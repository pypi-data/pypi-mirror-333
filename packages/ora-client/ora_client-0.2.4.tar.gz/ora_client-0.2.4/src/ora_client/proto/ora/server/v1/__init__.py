# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ora/server/v1/admin.proto, ora/server/v1/executor.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    TYPE_CHECKING,
    AsyncIterable,
    AsyncIterator,
    Dict,
    Iterable,
    List,
    Optional,
    Union,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common import v1 as __common_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class JobQueryOrder(betterproto.Enum):
    """The order of jobs returned."""

    UNSPECIFIED = 0
    """The order is unspecified."""

    CREATED_AT_ASC = 1
    """Order by the time the job was created in ascending order."""

    CREATED_AT_DESC = 2
    """Order by the time the job was created in descending order."""

    TARGET_EXECUTION_TIME_ASC = 3
    """Order by the target execution time in ascending order."""

    TARGET_EXECUTION_TIME_DESC = 4
    """Order by the target execution time in descending order."""


class JobExecutionStatus(betterproto.Enum):
    """The status of a job execution."""

    UNSPECIFIED = 0
    """The status is unspecified and depends on the implementation."""

    PENDING = 1
    """The job execution is pending and is not ready to run."""

    READY = 2
    """The job execution is ready to run."""

    ASSIGNED = 3
    """The job execution was assigned to an executor."""

    RUNNING = 4
    """The job execution is running."""

    SUCCEEDED = 5
    """The job execution is completed successfully."""

    FAILED = 6
    """The job execution is failed."""


class ScheduleQueryOrder(betterproto.Enum):
    """The order of schedules returned."""

    UNSPECIFIED = 0
    """The order is unspecified."""

    CREATED_AT_ASC = 1
    """Order by the time the schedule was created in ascending order."""

    CREATED_AT_DESC = 2
    """Order by the time the schedule was created in descending order."""


class LabelFilterExistCondition(betterproto.Enum):
    UNSPECIFIED = 0
    """The condition is unspecified."""

    EXISTS = 1
    """The label must exist."""


@dataclass(eq=False, repr=False)
class AddJobsRequest(betterproto.Message):
    """Request for `AddJobs`."""

    jobs: List["__common_v1__.JobDefinition"] = betterproto.message_field(1)
    """The jobs to add."""


@dataclass(eq=False, repr=False)
class AddJobsResponse(betterproto.Message):
    """Response for `AddJobs`."""

    job_ids: List[str] = betterproto.string_field(1)
    """The IDs of the added jobs."""


@dataclass(eq=False, repr=False)
class ListJobsRequest(betterproto.Message):
    """Request for `ListJobs`."""

    cursor: Optional[str] = betterproto.string_field(1, optional=True)
    """
    A cursor that can be used to continue a previous query.
    
     Note that if the cursor is present, filters
     and order may be ignored.
    """

    filter: "JobQueryFilter" = betterproto.message_field(2)
    """Filter the returned jobs."""

    order: Optional["JobQueryOrder"] = betterproto.enum_field(3, optional=True)
    """The order of the returned jobs."""

    limit: int = betterproto.uint32_field(4)
    """
    The maximum number of jobs to return.
    
     If the number is 0, the amount
     returned is unspecified.
    """


@dataclass(eq=False, repr=False)
class ListJobsResponse(betterproto.Message):
    """Response for `ListJobs`."""

    jobs: List["Job"] = betterproto.message_field(1)
    """A batch of jobs."""

    cursor: Optional[str] = betterproto.string_field(2, optional=True)
    """
    A cursor that can be used to continue a previous query.
    
     A cursor may be present even if there are no more
     jobs to return.
    
     Note that the format of the cursor is implementation-specific
     and should not be relied upon.
    """

    has_more: bool = betterproto.bool_field(3)
    """Whether there are more jobs to return."""


@dataclass(eq=False, repr=False)
class ListJobTypesRequest(betterproto.Message):
    """Request for `ListJobTypes`."""

    pass


@dataclass(eq=False, repr=False)
class ListJobTypesResponse(betterproto.Message):
    """Response for `ListJobTypes`."""

    job_types: List["__common_v1__.JobType"] = betterproto.message_field(1)
    """The job types."""


@dataclass(eq=False, repr=False)
class CountJobsRequest(betterproto.Message):
    """Request for `CountJobs`."""

    filter: "JobQueryFilter" = betterproto.message_field(1)
    """Filter the jobs to count."""


@dataclass(eq=False, repr=False)
class CountJobsResponse(betterproto.Message):
    """Response for `CountJobs`."""

    count: int = betterproto.uint64_field(1)
    """The number of jobs."""


@dataclass(eq=False, repr=False)
class CancelJobsRequest(betterproto.Message):
    """Request for `CancelJobs`."""

    filter: "JobQueryFilter" = betterproto.message_field(1)
    """The filter to select the jobs to cancel."""


@dataclass(eq=False, repr=False)
class CancelJobsResponse(betterproto.Message):
    """Response for `CancelJobs`."""

    job_ids: List[str] = betterproto.string_field(1)
    """The IDs of the cancelled jobs."""


@dataclass(eq=False, repr=False)
class DeleteInactiveJobsRequest(betterproto.Message):
    """Request for `DeleteInactiveJobs`."""

    filter: "JobQueryFilter" = betterproto.message_field(1)
    """The filter to select the jobs to remove."""


@dataclass(eq=False, repr=False)
class DeleteInactiveJobsResponse(betterproto.Message):
    """Response for `DeleteInactiveJobs`."""

    job_ids: List[str] = betterproto.string_field(1)
    """The IDs of the cleaned up jobs."""


@dataclass(eq=False, repr=False)
class ListExecutorsRequest(betterproto.Message):
    """Request for `ListExecutors`."""

    pass


@dataclass(eq=False, repr=False)
class ListExecutorsResponse(betterproto.Message):
    """Response for `ListExecutors`."""

    executors: List["ExecutorInfo"] = betterproto.message_field(1)
    """The executors."""


@dataclass(eq=False, repr=False)
class CreateSchedulesRequest(betterproto.Message):
    """Request for `CreateSchedules`."""

    schedules: List["__common_v1__.ScheduleDefinition"] = betterproto.message_field(1)
    """The schedules to create."""


@dataclass(eq=False, repr=False)
class CreateSchedulesResponse(betterproto.Message):
    """Response for `CreateSchedules`."""

    schedule_ids: List[str] = betterproto.string_field(1)
    """The IDs of the created schedules."""


@dataclass(eq=False, repr=False)
class ListSchedulesRequest(betterproto.Message):
    """Request for `ListSchedules`."""

    cursor: Optional[str] = betterproto.string_field(1, optional=True)
    """
    A cursor that can be used to continue a previous query.
    
     Note that if the cursor is present, filters
     and order may be ignored.
    """

    filter: "ScheduleQueryFilter" = betterproto.message_field(2)
    """Filter the returned schedules."""

    order: Optional["ScheduleQueryOrder"] = betterproto.enum_field(3, optional=True)
    """The order of the returned schedules."""

    limit: int = betterproto.uint32_field(4)
    """
    The maximum number of schedules to return.
    
     If the number is 0, the amount
     returned is unspecified.
    """


@dataclass(eq=False, repr=False)
class ListSchedulesResponse(betterproto.Message):
    """Response for `ListSchedules`."""

    schedules: List["Schedule"] = betterproto.message_field(1)
    """A batch of schedules."""

    cursor: Optional[str] = betterproto.string_field(2, optional=True)
    """
    A cursor that can be used to continue a previous query.
    
     A cursor may be present even if there are no more
     schedules to return.
    
     Note that the format of the cursor is implementation-specific
     and should not be relied upon.
    """

    has_more: bool = betterproto.bool_field(3)
    """Whether there are more schedules to return."""


@dataclass(eq=False, repr=False)
class CountSchedulesRequest(betterproto.Message):
    """Request for `CountSchedules`."""

    filter: "ScheduleQueryFilter" = betterproto.message_field(1)
    """Filter the schedules to count."""


@dataclass(eq=False, repr=False)
class CountSchedulesResponse(betterproto.Message):
    """Response for `CountSchedules`."""

    count: int = betterproto.uint64_field(1)
    """The number of schedules."""


@dataclass(eq=False, repr=False)
class CancelSchedulesRequest(betterproto.Message):
    """Request for `CancelSchedules`."""

    filter: "ScheduleQueryFilter" = betterproto.message_field(1)
    """The filter to select the schedules to cancel."""

    cancel_jobs: bool = betterproto.bool_field(2)
    """Whether to also cancel the jobs created by the schedules."""


@dataclass(eq=False, repr=False)
class CancelSchedulesResponse(betterproto.Message):
    """Response for `CancelSchedules`."""

    schedule_ids: List[str] = betterproto.string_field(1)
    """The IDs of the cancelled schedules."""

    job_ids: List[str] = betterproto.string_field(2)
    """
    The IDs of the cancelled jobs that were
     created by the schedules.
    """


@dataclass(eq=False, repr=False)
class DeleteInactiveSchedulesRequest(betterproto.Message):
    """Request for `DeleteInactiveSchedules`."""

    filter: "ScheduleQueryFilter" = betterproto.message_field(1)
    """The filter to select the schedules to remove."""


@dataclass(eq=False, repr=False)
class DeleteInactiveSchedulesResponse(betterproto.Message):
    """Response for `DeleteInactiveSchedules`."""

    schedule_ids: List[str] = betterproto.string_field(1)
    """The IDs of the cleaned up schedules."""


@dataclass(eq=False, repr=False)
class JobQueryFilter(betterproto.Message):
    """Filter of job queries."""

    job_ids: List[str] = betterproto.string_field(1)
    """
    The job IDs to filter by.
    
     If the list is empty, all jobs are included.
    """

    job_type_ids: List[str] = betterproto.string_field(2)
    """
    The job type IDs to filter by.
    
     If the list is empty, all job types are included.
    """

    execution_ids: List[str] = betterproto.string_field(3)
    """
    The execution IDs to filter by.
    
     If the list is empty, all executors are included.
    """

    schedule_ids: List[str] = betterproto.string_field(4)
    """
    The schedule IDs to filter by.
    
     If the list is empty, all schedules and jobs without
     schedules are included.
    """

    status: List["JobExecutionStatus"] = betterproto.enum_field(5)
    """
    A list of execution statuses to filter by.
     If the list is empty, all statuses are included.
    
     If a job has multiple executions, the last
     execution status is used.
    
     If a job has no executions, its status is
     considered to be pending.
    """

    labels: List["JobLabelFilter"] = betterproto.message_field(6)
    """
    A list of labels to filter by.
    
     If multiple filters are specified, all of them
     must match.
    """

    active: Optional[bool] = betterproto.bool_field(7, optional=True)
    """
    Only include active or inactive jobs.
    
     If not provided, all jobs are included.
    """

    target_execution_time: "__common_v1__.TimeRange" = betterproto.message_field(8)
    """
    Filter by the target execution time.
    
     The range can be open-ended in either direction.
    """

    created_at: "__common_v1__.TimeRange" = betterproto.message_field(9)
    """
    Filter by the time the job was created.
    
     The range can be open-ended in either direction.
    """


@dataclass(eq=False, repr=False)
class JobLabelFilter(betterproto.Message):
    """A job label filter."""

    key: str = betterproto.string_field(1)
    """The key of the label."""

    exists: "LabelFilterExistCondition" = betterproto.enum_field(2, group="value")
    """Whether the label should exist with any value."""

    equals: str = betterproto.string_field(3, group="value")
    """The value must be equal to the given value."""


@dataclass(eq=False, repr=False)
class Job(betterproto.Message):
    """A job."""

    id: str = betterproto.string_field(1)
    """The ID of the job."""

    schedule_id: Optional[str] = betterproto.string_field(2, optional=True)
    """The ID of the schedule that created the job."""

    definition: "__common_v1__.JobDefinition" = betterproto.message_field(3)
    """The job definition."""

    created_at: datetime = betterproto.message_field(4)
    """The time the job was created."""

    executions: List["JobExecution"] = betterproto.message_field(5)
    """All the executions of this job."""

    active: bool = betterproto.bool_field(6)
    """Whether the job is active."""

    cancelled: bool = betterproto.bool_field(7)
    """Whether the job was cancelled."""


@dataclass(eq=False, repr=False)
class JobExecution(betterproto.Message):
    id: str = betterproto.string_field(1)
    """The ID of the job execution."""

    job_id: str = betterproto.string_field(2)
    """The ID of the job."""

    executor_id: Optional[str] = betterproto.string_field(3, optional=True)
    """The ID of the associated executor."""

    status: "JobExecutionStatus" = betterproto.enum_field(4)
    """The status of the job execution."""

    created_at: datetime = betterproto.message_field(5)
    """The time the job execution was created."""

    ready_at: datetime = betterproto.message_field(6)
    """The time the job execution was marked as ready."""

    assigned_at: datetime = betterproto.message_field(7)
    """The time the job execution was assigned to an executor."""

    started_at: datetime = betterproto.message_field(8)
    """The time the job execution has started."""

    succeeded_at: datetime = betterproto.message_field(9)
    """The time the job execution has succeeded."""

    failed_at: datetime = betterproto.message_field(10)
    """The time the job execution has failed."""

    output_payload_json: Optional[str] = betterproto.string_field(11, optional=True)
    """The output payload of the execution."""

    failure_reason: Optional[str] = betterproto.string_field(12, optional=True)
    """The error message of the execution."""


@dataclass(eq=False, repr=False)
class ExecutorInfo(betterproto.Message):
    """Information about an executor."""

    id: str = betterproto.string_field(1)
    """The ID of the executor."""

    name: str = betterproto.string_field(2)
    """The name of the executor."""

    last_seen_at: datetime = betterproto.message_field(3)
    """The time the executor was last seen."""

    alive: bool = betterproto.bool_field(4)
    """Whether the executor is alive."""

    supported_job_type_ids: List[str] = betterproto.string_field(5)
    """The job types supported by the executor."""

    max_concurrent_executions: int = betterproto.uint32_field(6)
    """The maximum number of concurrent job executions."""

    assigned_execution_ids: List[str] = betterproto.string_field(7)
    """A list of execution IDs assigned to the executor."""


@dataclass(eq=False, repr=False)
class Schedule(betterproto.Message):
    """A schedule."""

    id: str = betterproto.string_field(1)
    """The ID of the schedule."""

    definition: "__common_v1__.ScheduleDefinition" = betterproto.message_field(2)
    """The schedule definition."""

    created_at: datetime = betterproto.message_field(3)
    """The time the schedule was created."""

    active: bool = betterproto.bool_field(5)
    """Whether the schedule is active."""

    cancelled: bool = betterproto.bool_field(6)
    """Whether the schedule was cancelled."""


@dataclass(eq=False, repr=False)
class ScheduleQueryFilter(betterproto.Message):
    """Filter of schedule queries."""

    schedule_ids: List[str] = betterproto.string_field(1)
    """
    The schedule IDs to filter by.
    
     If the list is empty, all schedules are included.
    """

    job_ids: List[str] = betterproto.string_field(2)
    """
    Filter by job IDs that
     are created by the schedules.
    
     If the list is empty, no filtering is done.
    """

    job_type_ids: List[str] = betterproto.string_field(3)
    """
    Filter by job type IDs of jobs
     that are created by the schedules (if applicable).
    
     If the list is empty, no filtering is done.
    """

    labels: List["ScheduleLabelFilter"] = betterproto.message_field(4)
    """
    A list of labels to filter by.
    
     If multiple filters are specified, all of them
     must match.
    """

    active: Optional[bool] = betterproto.bool_field(5, optional=True)
    """
    Only include active or inactive schedules.
    
     If not provided, all schedules are included.
    """

    created_at: "__common_v1__.TimeRange" = betterproto.message_field(6)
    """
    Filter by the time the schedule was created.
    
     The range can be open-ended in either direction.
    """


@dataclass(eq=False, repr=False)
class ScheduleLabelFilter(betterproto.Message):
    """A schedule label filter."""

    key: str = betterproto.string_field(1)
    """The key of the label."""

    exists: "LabelFilterExistCondition" = betterproto.enum_field(2, group="value")
    """Whether the label should exist with any value."""

    equals: str = betterproto.string_field(3, group="value")
    """The value must be equal to the given value."""


@dataclass(eq=False, repr=False)
class ExecutorConnectionRequest(betterproto.Message):
    """Request for `Heartbeat`."""

    message: "ExecutorMessage" = betterproto.message_field(1)
    """A message sent from the executor."""


@dataclass(eq=False, repr=False)
class ExecutorConnectionResponse(betterproto.Message):
    """Response for `Heartbeat`."""

    message: "ServerMessage" = betterproto.message_field(1)
    """A message sent from the server."""


@dataclass(eq=False, repr=False)
class ExecutorMessage(betterproto.Message):
    """A message sent from the executor."""

    capabilities: "ExecutorCapabilities" = betterproto.message_field(
        1, group="executor_message_kind"
    )
    """
    The capabilities of the executor.
    
     The executor must send the capabilities
     as the first message in the stream
     before any heartbeats, subsequent capabilities
     messages might be ignored.
    """

    heartbeat: "ExecutorHeartbeat" = betterproto.message_field(
        2, group="executor_message_kind"
    )
    """The heartbeat request."""

    execution_started: "ExecutionStarted" = betterproto.message_field(
        3, group="executor_message_kind"
    )
    """The job execution has started."""

    execution_succeeded: "ExecutionSucceeded" = betterproto.message_field(
        4, group="executor_message_kind"
    )
    """The execution has succeeded."""

    execution_failed: "ExecutionFailed" = betterproto.message_field(
        5, group="executor_message_kind"
    )
    """The execution has failed."""


@dataclass(eq=False, repr=False)
class ExecutorCapabilities(betterproto.Message):
    """
    Capabilities of the executor and other information
     that the server needs to know about the executor.
    """

    name: str = betterproto.string_field(1)
    """The name of the executor."""

    supported_job_types: List["__common_v1__.JobType"] = betterproto.message_field(2)
    """The supported job types."""

    max_concurrent_executions: int = betterproto.uint32_field(3)
    """
    The maximum number of concurrent job executions.
    
     The server will not assign more than `max_concurrent_executions`
     job executions at the same time.
    
     0 means no limit. Note that other than this currently
     there is no backpressure mechanism in place, a sensible
     limit is recommended in all cases.
    """


@dataclass(eq=False, repr=False)
class ExecutorHeartbeat(betterproto.Message):
    """The heartbeat content."""

    pass


@dataclass(eq=False, repr=False)
class ExecutionStarted(betterproto.Message):
    """The job execution has started."""

    execution_id: str = betterproto.string_field(1)
    """The ID of the job execution."""

    timestamp: datetime = betterproto.message_field(2)
    """The time when the job execution started."""


@dataclass(eq=False, repr=False)
class ExecutionSucceeded(betterproto.Message):
    """A job execution has succeeded."""

    execution_id: str = betterproto.string_field(1)
    """The ID of the job execution."""

    timestamp: datetime = betterproto.message_field(2)
    """The time when the job execution succeeded."""

    output_payload_json: str = betterproto.string_field(3)
    """The output payload of the job."""


@dataclass(eq=False, repr=False)
class ExecutionFailed(betterproto.Message):
    """The job execution has failed."""

    execution_id: str = betterproto.string_field(1)
    """The ID of the job execution."""

    timestamp: datetime = betterproto.message_field(2)
    """The time when the job execution failed."""

    error_message: str = betterproto.string_field(3)
    """The error message of the job."""


@dataclass(eq=False, repr=False)
class ServerMessage(betterproto.Message):
    """A message sent from the server."""

    properties: "ExecutorProperties" = betterproto.message_field(
        1, group="server_message_kind"
    )
    """The properties of the executor."""

    execution_ready: "ExecutionReady" = betterproto.message_field(
        2, group="server_message_kind"
    )
    """A job execution is ready to be executed by the executor."""

    execution_cancelled: "ExecutionCancelled" = betterproto.message_field(
        3, group="server_message_kind"
    )
    """
    The job execution was cancelled and should be dropped by the executor.
    """


@dataclass(eq=False, repr=False)
class ExecutorProperties(betterproto.Message):
    """Properties of the executor assigned by the server."""

    executor_id: str = betterproto.string_field(1)
    """The ID given to the executor."""

    max_heartbeat_interval: timedelta = betterproto.message_field(2)
    """
    The maximum interval between heartbeats.
    
     Executors should repeat the executor ping
     request at least every `max_heartbeat_interval`.
    
     Note that delays in the network or the server
     may cause the executor to miss the deadline,
     so the executor should send the heartbeat
     before the deadline to account for this.
    """


@dataclass(eq=False, repr=False)
class ExecutionReady(betterproto.Message):
    """A job execution is ready to be executed by the executor."""

    job_id: str = betterproto.string_field(1)
    """The ID of the job."""

    execution_id: str = betterproto.string_field(2)
    """The execution ID of the job."""

    job_type_id: str = betterproto.string_field(3)
    """The job type ID."""

    attempt_number: int = betterproto.uint64_field(4)
    """
    The attempt number of the job execution.
    
     The first attempt is 1.
    """

    input_payload_json: str = betterproto.string_field(5)
    """The input payload of the job."""

    target_execution_time: datetime = betterproto.message_field(6)
    """The target execution time of the job."""


@dataclass(eq=False, repr=False)
class ExecutionCancelled(betterproto.Message):
    """
    The job execution was cancelled and should be dropped by the executor.
    """

    execution_id: str = betterproto.string_field(1)
    """The ID of the job execution."""


class AdminServiceStub(betterproto.ServiceStub):
    async def add_jobs(
        self,
        add_jobs_request: "AddJobsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "AddJobsResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/AddJobs",
            add_jobs_request,
            AddJobsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_jobs(
        self,
        list_jobs_request: "ListJobsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListJobsResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/ListJobs",
            list_jobs_request,
            ListJobsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def count_jobs(
        self,
        count_jobs_request: "CountJobsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CountJobsResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/CountJobs",
            count_jobs_request,
            CountJobsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_job_types(
        self,
        list_job_types_request: "ListJobTypesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListJobTypesResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/ListJobTypes",
            list_job_types_request,
            ListJobTypesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_jobs(
        self,
        cancel_jobs_request: "CancelJobsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CancelJobsResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/CancelJobs",
            cancel_jobs_request,
            CancelJobsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_inactive_jobs(
        self,
        delete_inactive_jobs_request: "DeleteInactiveJobsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteInactiveJobsResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/DeleteInactiveJobs",
            delete_inactive_jobs_request,
            DeleteInactiveJobsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_executors(
        self,
        list_executors_request: "ListExecutorsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListExecutorsResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/ListExecutors",
            list_executors_request,
            ListExecutorsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_schedules(
        self,
        create_schedules_request: "CreateSchedulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CreateSchedulesResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/CreateSchedules",
            create_schedules_request,
            CreateSchedulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_schedules(
        self,
        list_schedules_request: "ListSchedulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "ListSchedulesResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/ListSchedules",
            list_schedules_request,
            ListSchedulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def count_schedules(
        self,
        count_schedules_request: "CountSchedulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CountSchedulesResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/CountSchedules",
            count_schedules_request,
            CountSchedulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_schedules(
        self,
        cancel_schedules_request: "CancelSchedulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "CancelSchedulesResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/CancelSchedules",
            cancel_schedules_request,
            CancelSchedulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_inactive_schedules(
        self,
        delete_inactive_schedules_request: "DeleteInactiveSchedulesRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "DeleteInactiveSchedulesResponse":
        return await self._unary_unary(
            "/ora.server.v1.AdminService/DeleteInactiveSchedules",
            delete_inactive_schedules_request,
            DeleteInactiveSchedulesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ExecutorServiceStub(betterproto.ServiceStub):
    async def executor_connection(
        self,
        executor_connection_request_iterator: Union[
            AsyncIterable[ExecutorConnectionRequest],
            Iterable[ExecutorConnectionRequest],
        ],
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> AsyncIterator[ExecutorConnectionResponse]:
        async for response in self._stream_stream(
            "/ora.server.v1.ExecutorService/ExecutorConnection",
            executor_connection_request_iterator,
            ExecutorConnectionRequest,
            ExecutorConnectionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class AdminServiceBase(ServiceBase):

    async def add_jobs(self, add_jobs_request: "AddJobsRequest") -> "AddJobsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_jobs(
        self, list_jobs_request: "ListJobsRequest"
    ) -> "ListJobsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def count_jobs(
        self, count_jobs_request: "CountJobsRequest"
    ) -> "CountJobsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_job_types(
        self, list_job_types_request: "ListJobTypesRequest"
    ) -> "ListJobTypesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_jobs(
        self, cancel_jobs_request: "CancelJobsRequest"
    ) -> "CancelJobsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_inactive_jobs(
        self, delete_inactive_jobs_request: "DeleteInactiveJobsRequest"
    ) -> "DeleteInactiveJobsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_executors(
        self, list_executors_request: "ListExecutorsRequest"
    ) -> "ListExecutorsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_schedules(
        self, create_schedules_request: "CreateSchedulesRequest"
    ) -> "CreateSchedulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_schedules(
        self, list_schedules_request: "ListSchedulesRequest"
    ) -> "ListSchedulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def count_schedules(
        self, count_schedules_request: "CountSchedulesRequest"
    ) -> "CountSchedulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_schedules(
        self, cancel_schedules_request: "CancelSchedulesRequest"
    ) -> "CancelSchedulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_inactive_schedules(
        self, delete_inactive_schedules_request: "DeleteInactiveSchedulesRequest"
    ) -> "DeleteInactiveSchedulesResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_add_jobs(
        self, stream: "grpclib.server.Stream[AddJobsRequest, AddJobsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.add_jobs(request)
        await stream.send_message(response)

    async def __rpc_list_jobs(
        self, stream: "grpclib.server.Stream[ListJobsRequest, ListJobsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_jobs(request)
        await stream.send_message(response)

    async def __rpc_count_jobs(
        self, stream: "grpclib.server.Stream[CountJobsRequest, CountJobsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.count_jobs(request)
        await stream.send_message(response)

    async def __rpc_list_job_types(
        self, stream: "grpclib.server.Stream[ListJobTypesRequest, ListJobTypesResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_job_types(request)
        await stream.send_message(response)

    async def __rpc_cancel_jobs(
        self, stream: "grpclib.server.Stream[CancelJobsRequest, CancelJobsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_jobs(request)
        await stream.send_message(response)

    async def __rpc_delete_inactive_jobs(
        self,
        stream: "grpclib.server.Stream[DeleteInactiveJobsRequest, DeleteInactiveJobsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_inactive_jobs(request)
        await stream.send_message(response)

    async def __rpc_list_executors(
        self,
        stream: "grpclib.server.Stream[ListExecutorsRequest, ListExecutorsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_executors(request)
        await stream.send_message(response)

    async def __rpc_create_schedules(
        self,
        stream: "grpclib.server.Stream[CreateSchedulesRequest, CreateSchedulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_schedules(request)
        await stream.send_message(response)

    async def __rpc_list_schedules(
        self,
        stream: "grpclib.server.Stream[ListSchedulesRequest, ListSchedulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_schedules(request)
        await stream.send_message(response)

    async def __rpc_count_schedules(
        self,
        stream: "grpclib.server.Stream[CountSchedulesRequest, CountSchedulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.count_schedules(request)
        await stream.send_message(response)

    async def __rpc_cancel_schedules(
        self,
        stream: "grpclib.server.Stream[CancelSchedulesRequest, CancelSchedulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_schedules(request)
        await stream.send_message(response)

    async def __rpc_delete_inactive_schedules(
        self,
        stream: "grpclib.server.Stream[DeleteInactiveSchedulesRequest, DeleteInactiveSchedulesResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_inactive_schedules(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/ora.server.v1.AdminService/AddJobs": grpclib.const.Handler(
                self.__rpc_add_jobs,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddJobsRequest,
                AddJobsResponse,
            ),
            "/ora.server.v1.AdminService/ListJobs": grpclib.const.Handler(
                self.__rpc_list_jobs,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListJobsRequest,
                ListJobsResponse,
            ),
            "/ora.server.v1.AdminService/CountJobs": grpclib.const.Handler(
                self.__rpc_count_jobs,
                grpclib.const.Cardinality.UNARY_UNARY,
                CountJobsRequest,
                CountJobsResponse,
            ),
            "/ora.server.v1.AdminService/ListJobTypes": grpclib.const.Handler(
                self.__rpc_list_job_types,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListJobTypesRequest,
                ListJobTypesResponse,
            ),
            "/ora.server.v1.AdminService/CancelJobs": grpclib.const.Handler(
                self.__rpc_cancel_jobs,
                grpclib.const.Cardinality.UNARY_UNARY,
                CancelJobsRequest,
                CancelJobsResponse,
            ),
            "/ora.server.v1.AdminService/DeleteInactiveJobs": grpclib.const.Handler(
                self.__rpc_delete_inactive_jobs,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteInactiveJobsRequest,
                DeleteInactiveJobsResponse,
            ),
            "/ora.server.v1.AdminService/ListExecutors": grpclib.const.Handler(
                self.__rpc_list_executors,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListExecutorsRequest,
                ListExecutorsResponse,
            ),
            "/ora.server.v1.AdminService/CreateSchedules": grpclib.const.Handler(
                self.__rpc_create_schedules,
                grpclib.const.Cardinality.UNARY_UNARY,
                CreateSchedulesRequest,
                CreateSchedulesResponse,
            ),
            "/ora.server.v1.AdminService/ListSchedules": grpclib.const.Handler(
                self.__rpc_list_schedules,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListSchedulesRequest,
                ListSchedulesResponse,
            ),
            "/ora.server.v1.AdminService/CountSchedules": grpclib.const.Handler(
                self.__rpc_count_schedules,
                grpclib.const.Cardinality.UNARY_UNARY,
                CountSchedulesRequest,
                CountSchedulesResponse,
            ),
            "/ora.server.v1.AdminService/CancelSchedules": grpclib.const.Handler(
                self.__rpc_cancel_schedules,
                grpclib.const.Cardinality.UNARY_UNARY,
                CancelSchedulesRequest,
                CancelSchedulesResponse,
            ),
            "/ora.server.v1.AdminService/DeleteInactiveSchedules": grpclib.const.Handler(
                self.__rpc_delete_inactive_schedules,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteInactiveSchedulesRequest,
                DeleteInactiveSchedulesResponse,
            ),
        }


class ExecutorServiceBase(ServiceBase):

    async def executor_connection(
        self,
        executor_connection_request_iterator: AsyncIterator[ExecutorConnectionRequest],
    ) -> AsyncIterator[ExecutorConnectionResponse]:
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield ExecutorConnectionResponse()

    async def __rpc_executor_connection(
        self,
        stream: "grpclib.server.Stream[ExecutorConnectionRequest, ExecutorConnectionResponse]",
    ) -> None:
        request = stream.__aiter__()
        await self._call_rpc_handler_server_stream(
            self.executor_connection,
            stream,
            request,
        )

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/ora.server.v1.ExecutorService/ExecutorConnection": grpclib.const.Handler(
                self.__rpc_executor_connection,
                grpclib.const.Cardinality.STREAM_STREAM,
                ExecutorConnectionRequest,
                ExecutorConnectionResponse,
            ),
        }
