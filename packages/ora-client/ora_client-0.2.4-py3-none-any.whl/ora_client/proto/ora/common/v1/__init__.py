# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ora/common/v1/job.proto, ora/common/v1/schedule.proto, ora/common/v1/time_range.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from datetime import (
    datetime,
    timedelta,
)
from typing import (
    List,
    Optional,
)

import betterproto


class JobTimeoutBaseTime(betterproto.Enum):
    """The base time for the timeout."""

    UNSPECIFIED = 0
    """The base time is unspecified and depends on the implementation."""

    TARGET_EXECUTION_TIME = 1
    """
    The base time is the target execution time of the job.
    
     Note that if the target execution time is not set,
     the timeout is calculated from the start time of the job.
    
     If the target execution time is in the past,
     the jobs may be immediately timed out.
    """

    START_TIME = 2
    """The base time is the start time of the job."""


class ScheduleMissedTimePolicy(betterproto.Enum):
    UNSPECIFIED = 0
    """The policy is unspecified."""

    SKIP = 1
    """Skip the missed times."""

    CREATE = 2
    """Create a job for each missed time."""


@dataclass(eq=False, repr=False)
class JobType(betterproto.Message):
    """Definition of a job type."""

    id: str = betterproto.string_field(1)
    """The ID of the job type."""

    name: Optional[str] = betterproto.string_field(2, optional=True)
    """The name of the job type."""

    description: Optional[str] = betterproto.string_field(3, optional=True)
    """The description of the job type."""

    input_schema_json: Optional[str] = betterproto.string_field(4, optional=True)
    """The input JSON schema of the job type."""

    output_schema_json: Optional[str] = betterproto.string_field(5, optional=True)
    """The output JSON schema of the job type."""


@dataclass(eq=False, repr=False)
class JobDefinition(betterproto.Message):
    """Definition of a job."""

    job_type_id: str = betterproto.string_field(1)
    """The ID of the job type."""

    target_execution_time: datetime = betterproto.message_field(2)
    """
    The target execution time of the job.
    
     If not provided, it should be set to the current time.
    """

    input_payload_json: str = betterproto.string_field(3)
    """The job input payload JSON that is passed to the executor."""

    labels: List["JobLabel"] = betterproto.message_field(4)
    """The labels of the job."""

    timeout_policy: "JobTimeoutPolicy" = betterproto.message_field(5)
    """The timeout policy of the job."""

    retry_policy: "JobRetryPolicy" = betterproto.message_field(6)
    """Retry policy for the job."""

    metadata_json: Optional[str] = betterproto.string_field(7, optional=True)
    """Arbitrary metadata in JSON format."""


@dataclass(eq=False, repr=False)
class JobLabel(betterproto.Message):
    """
    A label for a job.

     Labels can be used to categorize, filter,
     and group jobs.

     Any arbitrary metadata can be stored in a label.
    """

    key: str = betterproto.string_field(1)
    """
    The key of the label.
    
     The key must be unique within the job.
     The handling of duplicate keys is undefined
     and depends on the implementation.
    """

    value: str = betterproto.string_field(2)
    """The value of the label."""


@dataclass(eq=False, repr=False)
class JobTimeoutPolicy(betterproto.Message):
    """Timeout policy for a job."""

    timeout: timedelta = betterproto.message_field(1)
    """The timeout for the job."""

    base_time: "JobTimeoutBaseTime" = betterproto.enum_field(2)
    """
    The base time for the timeout.
    
     The timeout is calculated from this time.
    """


@dataclass(eq=False, repr=False)
class JobRetryPolicy(betterproto.Message):
    """Retry policy for a job."""

    retries: int = betterproto.uint64_field(1)
    """
    The number of retries for the job.
    
     If the number of retries is zero, the job is not retried.
    """


@dataclass(eq=False, repr=False)
class TimeRange(betterproto.Message):
    """
    A time range.

     A time range is a range of time between two points.

     The time range is inclusive of the start time and exclusive of the end time.
    """

    start: datetime = betterproto.message_field(1)
    """
    The start time of the time range.
    
     If not provided, the time range is open-ended.
    """

    end: datetime = betterproto.message_field(2)
    """
    The end time of the time range.
    
     If not provided, the time range is open-ended.
    """


@dataclass(eq=False, repr=False)
class InclusiveTimeRange(betterproto.Message):
    """
    An inclusive time range.

     An inclusive time range is a range of time between two points.

     The time range is inclusive of the start time and the end time.
    """

    start: datetime = betterproto.message_field(1)
    """
    The start time of the time range.
    
     If not provided, the time range is open-ended.
    """

    end: datetime = betterproto.message_field(2)
    """
    The end time of the time range.
    
     If not provided, the time range is open-ended.
    """


@dataclass(eq=False, repr=False)
class ScheduleDefinition(betterproto.Message):
    """
    A schedule is a tool for executing jobs at a specific times.

     Schedules create new jobs based on various criteria.
    """

    job_timing_policy: "ScheduleJobTimingPolicy" = betterproto.message_field(1)
    """The timing policy for the schedule."""

    job_creation_policy: "ScheduleJobCreationPolicy" = betterproto.message_field(2)
    """The policy for creating new jobs."""

    labels: List["ScheduleLabel"] = betterproto.message_field(3)
    """The labels of the schedule."""

    time_range: "TimeRange" = betterproto.message_field(4)
    """
    The time range for the schedule.
    
     The schedule will not create jobs outside of the time range.
     If the time range is not provided, the schedule will create jobs
     indefinitely.
    """

    metadata_json: Optional[str] = betterproto.string_field(5, optional=True)
    """Arbitrary metadata in JSON format."""


@dataclass(eq=False, repr=False)
class ScheduleJobTimingPolicy(betterproto.Message):
    repeat: "ScheduleJobTimingPolicyRepeat" = betterproto.message_field(
        1, group="job_timing"
    )
    """Repeat jobs with a given interval."""

    cron: "ScheduleJobTimingPolicyCron" = betterproto.message_field(
        2, group="job_timing"
    )
    """Repeat jobs with a given cron expression."""


@dataclass(eq=False, repr=False)
class ScheduleJobTimingPolicyRepeat(betterproto.Message):
    """Repeat jobs with a given interval."""

    interval: timedelta = betterproto.message_field(1)
    """The interval between each job."""

    immediate: bool = betterproto.bool_field(2)
    """
    Whether to immediately create a job
     when the schedule is created.
    """

    missed_time_policy: "ScheduleMissedTimePolicy" = betterproto.enum_field(3)
    """The policy for missed jobs."""


@dataclass(eq=False, repr=False)
class ScheduleJobTimingPolicyCron(betterproto.Message):
    """Repeat jobs with a given cron expression."""

    cron_expression: str = betterproto.string_field(1)
    """
    The cron expression for the schedule.
    
     The reference implementation uses the cron expression
     format supported by the `cronexpr` Rust crate (<https://docs.rs/cronexpr/latest/cronexpr/>).
    """

    immediate: bool = betterproto.bool_field(2)
    """
    Whether to immediately create a job
     when the schedule is created.
    """

    missed_time_policy: "ScheduleMissedTimePolicy" = betterproto.enum_field(3)
    """The policy for missed jobs."""


@dataclass(eq=False, repr=False)
class ScheduleJobCreationPolicy(betterproto.Message):
    """The policy that defines how new jobs are created."""

    job_definition: "JobDefinition" = betterproto.message_field(1, group="job_creation")
    """
    Create new jobs from a given definition,
     the target execution time is altered for each job.
    """


@dataclass(eq=False, repr=False)
class ScheduleLabel(betterproto.Message):
    """
    A label for a schedule.

     Labels can be used to categorize, filter,
     and group schedules.

     Any arbitrary metadata can be stored in a label.
    """

    key: str = betterproto.string_field(1)
    """
    The key of the label.
    
     The key must be unique within the schedule.
     The handling of duplicate keys is undefined
     and depends on the implementation.
    """

    value: str = betterproto.string_field(2)
    """The value of the label."""
