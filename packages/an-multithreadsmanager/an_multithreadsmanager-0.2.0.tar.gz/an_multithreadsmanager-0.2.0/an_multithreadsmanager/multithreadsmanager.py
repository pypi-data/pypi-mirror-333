# -*- coding: utf-8 -*-
"""MTHM_20250314_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BhJzMEwjiuXiPC4y6YGHhO1IN0w2gT53

# MultiThreadsManager
並列処理をサポートするクラス


```
2025/03/12 0.1.0完成。mtcopy実装。並列処理でコピーをスピード処理する。
2025/03/14 0.2.0 mycopyでサブフォルダもコピーできるようにした。
```

# MultiThreadsManager

## 1. モジュール定義
"""

# @title a. MultiThreadsManager 定義

import os
import shutil
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

class MultiThreadsManager:
    def __init__(self, max_workers=None):
        """
        コンストラクタ: スレッド数上限を指定可能。
        max_workersを指定しない場合、ThreadPoolExecutorのデフォルト値が使用される。
        """
        self.max_workers = max_workers

    def mtcopy(self, src_dir: str, dst_dir: str, desc="Copying"):
        """
        src_dir 内の全ファイル（再帰的に検索）を、dst_dir に並列コピーする。
        ファイルの相対パスを保持して、サブフォルダも含めてコピーします。
        コピー中に失敗したファイルがあればエラーメッセージを表示します。
        """
        # find コマンドでファイル一覧を取得
        try:
            result = subprocess.run(
                ["find", src_dir, "-type", "f"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
            file_paths = result.stdout.strip().splitlines()
        except Exception as e:
            raise RuntimeError(f"コピー元ディレクトリのファイル一覧取得に失敗しました: {e}")

        total_files = len(file_paths)
        if total_files == 0:
            print("コピーするファイルがありません。")
            return

        with tqdm(total=total_files, desc=desc, unit="files") as pbar:
            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                futures = []
                for f in file_paths:
                    # f は絶対パス。src_dir に対する相対パスを求める
                    rel_path = os.path.relpath(f, src_dir)
                    dst_path = os.path.join(dst_dir, rel_path)
                    # コピー先のディレクトリが存在しない場合は作成
                    os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                    futures.append(executor.submit(shutil.copy2, f, dst_path))
                for future in as_completed(futures):
                    try:
                        future.result()
                    except Exception as e:
                        tqdm.write(f"コピー失敗: {e}")
                    finally:
                        pbar.update(1)

"""## 2. テスト"""

# @title a. MultiThreadsManager テスト
import shutil
from google.colab import drive
drive.mount('/content/drive')

base_dst_dir = "/content/cEnv"
venv_src_dir = '/content/drive/MyDrive/cEnv/venv/kohya_env/'
venv_dst_dir = '/content/cEnv/venv/kohya_env/'
kohya_src_dir = "/content/drive/MyDrive/cEnv/app/kohya_ss/"
kohya_dst_dir = "/content/cEnv/app/kohya_ss/"

if __name__ == '__main__':
    shutil.rmtree( base_dst_dir, ignore_errors = True )
    # os.makedirs( dst_dir, exist_ok = True )
    mtmanager = MultiThreadsManager( max_workers = 16 )
    mtmanager.mtcopy( venv_src_dir, venv_dst_dir, desc = "venv")
#    mtmanager.mtcopy( kohya_src_dir, kohya_dst_dir, desc = "kohya" )
#    shutil.rmtree( "/content/cEnv/venv/kohya_env3", ignore_errors = True )
#    os.makedirs( "/content/cEnv/venv/kohya_env3", exist_ok = True )
#    !rsync -a --info=progress2 /content/drive/MyDrive/cEnv/venv/kohya_env/ /content/cEnv/venv/kohya_env3/