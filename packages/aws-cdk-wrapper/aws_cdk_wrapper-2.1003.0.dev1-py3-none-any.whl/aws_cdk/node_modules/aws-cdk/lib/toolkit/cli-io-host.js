"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliIoHost = exports.levelPriority = void 0;
exports.isCI = isCI;
const util = require("node:util");
const chalk = require("chalk");
const promptly = require("promptly");
const error_1 = require("./error");
const activity_printer_1 = require("../cli/activity-printer");
const deploy_1 = require("../commands/deploy");
exports.levelPriority = {
    error: 0,
    result: 1,
    warn: 2,
    info: 3,
    debug: 4,
    trace: 5,
};
/**
 * A simple IO host for the CLI that writes messages to the console.
 */
class CliIoHost {
    /**
     * Returns the singleton instance
     */
    static instance(props = {}, forceNew = false) {
        if (forceNew || !CliIoHost._instance) {
            CliIoHost._instance = new CliIoHost(props);
        }
        return CliIoHost._instance;
    }
    constructor(props = {}) {
        var _a, _b, _c, _d, _e, _f;
        this._progress = deploy_1.StackActivityProgress.BAR;
        // Corked Logging
        this.corkedCounter = 0;
        this.corkedLoggingBuffer = [];
        this._currentAction = (_a = props.currentAction) !== null && _a !== void 0 ? _a : 'none';
        this._isTTY = (_c = (_b = props.isTTY) !== null && _b !== void 0 ? _b : process.stdout.isTTY) !== null && _c !== void 0 ? _c : false;
        this._logLevel = (_d = props.logLevel) !== null && _d !== void 0 ? _d : 'info';
        this._isCI = (_e = props.isCI) !== null && _e !== void 0 ? _e : isCI();
        this.stackProgress = (_f = props.stackProgress) !== null && _f !== void 0 ? _f : deploy_1.StackActivityProgress.BAR;
    }
    /**
     * Returns the singleton instance
     */
    registerIoHost(ioHost) {
        if (ioHost !== this) {
            this._internalIoHost = ioHost;
        }
    }
    /**
     * Update the stackProgress preference.
     */
    set stackProgress(type) {
        this._progress = type;
    }
    /**
     * Gets the stackProgress value.
     *
     * This takes into account other state of the ioHost,
     * like if isTTY and isCI.
     */
    get stackProgress() {
        // We can always use EVENTS
        if (this._progress === deploy_1.StackActivityProgress.EVENTS) {
            return this._progress;
        }
        // if log level is tracing or debug, we default to the full history printer
        const verboseLogging = exports.levelPriority[this.logLevel] > exports.levelPriority.info;
        if (verboseLogging) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On Windows we cannot use fancy output
        const isWindows = process.platform === 'win32';
        if (isWindows) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On some CI systems (such as CircleCI) output still reports as a TTY so we also
        // need an individual check for whether we're running on CI.
        // see: https://discuss.circleci.com/t/circleci-terminal-is-a-tty-but-term-is-not-set/9965
        const fancyOutputAvailable = this.isTTY && !this.isCI;
        if (!fancyOutputAvailable) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // Use the user preference
        return this._progress;
    }
    /**
     * The current action being performed by the CLI.
     */
    get currentAction() {
        return this._currentAction;
    }
    /**
     * Sets the current action being performed by the CLI.
     *
     * @param action The action being performed by the CLI.
     */
    set currentAction(action) {
        this._currentAction = action;
    }
    /**
     * Whether the host can use interactions and message styling.
     */
    get isTTY() {
        return this._isTTY;
    }
    /**
     * Set TTY mode, i.e can the host use interactions and message styling.
     *
     * @param value set TTY mode
     */
    set isTTY(value) {
        this._isTTY = value;
    }
    /**
     * Whether the CliIoHost is running in CI mode. In CI mode, all non-error output goes to stdout instead of stderr.
     */
    get isCI() {
        return this._isCI;
    }
    /**
     * Set the CI mode. In CI mode, all non-error output goes to stdout instead of stderr.
     * @param value set the CI mode
     */
    set isCI(value) {
        this._isCI = value;
    }
    /**
     * The current threshold. Messages with a lower priority level will be ignored.
     */
    get logLevel() {
        return this._logLevel;
    }
    /**
     * Sets the current threshold. Messages with a lower priority level will be ignored.
     * @param level The new log level threshold
     */
    set logLevel(level) {
        this._logLevel = level;
    }
    /**
     * Executes a block of code with corked logging. All log messages during execution
     * are buffered and only written when all nested cork blocks complete (when CORK_COUNTER reaches 0).
     * The corking is bound to the specific instance of the CliIoHost.
     *
     * @param block - Async function to execute with corked logging
     * @returns Promise that resolves with the block's return value
     */
    async withCorkedLogging(block) {
        this.corkedCounter++;
        try {
            return await block();
        }
        finally {
            this.corkedCounter--;
            if (this.corkedCounter === 0) {
                // Process each buffered message through notify
                for (const ioMessage of this.corkedLoggingBuffer) {
                    await this.notify(ioMessage);
                }
                // remove all buffered messages in-place
                this.corkedLoggingBuffer.splice(0);
            }
        }
    }
    /**
     * Notifies the host of a message.
     * The caller waits until the notification completes.
     */
    async notify(msg) {
        if (this._internalIoHost) {
            return this._internalIoHost.notify(msg);
        }
        if (this.isStackActivity(msg)) {
            if (!this.activityPrinter) {
                this.activityPrinter = this.makeActivityPrinter();
            }
            await this.activityPrinter.notify(msg);
            return;
        }
        if (exports.levelPriority[msg.level] > exports.levelPriority[this.logLevel]) {
            return;
        }
        if (this.corkedCounter > 0) {
            this.corkedLoggingBuffer.push(msg);
            return;
        }
        const output = this.formatMessage(msg);
        const stream = this.selectStream(msg.level);
        stream.write(output);
    }
    /**
     * Detect stack activity messages so they can be send to the printer.
     */
    isStackActivity(msg) {
        return [
            'CDK_TOOLKIT_I5501',
            'CDK_TOOLKIT_I5502',
            'CDK_TOOLKIT_I5503',
        ].includes(msg.code);
    }
    /**
     * Determines the output stream, based on message level and configuration.
     */
    selectStream(level) {
        // The stream selection policy for the CLI is the following:
        //
        //   (1) Messages of level `result` always go to `stdout`
        //   (2) Messages of level `error` always go to `stderr`.
        //   (3a) All remaining messages go to `stderr`.
        //   (3b) If we are in CI mode, all remaining messages go to `stdout`.
        //
        switch (level) {
            case 'error':
                return process.stderr;
            case 'result':
                return process.stdout;
            default:
                return this.isCI ? process.stdout : process.stderr;
        }
    }
    /**
     * Notifies the host of a message that requires a response.
     *
     * If the host does not return a response the suggested
     * default response from the input message will be used.
     */
    async requestResponse(msg) {
        // First call out to a registered instance if we have one
        if (this._internalIoHost) {
            return this._internalIoHost.requestResponse(msg);
        }
        // If the request cannot be prompted for by the CliIoHost, we just accept the default
        if (!isPromptableRequest(msg)) {
            await this.notify(msg);
            return msg.defaultResponse;
        }
        const response = await this.withCorkedLogging(async () => {
            var _a, _b, _c;
            // prepare prompt data
            // @todo this format is not defined anywhere, probably should be
            const data = (_a = msg.data) !== null && _a !== void 0 ? _a : {};
            const motivation = (_b = data.motivation) !== null && _b !== void 0 ? _b : 'User input is needed';
            const concurrency = (_c = data.concurrency) !== null && _c !== void 0 ? _c : 0;
            // only talk to user if STDIN is a terminal (otherwise, fail)
            if (!this.isTTY) {
                throw new error_1.ToolkitError(`${motivation}, but terminal (TTY) is not attached so we are unable to get a confirmation from the user`);
            }
            // only talk to user if concurrency is 1 (otherwise, fail)
            if (concurrency > 1) {
                throw new error_1.ToolkitError(`${motivation}, but concurrency is greater than 1 so we are unable to get a confirmation from the user`);
            }
            // Basic confirmation prompt
            // We treat all requests with a boolean response as confirmation prompts
            if (isConfirmationPrompt(msg)) {
                const confirmed = await promptly.confirm(`${chalk.cyan(msg.message)} (y/n)`);
                if (!confirmed) {
                    throw new error_1.ToolkitError('Aborted by user');
                }
                return confirmed;
            }
            // Asking for a specific value
            const prompt = extractPromptInfo(msg);
            const answer = await promptly.prompt(`${chalk.cyan(msg.message)} (${prompt.default})`, {
                default: prompt.default,
            });
            return prompt.convertAnswer(answer);
        });
        // We need to cast this because it is impossible to narrow the generic type
        // isPromptableRequest ensures that the response type is one we can prompt for
        // the remaining code ensure we are indeed returning the correct type
        return response;
    }
    /**
     * Formats a message for console output with optional color support
     */
    formatMessage(msg) {
        // apply provided style or a default style if we're in TTY mode
        let message_text = this._isTTY
            ? styleMap[msg.level](msg.message)
            : msg.message;
        // prepend timestamp if IoMessageLevel is DEBUG or TRACE. Postpend a newline.
        return ((msg.level === 'debug' || msg.level === 'trace')
            ? `[${this.formatTime(msg.time)}] ${message_text}`
            : message_text) + '\n';
    }
    /**
     * Formats date to HH:MM:SS
     */
    formatTime(d) {
        const pad = (n) => n.toString().padStart(2, '0');
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
    /**
     * Get an instance of the ActivityPrinter
     */
    makeActivityPrinter() {
        const props = {
            stream: this.selectStream('info'),
        };
        switch (this.stackProgress) {
            case deploy_1.StackActivityProgress.EVENTS:
                return new activity_printer_1.HistoryActivityPrinter(props);
            case deploy_1.StackActivityProgress.BAR:
                return new activity_printer_1.CurrentActivityPrinter(props);
        }
    }
}
exports.CliIoHost = CliIoHost;
/**
 * This IoHost implementation considers a request promptable, if:
 * - it's a yes/no confirmation
 * - asking for a string or number value
 */
function isPromptableRequest(msg) {
    return isConfirmationPrompt(msg)
        || typeof msg.defaultResponse === 'string'
        || typeof msg.defaultResponse === 'number';
}
/**
 * Check if the request is a confirmation prompt
 * We treat all requests with a boolean response as confirmation prompts
 */
function isConfirmationPrompt(msg) {
    return typeof msg.defaultResponse === 'boolean';
}
/**
 * Helper to extract information for promptly from the request
 */
function extractPromptInfo(msg) {
    const isNumber = (typeof msg.defaultResponse === 'number');
    return {
        default: util.format(msg.defaultResponse),
        convertAnswer: isNumber ? (v) => Number(v) : (v) => String(v),
    };
}
const styleMap = {
    error: chalk.red,
    warn: chalk.yellow,
    result: chalk.white,
    info: chalk.white,
    debug: chalk.gray,
    trace: chalk.gray,
};
/**
 * Returns true if the current process is running in a CI environment
 * @returns true if the current process is running in a CI environment
 */
function isCI() {
    return process.env.CI !== undefined && process.env.CI !== 'false' && process.env.CI !== '0';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWlvLWhvc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbGktaW8taG9zdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFzakJBLG9CQUVDO0FBeGpCRCxrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQyxtQ0FBdUM7QUFDdkMsOERBQWlJO0FBQ2pJLCtDQUEyRDtBQWlFOUMsUUFBQSxhQUFhLEdBQW1DO0lBQzNELEtBQUssRUFBRSxDQUFDO0lBQ1IsTUFBTSxFQUFFLENBQUM7SUFDVCxJQUFJLEVBQUUsQ0FBQztJQUNQLElBQUksRUFBRSxDQUFDO0lBQ1AsS0FBSyxFQUFFLENBQUM7SUFDUixLQUFLLEVBQUUsQ0FBQztDQUNULENBQUM7QUErRkY7O0dBRUc7QUFDSCxNQUFhLFNBQVM7SUFDcEI7O09BRUc7SUFDSCxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQXdCLEVBQUUsRUFBRSxRQUFRLEdBQUcsS0FBSztRQUMxRCxJQUFJLFFBQVEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNyQyxTQUFTLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdDLENBQUM7UUFDRCxPQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUM7SUFDN0IsQ0FBQztJQXNCRCxZQUFvQixRQUF3QixFQUFFOztRQVR0QyxjQUFTLEdBQTBCLDhCQUFxQixDQUFDLEdBQUcsQ0FBQztRQUtyRSxpQkFBaUI7UUFDVCxrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUNULHdCQUFtQixHQUFxQixFQUFFLENBQUM7UUFHMUQsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFBLEtBQUssQ0FBQyxhQUFhLG1DQUFJLE1BQXVCLENBQUM7UUFDckUsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFBLE1BQUEsS0FBSyxDQUFDLEtBQUssbUNBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLG1DQUFJLEtBQUssQ0FBQztR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QUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQztRQUN6QyxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUM5RCxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sUUFBUSxHQUFvRDtJQUNoRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEdBQUc7SUFDaEIsSUFBSSxFQUFFLEtBQUssQ0FBQyxNQUFNO0lBQ2xCLE1BQU0sRUFBRSxLQUFLLENBQUMsS0FBSztJQUNuQixJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQUs7SUFDakIsS0FBSyxFQUFFLEtBQUssQ0FBQyxJQUFJO0lBQ2pCLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSTtDQUNsQixDQUFDO0FBRUY7OztHQUdHO0FBQ0gsU0FBZ0IsSUFBSTtJQUNsQixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLFNBQVMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxPQUFPLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQzlGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJ25vZGU6dXRpbCc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IEFjdGl2aXR5UHJpbnRlclByb3BzLCBDdXJyZW50QWN0aXZpdHlQcmludGVyLCBIaXN0b3J5QWN0aXZpdHlQcmludGVyLCBJQWN0aXZpdHlQcmludGVyIH0gZnJvbSAnLi4vY2xpL2FjdGl2aXR5LXByaW50ZXInO1xuaW1wb3J0IHsgU3RhY2tBY3Rpdml0eVByb2dyZXNzIH0gZnJvbSAnLi4vY29tbWFuZHMvZGVwbG95JztcblxuZXhwb3J0IHR5cGUgSW9NZXNzYWdlQ29kZUNhdGVnb3J5ID0gJ1RPT0xLSVQnIHwgJ1NESycgfCAnQVNTRVRTJztcbmV4cG9ydCB0eXBlIElvQ29kZUxldmVsID0gJ0UnIHwgJ1cnIHwgJ0knO1xuZXhwb3J0IHR5cGUgSW9NZXNzYWdlU3BlY2lmaWNDb2RlPEwgZXh0ZW5kcyBJb0NvZGVMZXZlbD4gPSBgQ0RLXyR7SW9NZXNzYWdlQ29kZUNhdGVnb3J5fV8ke0x9JHtudW1iZXJ9JHtudW1iZXJ9JHtudW1iZXJ9JHtudW1iZXJ9YDtcbmV4cG9ydCB0eXBlIElvTWVzc2FnZUNvZGUgPSBJb01lc3NhZ2VTcGVjaWZpY0NvZGU8SW9Db2RlTGV2ZWw+O1xuXG4vKipcbiAqIEJhc2ljIG1lc3NhZ2Ugc3RydWN0dXJlIGZvciB0b29sa2l0IG5vdGlmaWNhdGlvbnMuXG4gKiBNZXNzYWdlcyBhcmUgZW1pdHRlZCBieSB0aGUgdG9vbGtpdCBhbmQgaGFuZGxlZCBieSB0aGUgSW9Ib3N0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElvTWVzc2FnZTxUPiB7XG4gIC8qKlxuICAgKiBUaGUgdGltZSB0aGUgbWVzc2FnZSB3YXMgZW1pdHRlZC5cbiAgICovXG4gIHJlYWRvbmx5IHRpbWU6IERhdGU7XG5cbiAgLyoqXG4gICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICByZWFkb25seSBsZXZlbDogSW9NZXNzYWdlTGV2ZWw7XG5cbiAgLyoqXG4gICAqIFRoZSBhY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhlIG1lc3NhZ2UuXG4gICAqL1xuICByZWFkb25seSBhY3Rpb246IFRvb2xraXRBY3Rpb247XG5cbiAgLyoqXG4gICAqIEEgc2hvcnQgbWVzc2FnZSBjb2RlIHVuaXF1ZWx5IGlkZW50aWZ5aW5nIGEgbWVzc2FnZSB0eXBlIHVzaW5nIHRoZSBmb3JtYXQgQ0RLX1tDQVRFR09SWV1fW0UvVy9JXVswMDAtOTk5XS5cbiAgICpcbiAgICogVGhlIGxldmVsIGluZGljYXRvciBmb2xsb3dzIHRoZXNlIHJ1bGVzOlxuICAgKiAtICdFJyBmb3IgZXJyb3IgbGV2ZWwgbWVzc2FnZXNcbiAgICogLSAnVycgZm9yIHdhcm5pbmcgbGV2ZWwgbWVzc2FnZXNcbiAgICogLSAnSScgZm9yIGluZm8vZGVidWcvdHJhY2UgbGV2ZWwgbWVzc2FnZXNcbiAgICpcbiAgICogQ29kZXMgZW5kaW5nIGluIDAwMCBhcmUgZ2VuZXJpYyBtZXNzYWdlcywgd2hpbGUgY29kZXMgZW5kaW5nIGluIDAwMS05OTkgYXJlIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBtZXNzYWdlLlxuICAgKiBUaGUgZm9sbG93aW5nIGFyZSBleGFtcGxlcyBvZiB2YWxpZCBhbmQgaW52YWxpZCBtZXNzYWdlIGNvZGVzOlxuICAgKiBgYGB0c1xuICAgKiAnQ0RLX0FTU0VUU19JMDAwJyAgICAgICAvLyB2YWxpZDogZ2VuZXJpYyBhc3NldHMgaW5mbyBtZXNzYWdlXG4gICAqICdDREtfVE9PTEtJVF9FMDAyJyAgICAgIC8vIHZhbGlkOiBzcGVjaWZpYyB0b29sa2l0IGVycm9yIG1lc3NhZ2VcbiAgICogJ0NES19TREtfVzAyMycgICAgICAgICAgLy8gdmFsaWQ6IHNwZWNpZmljIHNkayB3YXJuaW5nIG1lc3NhZ2VcbiAgICogYGBgXG4gICAqL1xuICByZWFkb25seSBjb2RlOiBJb01lc3NhZ2VDb2RlO1xuXG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSB0ZXh0LlxuICAgKi9cbiAgcmVhZG9ubHkgbWVzc2FnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZGF0YSBhdHRhY2hlZCB0byB0aGUgbWVzc2FnZS5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE/OiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElvUmVxdWVzdDxULCBVPiBleHRlbmRzIElvTWVzc2FnZTxUPiB7XG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCByZXNwb25zZSB0aGF0IHdpbGwgYmUgdXNlZCBpZiBubyBkYXRhIGlzIHJldHVybmVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZGVmYXVsdFJlc3BvbnNlOiBVO1xufVxuXG5leHBvcnQgdHlwZSBJb01lc3NhZ2VMZXZlbCA9ICdlcnJvcicgfCAncmVzdWx0JyB8ICd3YXJuJyB8ICdpbmZvJyB8ICdkZWJ1ZycgfCAndHJhY2UnO1xuXG5leHBvcnQgY29uc3QgbGV2ZWxQcmlvcml0eTogUmVjb3JkPElvTWVzc2FnZUxldmVsLCBudW1iZXI+ID0ge1xuICBlcnJvcjogMCxcbiAgcmVzdWx0OiAxLFxuICB3YXJuOiAyLFxuICBpbmZvOiAzLFxuICBkZWJ1ZzogNCxcbiAgdHJhY2U6IDUsXG59O1xuXG4vKipcbiAqIFRlbXBvcmFyeSBoZWxwZXIgdG8gZ3JvdXAgcmVxdWlyZWQgcHJvcHMgZm9yIElvTWVzc2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJb01lc3NhZ2luZyB7XG4gIGlvSG9zdDogSUlvSG9zdDtcbiAgYWN0aW9uOiBUb29sa2l0QWN0aW9uO1xufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IGFjdGlvbiBiZWluZyBwZXJmb3JtZWQgYnkgdGhlIENMSS4gJ25vbmUnIHJlcHJlc2VudHMgdGhlIGFic2VuY2Ugb2YgYW4gYWN0aW9uLlxuICovXG5leHBvcnQgdHlwZSBUb29sa2l0QWN0aW9uID1cbnwgJ2Fzc2VtYmx5J1xufCAnYm9vdHN0cmFwJ1xufCAnc3ludGgnXG58ICdsaXN0J1xufCAnZGlmZidcbnwgJ2RlcGxveSdcbnwgJ3JvbGxiYWNrJ1xufCAnd2F0Y2gnXG58ICdkZXN0cm95J1xufCAnY29udGV4dCdcbnwgJ2RvY3MnXG58ICdkb2N0b3InXG58ICdnYydcbnwgJ2ltcG9ydCdcbnwgJ21ldGFkYXRhJ1xufCAnbm90aWNlcydcbnwgJ2luaXQnXG58ICdtaWdyYXRlJ1xufCAndmVyc2lvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUlvSG9zdCB7XG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgaG9zdCBvZiBhIG1lc3NhZ2UuXG4gICAqIFRoZSBjYWxsZXIgd2FpdHMgdW50aWwgdGhlIG5vdGlmaWNhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuICBub3RpZnk8VD4obXNnOiBJb01lc3NhZ2U8VD4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgaG9zdCBvZiBhIG1lc3NhZ2UgdGhhdCByZXF1aXJlcyBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBJZiB0aGUgaG9zdCBkb2VzIG5vdCByZXR1cm4gYSByZXNwb25zZSB0aGUgc3VnZ2VzdGVkXG4gICAqIGRlZmF1bHQgcmVzcG9uc2UgZnJvbSB0aGUgaW5wdXQgbWVzc2FnZSB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICByZXF1ZXN0UmVzcG9uc2U8VCwgVT4obXNnOiBJb1JlcXVlc3Q8VCwgVT4pOiBQcm9taXNlPFU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsaUlvSG9zdFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIFRvb2xraXQgYWN0aW9uIHRoZSBob3N0cyBzdGFydHMgd2l0aC5cbiAgICpcbiAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAqL1xuICByZWFkb25seSBjdXJyZW50QWN0aW9uPzogVG9vbGtpdEFjdGlvbjtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdmVyYm9zaXR5IG9mIHRoZSBvdXRwdXQuXG4gICAqXG4gICAqIFRoZSBDbGlJb0hvc3Qgd2lsbCBzdGlsbCByZWNlaXZlIGFsbCBtZXNzYWdlcyBhbmQgcmVxdWVzdHMsXG4gICAqIGJ1dCBvbmx5IHRoZSBtZXNzYWdlcyBpbmNsdWRlZCBpbiB0aGlzIGxldmVsIHdpbGwgYmUgcHJpbnRlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgJ2luZm8nXG4gICAqL1xuICByZWFkb25seSBsb2dMZXZlbD86IElvTWVzc2FnZUxldmVsO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGF1dG9tYXRpYyBUVFkgZGV0ZWN0aW9uLlxuICAgKlxuICAgKiBXaGVuIFRUWSBpcyBkaXNhYmxlZCwgdGhlIENMSSB3aWxsIGhhdmUgbm8gaW50ZXJhY3Rpb25zIG9yIGNvbG9yLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGRldGVybWluZWQgZnJvbSB0aGUgY3VycmVudCBwcm9jZXNzXG4gICAqL1xuICByZWFkb25seSBpc1RUWT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIENsaUlvSG9zdCBpcyBydW5uaW5nIGluIENJIG1vZGUuXG4gICAqXG4gICAqIEluIENJIG1vZGUsIGFsbCBub24tZXJyb3Igb3V0cHV0IGdvZXMgdG8gc3Rkb3V0IGluc3RlYWQgb2Ygc3RkZXJyLlxuICAgKiBTZXQgdG8gZmFsc2UgaW4gdGhlIENsaUlvSG9zdCBjb25zdHJ1Y3RvciBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGlmIHRoZSBDTEkgQ0kgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGV0ZXJtaW5lZCBmcm9tIHRoZSBlbnZpcm9ubWVudCwgc3BlY2lmaWNhbGx5IGJhc2VkIG9uIGBwcm9jZXNzLmVudi5DSWBcbiAgICovXG4gIHJlYWRvbmx5IGlzQ0k/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBUb29sa2l0IGFjdGlvbiB0aGUgaG9zdHMgc3RhcnRzIHdpdGguXG4gICAqXG4gICAqIEBkZWZhdWx0IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVJcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrUHJvZ3Jlc3M/OiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3M7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgSU8gaG9zdCBmb3IgdGhlIENMSSB0aGF0IHdyaXRlcyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS5cbiAqL1xuZXhwb3J0IGNsYXNzIENsaUlvSG9zdCBpbXBsZW1lbnRzIElJb0hvc3Qge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2luZ2xldG9uIGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgaW5zdGFuY2UocHJvcHM6IENsaUlvSG9zdFByb3BzID0ge30sIGZvcmNlTmV3ID0gZmFsc2UpOiBDbGlJb0hvc3Qge1xuICAgIGlmIChmb3JjZU5ldyB8fCAhQ2xpSW9Ib3N0Ll9pbnN0YW5jZSkge1xuICAgICAgQ2xpSW9Ib3N0Ll9pbnN0YW5jZSA9IG5ldyBDbGlJb0hvc3QocHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gQ2xpSW9Ib3N0Ll9pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIENsaUlvSG9zdFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlOiBDbGlJb0hvc3QgfCB1bmRlZmluZWQ7XG5cbiAgLy8gaW50ZXJuYWwgc3RhdGUgZm9yIGdldHRlcnMvc2V0dGVyXG4gIHByaXZhdGUgX2N1cnJlbnRBY3Rpb246IFRvb2xraXRBY3Rpb247XG4gIHByaXZhdGUgX2lzQ0k6IGJvb2xlYW47XG4gIHByaXZhdGUgX2lzVFRZOiBib29sZWFuO1xuICBwcml2YXRlIF9sb2dMZXZlbDogSW9NZXNzYWdlTGV2ZWw7XG4gIHByaXZhdGUgX2ludGVybmFsSW9Ib3N0PzogSUlvSG9zdDtcbiAgcHJpdmF0ZSBfcHJvZ3Jlc3M6IFN0YWNrQWN0aXZpdHlQcm9ncmVzcyA9IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVI7XG5cbiAgLy8gU3RhY2sgQWN0aXZpdHkgUHJpbnRlclxuICBwcml2YXRlIGFjdGl2aXR5UHJpbnRlcj86IElBY3Rpdml0eVByaW50ZXI7XG5cbiAgLy8gQ29ya2VkIExvZ2dpbmdcbiAgcHJpdmF0ZSBjb3JrZWRDb3VudGVyID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb3JrZWRMb2dnaW5nQnVmZmVyOiBJb01lc3NhZ2U8YW55PltdID0gW107XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcm9wczogQ2xpSW9Ib3N0UHJvcHMgPSB7fSkge1xuICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBwcm9wcy5jdXJyZW50QWN0aW9uID8/ICdub25lJyBhcyBUb29sa2l0QWN0aW9uO1xuICAgIHRoaXMuX2lzVFRZID0gcHJvcHMuaXNUVFkgPz8gcHJvY2Vzcy5zdGRvdXQuaXNUVFkgPz8gZmFsc2U7XG4gICAgdGhpcy5fbG9nTGV2ZWwgPSBwcm9wcy5sb2dMZXZlbCA/PyAnaW5mbyc7XG4gICAgdGhpcy5faXNDSSA9IHByb3BzLmlzQ0kgPz8gaXNDSSgpO1xuXG4gICAgdGhpcy5zdGFja1Byb2dyZXNzID0gcHJvcHMuc3RhY2tQcm9ncmVzcyA/PyBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuQkFSO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVySW9Ib3N0KGlvSG9zdDogSUlvSG9zdCkge1xuICAgIGlmIChpb0hvc3QgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsSW9Ib3N0ID0gaW9Ib3N0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHN0YWNrUHJvZ3Jlc3MgcHJlZmVyZW5jZS5cbiAgICovXG4gIHB1YmxpYyBzZXQgc3RhY2tQcm9ncmVzcyh0eXBlOiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MpIHtcbiAgICB0aGlzLl9wcm9ncmVzcyA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RhY2tQcm9ncmVzcyB2YWx1ZS5cbiAgICpcbiAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgb3RoZXIgc3RhdGUgb2YgdGhlIGlvSG9zdCxcbiAgICogbGlrZSBpZiBpc1RUWSBhbmQgaXNDSS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tQcm9ncmVzcygpOiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3Mge1xuICAgIC8vIFdlIGNhbiBhbHdheXMgdXNlIEVWRU5UU1xuICAgIGlmICh0aGlzLl9wcm9ncmVzcyA9PT0gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUykge1xuICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICAgIH1cblxuICAgIC8vIGlmIGxvZyBsZXZlbCBpcyB0cmFjaW5nIG9yIGRlYnVnLCB3ZSBkZWZhdWx0IHRvIHRoZSBmdWxsIGhpc3RvcnkgcHJpbnRlclxuICAgIGNvbnN0IHZlcmJvc2VMb2dnaW5nID0gbGV2ZWxQcmlvcml0eVt0aGlzLmxvZ0xldmVsXSA+IGxldmVsUHJpb3JpdHkuaW5mbztcbiAgICBpZiAodmVyYm9zZUxvZ2dpbmcpIHtcbiAgICAgIHJldHVybiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuRVZFTlRTO1xuICAgIH1cblxuICAgIC8vIE9uIFdpbmRvd3Mgd2UgY2Fubm90IHVzZSBmYW5jeSBvdXRwdXRcbiAgICBjb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgIGlmIChpc1dpbmRvd3MpIHtcbiAgICAgIHJldHVybiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuRVZFTlRTO1xuICAgIH1cblxuICAgIC8vIE9uIHNvbWUgQ0kgc3lzdGVtcyAoc3VjaCBhcyBDaXJjbGVDSSkgb3V0cHV0IHN0aWxsIHJlcG9ydHMgYXMgYSBUVFkgc28gd2UgYWxzb1xuICAgIC8vIG5lZWQgYW4gaW5kaXZpZHVhbCBjaGVjayBmb3Igd2hldGhlciB3ZSdyZSBydW5uaW5nIG9uIENJLlxuICAgIC8vIHNlZTogaHR0cHM6Ly9kaXNjdXNzLmNpcmNsZWNpLmNvbS90L2NpcmNsZWNpLXRlcm1pbmFsLWlzLWEtdHR5LWJ1dC10ZXJtLWlzLW5vdC1zZXQvOTk2NVxuICAgIGNvbnN0IGZhbmN5T3V0cHV0QXZhaWxhYmxlID0gdGhpcy5pc1RUWSAmJiAhdGhpcy5pc0NJO1xuICAgIGlmICghZmFuY3lPdXRwdXRBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuRVZFTlRTO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgdXNlciBwcmVmZXJlbmNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGFjdGlvbiBiZWluZyBwZXJmb3JtZWQgYnkgdGhlIENMSS5cbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudEFjdGlvbigpOiBUb29sa2l0QWN0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEFjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IGFjdGlvbiBiZWluZyBwZXJmb3JtZWQgYnkgdGhlIENMSS5cbiAgICpcbiAgICogQHBhcmFtIGFjdGlvbiBUaGUgYWN0aW9uIGJlaW5nIHBlcmZvcm1lZCBieSB0aGUgQ0xJLlxuICAgKi9cbiAgcHVibGljIHNldCBjdXJyZW50QWN0aW9uKGFjdGlvbjogVG9vbGtpdEFjdGlvbikge1xuICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgaG9zdCBjYW4gdXNlIGludGVyYWN0aW9ucyBhbmQgbWVzc2FnZSBzdHlsaW5nLlxuICAgKi9cbiAgcHVibGljIGdldCBpc1RUWSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faXNUVFk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IFRUWSBtb2RlLCBpLmUgY2FuIHRoZSBob3N0IHVzZSBpbnRlcmFjdGlvbnMgYW5kIG1lc3NhZ2Ugc3R5bGluZy5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHNldCBUVFkgbW9kZVxuICAgKi9cbiAgcHVibGljIHNldCBpc1RUWSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2lzVFRZID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgQ2xpSW9Ib3N0IGlzIHJ1bm5pbmcgaW4gQ0kgbW9kZS4gSW4gQ0kgbW9kZSwgYWxsIG5vbi1lcnJvciBvdXRwdXQgZ29lcyB0byBzdGRvdXQgaW5zdGVhZCBvZiBzdGRlcnIuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzQ0koKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ0k7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBDSSBtb2RlLiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAgICogQHBhcmFtIHZhbHVlIHNldCB0aGUgQ0kgbW9kZVxuICAgKi9cbiAgcHVibGljIHNldCBpc0NJKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faXNDSSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRocmVzaG9sZC4gTWVzc2FnZXMgd2l0aCBhIGxvd2VyIHByaW9yaXR5IGxldmVsIHdpbGwgYmUgaWdub3JlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgbG9nTGV2ZWwoKTogSW9NZXNzYWdlTGV2ZWwge1xuICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHRocmVzaG9sZC4gTWVzc2FnZXMgd2l0aCBhIGxvd2VyIHByaW9yaXR5IGxldmVsIHdpbGwgYmUgaWdub3JlZC5cbiAgICogQHBhcmFtIGxldmVsIFRoZSBuZXcgbG9nIGxldmVsIHRocmVzaG9sZFxuICAgKi9cbiAgcHVibGljIHNldCBsb2dMZXZlbChsZXZlbDogSW9NZXNzYWdlTGV2ZWwpIHtcbiAgICB0aGlzLl9sb2dMZXZlbCA9IGxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgYmxvY2sgb2YgY29kZSB3aXRoIGNvcmtlZCBsb2dnaW5nLiBBbGwgbG9nIG1lc3NhZ2VzIGR1cmluZyBleGVjdXRpb25cbiAgICogYXJlIGJ1ZmZlcmVkIGFuZCBvbmx5IHdyaXR0ZW4gd2hlbiBhbGwgbmVzdGVkIGNvcmsgYmxvY2tzIGNvbXBsZXRlICh3aGVuIENPUktfQ09VTlRFUiByZWFjaGVzIDApLlxuICAgKiBUaGUgY29ya2luZyBpcyBib3VuZCB0byB0aGUgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgdGhlIENsaUlvSG9zdC5cbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gQXN5bmMgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoIGNvcmtlZCBsb2dnaW5nXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBibG9jaydzIHJldHVybiB2YWx1ZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHdpdGhDb3JrZWRMb2dnaW5nPFQ+KGJsb2NrOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgdGhpcy5jb3JrZWRDb3VudGVyKys7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBibG9jaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmNvcmtlZENvdW50ZXItLTtcbiAgICAgIGlmICh0aGlzLmNvcmtlZENvdW50ZXIgPT09IDApIHtcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGJ1ZmZlcmVkIG1lc3NhZ2UgdGhyb3VnaCBub3RpZnlcbiAgICAgICAgZm9yIChjb25zdCBpb01lc3NhZ2Ugb2YgdGhpcy5jb3JrZWRMb2dnaW5nQnVmZmVyKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5ub3RpZnkoaW9NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYWxsIGJ1ZmZlcmVkIG1lc3NhZ2VzIGluLXBsYWNlXG4gICAgICAgIHRoaXMuY29ya2VkTG9nZ2luZ0J1ZmZlci5zcGxpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSBob3N0IG9mIGEgbWVzc2FnZS5cbiAgICogVGhlIGNhbGxlciB3YWl0cyB1bnRpbCB0aGUgbm90aWZpY2F0aW9uIGNvbXBsZXRlcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBub3RpZnk8VD4obXNnOiBJb01lc3NhZ2U8VD4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5faW50ZXJuYWxJb0hvc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbElvSG9zdC5ub3RpZnkobXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1N0YWNrQWN0aXZpdHkobXNnKSkge1xuICAgICAgaWYgKCF0aGlzLmFjdGl2aXR5UHJpbnRlcikge1xuICAgICAgICB0aGlzLmFjdGl2aXR5UHJpbnRlciA9IHRoaXMubWFrZUFjdGl2aXR5UHJpbnRlcigpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5hY3Rpdml0eVByaW50ZXIubm90aWZ5KG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxldmVsUHJpb3JpdHlbbXNnLmxldmVsXSA+IGxldmVsUHJpb3JpdHlbdGhpcy5sb2dMZXZlbF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb3JrZWRDb3VudGVyID4gMCkge1xuICAgICAgdGhpcy5jb3JrZWRMb2dnaW5nQnVmZmVyLnB1c2gobXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmZvcm1hdE1lc3NhZ2UobXNnKTtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnNlbGVjdFN0cmVhbShtc2cubGV2ZWwpO1xuICAgIHN0cmVhbS53cml0ZShvdXRwdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBzdGFjayBhY3Rpdml0eSBtZXNzYWdlcyBzbyB0aGV5IGNhbiBiZSBzZW5kIHRvIHRoZSBwcmludGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBpc1N0YWNrQWN0aXZpdHkobXNnOiBJb01lc3NhZ2U8YW55Pikge1xuICAgIHJldHVybiBbXG4gICAgICAnQ0RLX1RPT0xLSVRfSTU1MDEnLFxuICAgICAgJ0NES19UT09MS0lUX0k1NTAyJyxcbiAgICAgICdDREtfVE9PTEtJVF9JNTUwMycsXG4gICAgXS5pbmNsdWRlcyhtc2cuY29kZSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgb3V0cHV0IHN0cmVhbSwgYmFzZWQgb24gbWVzc2FnZSBsZXZlbCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgc2VsZWN0U3RyZWFtKGxldmVsOiBJb01lc3NhZ2VMZXZlbCkge1xuICAgIC8vIFRoZSBzdHJlYW0gc2VsZWN0aW9uIHBvbGljeSBmb3IgdGhlIENMSSBpcyB0aGUgZm9sbG93aW5nOlxuICAgIC8vXG4gICAgLy8gICAoMSkgTWVzc2FnZXMgb2YgbGV2ZWwgYHJlc3VsdGAgYWx3YXlzIGdvIHRvIGBzdGRvdXRgXG4gICAgLy8gICAoMikgTWVzc2FnZXMgb2YgbGV2ZWwgYGVycm9yYCBhbHdheXMgZ28gdG8gYHN0ZGVycmAuXG4gICAgLy8gICAoM2EpIEFsbCByZW1haW5pbmcgbWVzc2FnZXMgZ28gdG8gYHN0ZGVycmAuXG4gICAgLy8gICAoM2IpIElmIHdlIGFyZSBpbiBDSSBtb2RlLCBhbGwgcmVtYWluaW5nIG1lc3NhZ2VzIGdvIHRvIGBzdGRvdXRgLlxuICAgIC8vXG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnI7XG4gICAgICBjYXNlICdyZXN1bHQnOlxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5pc0NJID8gcHJvY2Vzcy5zdGRvdXQgOiBwcm9jZXNzLnN0ZGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlIHRoYXQgcmVxdWlyZXMgYSByZXNwb25zZS5cbiAgICpcbiAgICogSWYgdGhlIGhvc3QgZG9lcyBub3QgcmV0dXJuIGEgcmVzcG9uc2UgdGhlIHN1Z2dlc3RlZFxuICAgKiBkZWZhdWx0IHJlc3BvbnNlIGZyb20gdGhlIGlucHV0IG1lc3NhZ2Ugd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlcXVlc3RSZXNwb25zZTxEYXRhVHlwZSwgUmVzcG9uc2VUeXBlPihtc2c6IElvUmVxdWVzdDxEYXRhVHlwZSwgUmVzcG9uc2VUeXBlPik6IFByb21pc2U8UmVzcG9uc2VUeXBlPiB7XG4gICAgLy8gRmlyc3QgY2FsbCBvdXQgdG8gYSByZWdpc3RlcmVkIGluc3RhbmNlIGlmIHdlIGhhdmUgb25lXG4gICAgaWYgKHRoaXMuX2ludGVybmFsSW9Ib3N0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxJb0hvc3QucmVxdWVzdFJlc3BvbnNlKG1zZyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgY2Fubm90IGJlIHByb21wdGVkIGZvciBieSB0aGUgQ2xpSW9Ib3N0LCB3ZSBqdXN0IGFjY2VwdCB0aGUgZGVmYXVsdFxuICAgIGlmICghaXNQcm9tcHRhYmxlUmVxdWVzdChtc2cpKSB7XG4gICAgICBhd2FpdCB0aGlzLm5vdGlmeShtc2cpO1xuICAgICAgcmV0dXJuIG1zZy5kZWZhdWx0UmVzcG9uc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndpdGhDb3JrZWRMb2dnaW5nKGFzeW5jICgpOiBQcm9taXNlPHN0cmluZyB8IG51bWJlciB8IHRydWU+ID0+IHtcbiAgICAgIC8vIHByZXBhcmUgcHJvbXB0IGRhdGFcbiAgICAgIC8vIEB0b2RvIHRoaXMgZm9ybWF0IGlzIG5vdCBkZWZpbmVkIGFueXdoZXJlLCBwcm9iYWJseSBzaG91bGQgYmVcbiAgICAgIGNvbnN0IGRhdGE6IHtcbiAgICAgICAgbW90aXZhdGlvbj86IHN0cmluZztcbiAgICAgICAgY29uY3VycmVuY3k/OiBudW1iZXI7XG4gICAgICB9ID0gbXNnLmRhdGEgPz8ge307XG5cbiAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSBkYXRhLm1vdGl2YXRpb24gPz8gJ1VzZXIgaW5wdXQgaXMgbmVlZGVkJztcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gZGF0YS5jb25jdXJyZW5jeSA/PyAwO1xuXG4gICAgICAvLyBvbmx5IHRhbGsgdG8gdXNlciBpZiBTVERJTiBpcyBhIHRlcm1pbmFsIChvdGhlcndpc2UsIGZhaWwpXG4gICAgICBpZiAoIXRoaXMuaXNUVFkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttb3RpdmF0aW9ufSwgYnV0IHRlcm1pbmFsIChUVFkpIGlzIG5vdCBhdHRhY2hlZCBzbyB3ZSBhcmUgdW5hYmxlIHRvIGdldCBhIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSB1c2VyYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgdGFsayB0byB1c2VyIGlmIGNvbmN1cnJlbmN5IGlzIDEgKG90aGVyd2lzZSwgZmFpbClcbiAgICAgIGlmIChjb25jdXJyZW5jeSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgJHttb3RpdmF0aW9ufSwgYnV0IGNvbmN1cnJlbmN5IGlzIGdyZWF0ZXIgdGhhbiAxIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXJgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQmFzaWMgY29uZmlybWF0aW9uIHByb21wdFxuICAgICAgLy8gV2UgdHJlYXQgYWxsIHJlcXVlc3RzIHdpdGggYSBib29sZWFuIHJlc3BvbnNlIGFzIGNvbmZpcm1hdGlvbiBwcm9tcHRzXG4gICAgICBpZiAoaXNDb25maXJtYXRpb25Qcm9tcHQobXNnKSkge1xuICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBwcm9tcHRseS5jb25maXJtKGAke2NoYWxrLmN5YW4obXNnLm1lc3NhZ2UpfSAoeS9uKWApO1xuICAgICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0Fib3J0ZWQgYnkgdXNlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maXJtZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEFza2luZyBmb3IgYSBzcGVjaWZpYyB2YWx1ZVxuICAgICAgY29uc3QgcHJvbXB0ID0gZXh0cmFjdFByb21wdEluZm8obXNnKTtcbiAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHByb21wdGx5LnByb21wdChgJHtjaGFsay5jeWFuKG1zZy5tZXNzYWdlKX0gKCR7cHJvbXB0LmRlZmF1bHR9KWAsIHtcbiAgICAgICAgZGVmYXVsdDogcHJvbXB0LmRlZmF1bHQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9tcHQuY29udmVydEFuc3dlcihhbnN3ZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gV2UgbmVlZCB0byBjYXN0IHRoaXMgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIG5hcnJvdyB0aGUgZ2VuZXJpYyB0eXBlXG4gICAgLy8gaXNQcm9tcHRhYmxlUmVxdWVzdCBlbnN1cmVzIHRoYXQgdGhlIHJlc3BvbnNlIHR5cGUgaXMgb25lIHdlIGNhbiBwcm9tcHQgZm9yXG4gICAgLy8gdGhlIHJlbWFpbmluZyBjb2RlIGVuc3VyZSB3ZSBhcmUgaW5kZWVkIHJldHVybmluZyB0aGUgY29ycmVjdCB0eXBlXG4gICAgcmV0dXJuIHJlc3BvbnNlIGFzIFJlc3BvbnNlVHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXRzIGEgbWVzc2FnZSBmb3IgY29uc29sZSBvdXRwdXQgd2l0aCBvcHRpb25hbCBjb2xvciBzdXBwb3J0XG4gICAqL1xuICBwcml2YXRlIGZvcm1hdE1lc3NhZ2UobXNnOiBJb01lc3NhZ2U8YW55Pik6IHN0cmluZyB7XG4gICAgLy8gYXBwbHkgcHJvdmlkZWQgc3R5bGUgb3IgYSBkZWZhdWx0IHN0eWxlIGlmIHdlJ3JlIGluIFRUWSBtb2RlXG4gICAgbGV0IG1lc3NhZ2VfdGV4dCA9IHRoaXMuX2lzVFRZXG4gICAgICA/IHN0eWxlTWFwW21zZy5sZXZlbF0obXNnLm1lc3NhZ2UpXG4gICAgICA6IG1zZy5tZXNzYWdlO1xuXG4gICAgLy8gcHJlcGVuZCB0aW1lc3RhbXAgaWYgSW9NZXNzYWdlTGV2ZWwgaXMgREVCVUcgb3IgVFJBQ0UuIFBvc3RwZW5kIGEgbmV3bGluZS5cbiAgICByZXR1cm4gKChtc2cubGV2ZWwgPT09ICdkZWJ1ZycgfHwgbXNnLmxldmVsID09PSAndHJhY2UnKVxuICAgICAgPyBgWyR7dGhpcy5mb3JtYXRUaW1lKG1zZy50aW1lKX1dICR7bWVzc2FnZV90ZXh0fWBcbiAgICAgIDogbWVzc2FnZV90ZXh0KSArICdcXG4nO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgZGF0ZSB0byBISDpNTTpTU1xuICAgKi9cbiAgcHJpdmF0ZSBmb3JtYXRUaW1lKGQ6IERhdGUpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhZCA9IChuOiBudW1iZXIpOiBzdHJpbmcgPT4gbi50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgcmV0dXJuIGAke3BhZChkLmdldEhvdXJzKCkpfToke3BhZChkLmdldE1pbnV0ZXMoKSl9OiR7cGFkKGQuZ2V0U2Vjb25kcygpKX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBpbnN0YW5jZSBvZiB0aGUgQWN0aXZpdHlQcmludGVyXG4gICAqL1xuICBwcml2YXRlIG1ha2VBY3Rpdml0eVByaW50ZXIoKSB7XG4gICAgY29uc3QgcHJvcHM6IEFjdGl2aXR5UHJpbnRlclByb3BzID0ge1xuICAgICAgc3RyZWFtOiB0aGlzLnNlbGVjdFN0cmVhbSgnaW5mbycpLFxuICAgIH07XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhY2tQcm9ncmVzcykge1xuICAgICAgY2FzZSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuRVZFTlRTOlxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlBY3Rpdml0eVByaW50ZXIocHJvcHMpO1xuICAgICAgY2FzZSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuQkFSOlxuICAgICAgICByZXR1cm4gbmV3IEN1cnJlbnRBY3Rpdml0eVByaW50ZXIocHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgSW9Ib3N0IGltcGxlbWVudGF0aW9uIGNvbnNpZGVycyBhIHJlcXVlc3QgcHJvbXB0YWJsZSwgaWY6XG4gKiAtIGl0J3MgYSB5ZXMvbm8gY29uZmlybWF0aW9uXG4gKiAtIGFza2luZyBmb3IgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzUHJvbXB0YWJsZVJlcXVlc3QobXNnOiBJb1JlcXVlc3Q8YW55LCBhbnk+KTogbXNnIGlzIElvUmVxdWVzdDxhbnksIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4+IHtcbiAgcmV0dXJuIGlzQ29uZmlybWF0aW9uUHJvbXB0KG1zZylcbiAgICB8fCB0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ3N0cmluZydcbiAgICB8fCB0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHJlcXVlc3QgaXMgYSBjb25maXJtYXRpb24gcHJvbXB0XG4gKiBXZSB0cmVhdCBhbGwgcmVxdWVzdHMgd2l0aCBhIGJvb2xlYW4gcmVzcG9uc2UgYXMgY29uZmlybWF0aW9uIHByb21wdHNcbiAqL1xuZnVuY3Rpb24gaXNDb25maXJtYXRpb25Qcm9tcHQobXNnOiBJb1JlcXVlc3Q8YW55LCBhbnk+KTogbXNnIGlzIElvUmVxdWVzdDxhbnksIGJvb2xlYW4+IHtcbiAgcmV0dXJuIHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGV4dHJhY3QgaW5mb3JtYXRpb24gZm9yIHByb21wdGx5IGZyb20gdGhlIHJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb21wdEluZm8obXNnOiBJb1JlcXVlc3Q8YW55LCBhbnk+KToge1xuICBkZWZhdWx0OiBzdHJpbmc7XG4gIGNvbnZlcnRBbnN3ZXI6IChpbnB1dDogc3RyaW5nKSA9PiBzdHJpbmcgfCBudW1iZXI7XG59IHtcbiAgY29uc3QgaXNOdW1iZXIgPSAodHlwZW9mIG1zZy5kZWZhdWx0UmVzcG9uc2UgPT09ICdudW1iZXInKTtcbiAgcmV0dXJuIHtcbiAgICBkZWZhdWx0OiB1dGlsLmZvcm1hdChtc2cuZGVmYXVsdFJlc3BvbnNlKSxcbiAgICBjb252ZXJ0QW5zd2VyOiBpc051bWJlciA/ICh2KSA9PiBOdW1iZXIodikgOiAodikgPT4gU3RyaW5nKHYpLFxuICB9O1xufVxuXG5jb25zdCBzdHlsZU1hcDogUmVjb3JkPElvTWVzc2FnZUxldmVsLCAoc3RyOiBzdHJpbmcpID0+IHN0cmluZz4gPSB7XG4gIGVycm9yOiBjaGFsay5yZWQsXG4gIHdhcm46IGNoYWxrLnllbGxvdyxcbiAgcmVzdWx0OiBjaGFsay53aGl0ZSxcbiAgaW5mbzogY2hhbGsud2hpdGUsXG4gIGRlYnVnOiBjaGFsay5ncmF5LFxuICB0cmFjZTogY2hhbGsuZ3JheSxcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHByb2Nlc3MgaXMgcnVubmluZyBpbiBhIENJIGVudmlyb25tZW50XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IHByb2Nlc3MgaXMgcnVubmluZyBpbiBhIENJIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NJKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuQ0kgIT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzLmVudi5DSSAhPT0gJ2ZhbHNlJyAmJiBwcm9jZXNzLmVudi5DSSAhPT0gJzAnO1xufVxuXG4iXX0=