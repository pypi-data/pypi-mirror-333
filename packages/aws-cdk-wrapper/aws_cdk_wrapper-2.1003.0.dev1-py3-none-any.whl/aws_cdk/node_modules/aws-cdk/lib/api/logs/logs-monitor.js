"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudWatchLogEventMonitor = void 0;
const util = require("util");
const chalk = require("chalk");
const logging_1 = require("../../logging");
const util_1 = require("../../util");
/**
 * After reading events from all CloudWatch log groups
 * how long should we wait to read more events.
 *
 * If there is some error with reading events (i.e. Throttle)
 * then this is also how long we wait until we try again
 */
const SLEEP = 2000;
class CloudWatchLogEventMonitor {
    constructor(startTime) {
        var _a;
        /**
         * Map of environment (account:region) to LogGroupsAccessSettings
         */
        this.envsLogGroupsAccessSettings = new Map();
        this.active = false;
        this.startTime = (_a = startTime === null || startTime === void 0 ? void 0 : startTime.getTime()) !== null && _a !== void 0 ? _a : Date.now();
    }
    /**
     * resume reading/printing events
     */
    activate() {
        this.active = true;
        this.scheduleNextTick(0);
    }
    /**
     * deactivates the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered
     * and clears the list of tracked log groups
     */
    deactivate() {
        this.active = false;
        this.startTime = Date.now();
        this.envsLogGroupsAccessSettings.clear();
    }
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple stacks that deploy to
     * multiple environments (account+region), we need to store a list of log groups
     * per env along with the SDK object that has access to read from
     * that environment.
     */
    addLogGroups(env, sdk, logGroupNames) {
        var _a;
        const awsEnv = `${env.account}:${env.region}`;
        const logGroupsStartTimes = logGroupNames.reduce((acc, groupName) => {
            acc[groupName] = this.startTime;
            return acc;
        }, {});
        this.envsLogGroupsAccessSettings.set(awsEnv, {
            sdk,
            logGroupsStartTimes: {
                ...(_a = this.envsLogGroupsAccessSettings.get(awsEnv)) === null || _a === void 0 ? void 0 : _a.logGroupsStartTimes,
                ...logGroupsStartTimes,
            },
        });
    }
    scheduleNextTick(sleep) {
        setTimeout(() => void this.tick(), sleep);
    }
    async tick() {
        // excluding from codecoverage because this
        // doesn't always run (depends on timing)
        /* istanbul ignore next */
        if (!this.active) {
            return;
        }
        try {
            const events = (0, util_1.flatten)(await this.readNewEvents());
            events.forEach((event) => {
                this.print(event);
            });
        }
        catch (e) {
            (0, logging_1.error)('Error occurred while monitoring logs: %s', e);
        }
        this.scheduleNextTick(SLEEP);
    }
    /**
     * Reads all new log events from a set of CloudWatch Log Groups
     * in parallel
     */
    async readNewEvents() {
        const promises = [];
        for (const settings of this.envsLogGroupsAccessSettings.values()) {
            for (const group of Object.keys(settings.logGroupsStartTimes)) {
                promises.push(this.readEventsFromLogGroup(settings, group));
            }
        }
        // Limited set of log groups
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        return Promise.all(promises);
    }
    /**
     * Print out a cloudwatch event
     */
    print(event) {
        (0, logging_1.info)(util.format('[%s] %s %s', chalk.blue(event.logGroupName), chalk.yellow(event.timestamp.toLocaleTimeString()), event.message.trim()));
    }
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the hotswap was triggered or
     * when the last event was read on the previous tick
     */
    async readEventsFromLogGroup(logGroupsAccessSettings, logGroupName) {
        var _a, _b;
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group
        const startTime = (_a = logGroupsAccessSettings.logGroupsStartTimes[logGroupName]) !== null && _a !== void 0 ? _a : this.startTime;
        let endTime = startTime;
        try {
            const response = await logGroupsAccessSettings.sdk.cloudWatchLogs().filterLogEvents({
                logGroupName: logGroupName,
                limit: 100,
                startTime: startTime,
            });
            const filteredEvents = (_b = response.events) !== null && _b !== void 0 ? _b : [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // As long as there are _any_ events in the log group `filterLogEvents` will return a nextToken.
            // This is true even if these events are before `startTime`. So if we have 100 events and a nextToken
            // then assume that we have hit the limit and let the user know some messages have been suppressed.
            // We are essentially showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length === 100 && response.nextToken) {
                events.push({
                    message: '>>> `watch` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the CloudWatch is not created
            // until something is logged, so just keep polling until
            // there is somthing to find
            if (e.name === 'ResourceNotFoundException') {
                return [];
            }
            throw e;
        }
        logGroupsAccessSettings.logGroupsStartTimes[logGroupName] = endTime + 1;
        return events;
    }
}
exports.CloudWatchLogEventMonitor = CloudWatchLogEventMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibG9ncy1tb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsMkNBQTRDO0FBQzVDLHFDQUFxQztBQUdyQzs7Ozs7O0dBTUc7QUFDSCxNQUFNLEtBQUssR0FBRyxJQUFLLENBQUM7QUEwQ3BCLE1BQWEseUJBQXlCO0lBYXBDLFlBQVksU0FBZ0I7O1FBUDVCOztXQUVHO1FBQ2MsZ0NBQTJCLEdBQUcsSUFBSSxHQUFHLEVBQW1DLENBQUM7UUFFbEYsV0FBTSxHQUFHLEtBQUssQ0FBQztRQUdyQixJQUFJLENBQUMsU0FBUyxHQUFHLE1BQUEsU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLE9BQU8sRUFBRSxtQ0FBSSxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksUUFBUTtRQUNiLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ25CLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSSxVQUFVO1FBQ2YsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDNUIsSUFBSSxDQUFDLDJCQUEyQixDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxZQUFZLENBQUMsR0FBc0IsRUFBRSxHQUFRLEVBQUUsYUFBdUI7O1FBQzNFLE1BQU0sTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLE9BQU8sSUFBSSxHQUFHLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDOUMsTUFBTSxtQkFBbUIsR0FBRyxhQUFhLENBQUMsTUFBTSxDQUM5QyxDQUFDLEdBQUcsRUFBRSxT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REFBc0Q7WUFDdEQsd0RBQXdEO1lBQ3hELDRCQUE0QjtZQUM1QixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssMkJBQTJCLEVBQUUsQ0FBQztnQkFDM0MsT0FBTyxFQUFFLENBQUM7WUFDWixDQUFDO1lBQ0QsTUFBTSxDQUFDLENBQUM7UUFDVixDQUFDO1FBQ0QsdUJBQXVCLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLEdBQUcsT0FBTyxHQUFHLENBQUMsQ0FBQztRQUN4RSxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUFsTEQsOERBa0xDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICd1dGlsJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBpbmZvLCBlcnJvciB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbi8qKlxuICogQWZ0ZXIgcmVhZGluZyBldmVudHMgZnJvbSBhbGwgQ2xvdWRXYXRjaCBsb2cgZ3JvdXBzXG4gKiBob3cgbG9uZyBzaG91bGQgd2Ugd2FpdCB0byByZWFkIG1vcmUgZXZlbnRzLlxuICpcbiAqIElmIHRoZXJlIGlzIHNvbWUgZXJyb3Igd2l0aCByZWFkaW5nIGV2ZW50cyAoaS5lLiBUaHJvdHRsZSlcbiAqIHRoZW4gdGhpcyBpcyBhbHNvIGhvdyBsb25nIHdlIHdhaXQgdW50aWwgd2UgdHJ5IGFnYWluXG4gKi9cbmNvbnN0IFNMRUVQID0gMl8wMDA7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIENsb3VkV2F0Y2ggTG9nIEV2ZW50IHRoYXQgd2lsbCBiZVxuICogcHJpbnRlZCB0byB0aGUgdGVybWluYWxcbiAqL1xuaW50ZXJmYWNlIENsb3VkV2F0Y2hMb2dFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgbG9nIGV2ZW50IG1lc3NhZ2VcbiAgICovXG4gIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGxvZyBncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgbG9nR3JvdXBOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBldmVudCBvY2N1cnJlZFxuICAgKi9cbiAgcmVhZG9ubHkgdGltZXN0YW1wOiBEYXRlO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gdHJhY2tpbmcgaW5mb3JtYXRpb24gb24gdGhlIGxvZyBncm91cHMgdGhhdCBhcmVcbiAqIGJlaW5nIG1vbml0b3JlZFxuICovXG5pbnRlcmZhY2UgTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3Mge1xuICAvKipcbiAgICogVGhlIFNESyBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudCAoYWNjb3VudC9yZWdpb24pXG4gICAqL1xuICByZWFkb25seSBzZGs6IFNESztcblxuICAvKipcbiAgICogQSBtYXAgb2YgbG9nIGdyb3VwcyBhbmQgYXNzb2NpYXRlZCBzdGFydFRpbWUgaW4gYSBnaXZlbiBhY2NvdW50LlxuICAgKlxuICAgKiBUaGUgbW9uaXRvciB3aWxsIHJlYWQgZXZlbnRzIGZyb20gdGhlIGxvZyBncm91cCBzdGFydGluZyBhdCB0aGVcbiAgICogYXNzb2NpYXRlZCBzdGFydFRpbWVcbiAgICovXG4gIHJlYWRvbmx5IGxvZ0dyb3Vwc1N0YXJ0VGltZXM6IHsgW2xvZ0dyb3VwTmFtZTogc3RyaW5nXTogbnVtYmVyIH07XG59XG5cbmV4cG9ydCBjbGFzcyBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yIHtcbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hpY2ggZXZlbnRzIG5vdCB0byBkaXNwbGF5XG4gICAqL1xuICBwcml2YXRlIHN0YXJ0VGltZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgZW52aXJvbm1lbnQgKGFjY291bnQ6cmVnaW9uKSB0byBMb2dHcm91cHNBY2Nlc3NTZXR0aW5nc1xuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBlbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MgPSBuZXcgTWFwPHN0cmluZywgTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3M+KCk7XG5cbiAgcHJpdmF0ZSBhY3RpdmUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihzdGFydFRpbWU/OiBEYXRlKSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU/LmdldFRpbWUoKSA/PyBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc3VtZSByZWFkaW5nL3ByaW50aW5nIGV2ZW50c1xuICAgKi9cbiAgcHVibGljIGFjdGl2YXRlKCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjaGVkdWxlTmV4dFRpY2soMCk7XG4gIH1cblxuICAvKipcbiAgICogZGVhY3RpdmF0ZXMgdGhlIG1vbml0b3Igc28gbm8gbmV3IGV2ZW50cyBhcmUgcmVhZFxuICAgKiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB3aGVuIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIHBlcmZvcm1pbmcgYSBkZXBsb3ltZW50XG4gICAqIGFuZCBkb24ndCB3YW50IHRvIGludGVyd2VhdmUgYWxsIHRoZSBsb2dzIHRvZ2V0aGVyIHdpdGggdGhlIENGTlxuICAgKiBkZXBsb3ltZW50IGxvZ3NcbiAgICpcbiAgICogQWxzbyByZXNldHMgdGhlIHN0YXJ0IHRpbWUgdG8gYmUgd2hlbiB0aGUgbmV3IGRlcGxveW1lbnQgd2FzIHRyaWdnZXJlZFxuICAgKiBhbmQgY2xlYXJzIHRoZSBsaXN0IG9mIHRyYWNrZWQgbG9nIGdyb3Vwc1xuICAgKi9cbiAgcHVibGljIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIENsb3VkV2F0Y2ggbG9nIGdyb3VwcyB0byByZWFkIGxvZyBldmVudHMgZnJvbS5cbiAgICogU2luY2Ugd2UgY291bGQgYmUgd2F0Y2hpbmcgbXVsdGlwbGUgc3RhY2tzIHRoYXQgZGVwbG95IHRvXG4gICAqIG11bHRpcGxlIGVudmlyb25tZW50cyAoYWNjb3VudCtyZWdpb24pLCB3ZSBuZWVkIHRvIHN0b3JlIGEgbGlzdCBvZiBsb2cgZ3JvdXBzXG4gICAqIHBlciBlbnYgYWxvbmcgd2l0aCB0aGUgU0RLIG9iamVjdCB0aGF0IGhhcyBhY2Nlc3MgdG8gcmVhZCBmcm9tXG4gICAqIHRoYXQgZW52aXJvbm1lbnQuXG4gICAqL1xuICBwdWJsaWMgYWRkTG9nR3JvdXBzKGVudjogY3hhcGkuRW52aXJvbm1lbnQsIHNkazogU0RLLCBsb2dHcm91cE5hbWVzOiBzdHJpbmdbXSk6IHZvaWQge1xuICAgIGNvbnN0IGF3c0VudiA9IGAke2Vudi5hY2NvdW50fToke2Vudi5yZWdpb259YDtcbiAgICBjb25zdCBsb2dHcm91cHNTdGFydFRpbWVzID0gbG9nR3JvdXBOYW1lcy5yZWR1Y2UoXG4gICAgICAoYWNjLCBncm91cE5hbWUpID0+IHtcbiAgICAgICAgYWNjW2dyb3VwTmFtZV0gPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyB7IFtsb2dHcm91cE5hbWU6IHN0cmluZ106IG51bWJlciB9LFxuICAgICk7XG4gICAgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3Muc2V0KGF3c0Vudiwge1xuICAgICAgc2RrLFxuICAgICAgbG9nR3JvdXBzU3RhcnRUaW1lczoge1xuICAgICAgICAuLi50aGlzLmVudnNMb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5nZXQoYXdzRW52KT8ubG9nR3JvdXBzU3RhcnRUaW1lcyxcbiAgICAgICAgLi4ubG9nR3JvdXBzU3RhcnRUaW1lcyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlTmV4dFRpY2soc2xlZXA6IG51bWJlcik6IHZvaWQge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdm9pZCB0aGlzLnRpY2soKSwgc2xlZXApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyB0aWNrKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIGV4Y2x1ZGluZyBmcm9tIGNvZGVjb3ZlcmFnZSBiZWNhdXNlIHRoaXNcbiAgICAvLyBkb2Vzbid0IGFsd2F5cyBydW4gKGRlcGVuZHMgb24gdGltaW5nKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnRzID0gZmxhdHRlbihhd2FpdCB0aGlzLnJlYWROZXdFdmVudHMoKSk7XG4gICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5wcmludChldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcignRXJyb3Igb2NjdXJyZWQgd2hpbGUgbW9uaXRvcmluZyBsb2dzOiAlcycsIGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljayhTTEVFUCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgYWxsIG5ldyBsb2cgZXZlbnRzIGZyb20gYSBzZXQgb2YgQ2xvdWRXYXRjaCBMb2cgR3JvdXBzXG4gICAqIGluIHBhcmFsbGVsXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlYWROZXdFdmVudHMoKTogUHJvbWlzZTxBcnJheTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+Pj4ge1xuICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+PiA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2V0dGluZ3Mgb2YgdGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgT2JqZWN0LmtleXMoc2V0dGluZ3MubG9nR3JvdXBzU3RhcnRUaW1lcykpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnJlYWRFdmVudHNGcm9tTG9nR3JvdXAoc2V0dGluZ3MsIGdyb3VwKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpbWl0ZWQgc2V0IG9mIGxvZyBncm91cHNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW50IG91dCBhIGNsb3Vkd2F0Y2ggZXZlbnRcbiAgICovXG4gIHByaXZhdGUgcHJpbnQoZXZlbnQ6IENsb3VkV2F0Y2hMb2dFdmVudCk6IHZvaWQge1xuICAgIGluZm8oXG4gICAgICB1dGlsLmZvcm1hdChcbiAgICAgICAgJ1slc10gJXMgJXMnLFxuICAgICAgICBjaGFsay5ibHVlKGV2ZW50LmxvZ0dyb3VwTmFtZSksXG4gICAgICAgIGNoYWxrLnllbGxvdyhldmVudC50aW1lc3RhbXAudG9Mb2NhbGVUaW1lU3RyaW5nKCkpLFxuICAgICAgICBldmVudC5tZXNzYWdlLnRyaW0oKSxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgbmV3IGxvZyBldmVudHMgZnJvbSBhIENsb3VkV2F0Y2ggTG9nIEdyb3VwXG4gICAqIHN0YXJ0aW5nIGF0IGVpdGhlciB0aGUgdGltZSB0aGUgaG90c3dhcCB3YXMgdHJpZ2dlcmVkIG9yXG4gICAqIHdoZW4gdGhlIGxhc3QgZXZlbnQgd2FzIHJlYWQgb24gdGhlIHByZXZpb3VzIHRpY2tcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVhZEV2ZW50c0Zyb21Mb2dHcm91cChcbiAgICBsb2dHcm91cHNBY2Nlc3NTZXR0aW5nczogTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MsXG4gICAgbG9nR3JvdXBOYW1lOiBzdHJpbmcsXG4gICk6IFByb21pc2U8QXJyYXk8Q2xvdWRXYXRjaExvZ0V2ZW50Pj4ge1xuICAgIGNvbnN0IGV2ZW50czogQ2xvdWRXYXRjaExvZ0V2ZW50W10gPSBbXTtcblxuICAgIC8vIGxvZyBldmVudHMgZnJvbSBzb21lIHNlcnZpY2UgYXJlIGluZ2VzdGVkIGZhc3RlciB0aGFuIG90aGVyc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gdHJhY2sgdGhlIHN0YXJ0L2VuZCB0aW1lIGZvciBlYWNoIGxvZyBncm91cCBpbmRpdmlkdWFsbHlcbiAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcm9jZXNzIGFsbCBldmVudHMgZnJvbSBlYWNoIGxvZyBncm91cFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXNbbG9nR3JvdXBOYW1lXSA/PyB0aGlzLnN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5zZGsuY2xvdWRXYXRjaExvZ3MoKS5maWx0ZXJMb2dFdmVudHMoe1xuICAgICAgICBsb2dHcm91cE5hbWU6IGxvZ0dyb3VwTmFtZSxcbiAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRXZlbnRzID0gcmVzcG9uc2UuZXZlbnRzID8/IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGZpbHRlcmVkRXZlbnRzKSB7XG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZSxcbiAgICAgICAgICAgIGxvZ0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wID8gbmV3IERhdGUoZXZlbnQudGltZXN0YW1wKSA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXZlbnQudGltZXN0YW1wICYmIGVuZFRpbWUgPCBldmVudC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBldmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBcyBsb25nIGFzIHRoZXJlIGFyZSBfYW55XyBldmVudHMgaW4gdGhlIGxvZyBncm91cCBgZmlsdGVyTG9nRXZlbnRzYCB3aWxsIHJldHVybiBhIG5leHRUb2tlbi5cbiAgICAgIC8vIFRoaXMgaXMgdHJ1ZSBldmVuIGlmIHRoZXNlIGV2ZW50cyBhcmUgYmVmb3JlIGBzdGFydFRpbWVgLiBTbyBpZiB3ZSBoYXZlIDEwMCBldmVudHMgYW5kIGEgbmV4dFRva2VuXG4gICAgICAvLyB0aGVuIGFzc3VtZSB0aGF0IHdlIGhhdmUgaGl0IHRoZSBsaW1pdCBhbmQgbGV0IHRoZSB1c2VyIGtub3cgc29tZSBtZXNzYWdlcyBoYXZlIGJlZW4gc3VwcHJlc3NlZC5cbiAgICAgIC8vIFdlIGFyZSBlc3NlbnRpYWxseSBzaG93aW5nIHRoZW0gYSBzYW1wbGluZyAoMTAwMDAgZXZlbnRzIHByaW50ZWQgb3V0IGlzIG5vdCB2ZXJ5IHVzZWZ1bClcbiAgICAgIGlmIChmaWx0ZXJlZEV2ZW50cy5sZW5ndGggPT09IDEwMCAmJiByZXNwb25zZS5uZXh0VG9rZW4pIHtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG1lc3NhZ2U6ICc+Pj4gYHdhdGNoYCBzaG93cyBvbmx5IHRoZSBmaXJzdCAxMDAgbG9nIG1lc3NhZ2VzIC0gdGhlIHJlc3QgaGF2ZSBiZWVuIHRydW5jYXRlZC4uLicsXG4gICAgICAgICAgbG9nR3JvdXBOYW1lLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoZW5kVGltZSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gd2l0aCBMYW1iZGEgZnVuY3Rpb25zIHRoZSBDbG91ZFdhdGNoIGlzIG5vdCBjcmVhdGVkXG4gICAgICAvLyB1bnRpbCBzb21ldGhpbmcgaXMgbG9nZ2VkLCBzbyBqdXN0IGtlZXAgcG9sbGluZyB1bnRpbFxuICAgICAgLy8gdGhlcmUgaXMgc29tdGhpbmcgdG8gZmluZFxuICAgICAgaWYgKGUubmFtZSA9PT0gJ1Jlc291cmNlTm90Rm91bmRFeGNlcHRpb24nKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXNbbG9nR3JvdXBOYW1lXSA9IGVuZFRpbWUgKyAxO1xuICAgIHJldHVybiBldmVudHM7XG4gIH1cbn1cbiJdfQ==