"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoBootstrapStackEnvironmentResources = exports.EnvironmentResources = exports.EnvironmentResourcesRegistry = void 0;
const messages_1 = require("../../cli/messages");
const notices_1 = require("../../notices");
const error_1 = require("../../toolkit/error");
const util_1 = require("../../util");
const toolkit_info_1 = require("../toolkit-info");
/**
 * Registry class for `EnvironmentResources`.
 *
 * The state management of this class is a bit non-standard. We want to cache
 * data related to toolkit stacks and SSM parameters, but we are not in charge
 * of ensuring caching of SDKs. Since `EnvironmentResources` needs an SDK to
 * function, we treat it as an ephemeral class, and store the actual cached data
 * in `EnvironmentResourcesRegistry`.
 */
class EnvironmentResourcesRegistry {
    constructor(toolkitStackName) {
        this.toolkitStackName = toolkitStackName;
        this.cache = new Map();
    }
    for(resolvedEnvironment, sdk, msg) {
        const key = `${resolvedEnvironment.account}:${resolvedEnvironment.region}`;
        let envCache = this.cache.get(key);
        if (!envCache) {
            envCache = emptyCache();
            this.cache.set(key, envCache);
        }
        return new EnvironmentResources(resolvedEnvironment, sdk, msg, envCache, this.toolkitStackName);
    }
}
exports.EnvironmentResourcesRegistry = EnvironmentResourcesRegistry;
/**
 * Interface with the account and region we're deploying into
 *
 * Manages lookups for bootstrapped resources, falling back to the legacy "CDK Toolkit"
 * original bootstrap stack if necessary.
 *
 * The state management of this class is a bit non-standard. We want to cache
 * data related to toolkit stacks and SSM parameters, but we are not in charge
 * of ensuring caching of SDKs. Since `EnvironmentResources` needs an SDK to
 * function, we treat it as an ephemeral class, and store the actual cached data
 * in `EnvironmentResourcesRegistry`.
 */
class EnvironmentResources {
    constructor(environment, sdk, msg, cache, toolkitStackName) {
        this.environment = environment;
        this.sdk = sdk;
        this.msg = msg;
        this.cache = cache;
        this.toolkitStackName = toolkitStackName;
    }
    /**
     * Look up the toolkit for a given environment, using a given SDK
     */
    async lookupToolkit() {
        if (!this.cache.toolkitInfo) {
            this.cache.toolkitInfo = await toolkit_info_1.ToolkitInfo.lookup(this.environment, this.sdk, this.msg, this.toolkitStackName);
        }
        return this.cache.toolkitInfo;
    }
    /**
     * Validate that the bootstrap stack version matches or exceeds the expected version
     *
     * Use the SSM parameter name to read the version number if given, otherwise use the version
     * discovered on the bootstrap stack.
     *
     * Pass in the SSM parameter name so we can cache the lookups an don't need to do the same
     * lookup again and again for every artifact.
     */
    async validateVersion(expectedVersion, ssmParameterName) {
        if (expectedVersion === undefined) {
            // No requirement
            return;
        }
        const defExpectedVersion = expectedVersion;
        if (ssmParameterName !== undefined) {
            try {
                doValidate(await this.versionFromSsmParameter(ssmParameterName), this.environment);
                return;
            }
            catch (e) {
                if (e.name !== 'AccessDeniedException') {
                    throw e;
                }
                // This is a fallback! The bootstrap template that goes along with this change introduces
                // a new 'ssm:GetParameter' permission, but when run using the previous bootstrap template we
                // won't have the permissions yet to read the version, so we won't be able to show the
                // message telling the user they need to update! When we see an AccessDeniedException, fall
                // back to the version we read from Stack Outputs; but ONLY if the version we discovered via
                // outputs is legitimately an old version. If it's newer than that, something else must be broken,
                // so let it fail as it would if we didn't have this fallback.
                const bootstrapStack = await this.lookupToolkit();
                if (bootstrapStack.found && bootstrapStack.version < BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER) {
                    await this.msg.ioHost.notify((0, messages_1.warn)(this.msg.action, `Could not read SSM parameter ${ssmParameterName}: ${(0, util_1.formatErrorMessage)(e)}, falling back to version from ${bootstrapStack}`));
                    doValidate(bootstrapStack.version, this.environment);
                    return;
                }
                throw new error_1.ToolkitError(`This CDK deployment requires bootstrap stack version '${expectedVersion}', but during the confirmation via SSM parameter ${ssmParameterName} the following error occurred: ${e}`);
            }
        }
        // No SSM parameter
        const bootstrapStack = await this.lookupToolkit();
        doValidate(bootstrapStack.version, this.environment);
        function doValidate(version, environment) {
            const notices = notices_1.Notices.get();
            if (notices) {
                // if `Notices` hasn't been initialized there is probably a good
                // reason for it. handle gracefully.
                notices.addBootstrappedEnvironment({ bootstrapStackVersion: version, environment });
            }
            if (defExpectedVersion > version) {
                throw new error_1.ToolkitError(`This CDK deployment requires bootstrap stack version '${expectedVersion}', found '${version}'. Please run 'cdk bootstrap'.`);
            }
        }
    }
    /**
     * Read a version from an SSM parameter, cached
     */
    async versionFromSsmParameter(parameterName) {
        var _a, _b;
        const existing = this.cache.ssmParameters.get(parameterName);
        if (existing !== undefined) {
            return existing;
        }
        const ssm = this.sdk.ssm();
        try {
            const result = await ssm.getParameter({ Name: parameterName });
            const asNumber = parseInt(`${(_a = result.Parameter) === null || _a === void 0 ? void 0 : _a.Value}`, 10);
            if (isNaN(asNumber)) {
                throw new error_1.ToolkitError(`SSM parameter ${parameterName} not a number: ${(_b = result.Parameter) === null || _b === void 0 ? void 0 : _b.Value}`);
            }
            this.cache.ssmParameters.set(parameterName, asNumber);
            return asNumber;
        }
        catch (e) {
            if (e.name === 'ParameterNotFound') {
                throw new error_1.ToolkitError(`SSM parameter ${parameterName} not found. Has the environment been bootstrapped? Please run \'cdk bootstrap\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
            }
            throw e;
        }
    }
    async prepareEcrRepository(repositoryName) {
        var _a, _b;
        if (!this.sdk) {
            throw new error_1.ToolkitError('ToolkitInfo needs to have been initialized with an sdk to call prepareEcrRepository');
        }
        const ecr = this.sdk.ecr();
        // check if repo already exists
        try {
            await this.msg.ioHost.notify((0, messages_1.debug)(this.msg.action, `${repositoryName}: checking if ECR repository already exists`));
            const describeResponse = await ecr.describeRepositories({
                repositoryNames: [repositoryName],
            });
            const existingRepositoryUri = (_a = describeResponse.repositories[0]) === null || _a === void 0 ? void 0 : _a.repositoryUri;
            if (existingRepositoryUri) {
                return { repositoryUri: existingRepositoryUri };
            }
        }
        catch (e) {
            if (e.name !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        // create the repo (tag it so it will be easier to garbage collect in the future)
        await this.msg.ioHost.notify((0, messages_1.debug)(this.msg.action, `${repositoryName}: creating ECR repository`));
        const assetTag = { Key: 'awscdk:asset', Value: 'true' };
        const response = await ecr.createRepository({
            repositoryName,
            tags: [assetTag],
        });
        const repositoryUri = (_b = response.repository) === null || _b === void 0 ? void 0 : _b.repositoryUri;
        if (!repositoryUri) {
            throw new error_1.ToolkitError(`CreateRepository did not return a repository URI for ${repositoryUri}`);
        }
        // configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        await this.msg.ioHost.notify((0, messages_1.debug)(this.msg.action, `${repositoryName}: enable image scanning`));
        await ecr.putImageScanningConfiguration({
            repositoryName,
            imageScanningConfiguration: { scanOnPush: true },
        });
        return { repositoryUri };
    }
}
exports.EnvironmentResources = EnvironmentResources;
class NoBootstrapStackEnvironmentResources extends EnvironmentResources {
    constructor(environment, sdk, msg) {
        super(environment, sdk, msg, emptyCache());
    }
    /**
     * Look up the toolkit for a given environment, using a given SDK
     */
    async lookupToolkit() {
        throw new error_1.ToolkitError('Trying to perform an operation that requires a bootstrap stack; you should not see this error, this is a bug in the CDK CLI.');
    }
}
exports.NoBootstrapStackEnvironmentResources = NoBootstrapStackEnvironmentResources;
function emptyCache() {
    return {
        ssmParameters: new Map(),
        toolkitInfo: undefined,
    };
}
/**
 * The bootstrap template version that introduced ssm:GetParameter
 */
const BOOTSTRAP_TEMPLATE_VERSION_INTRODUCING_GETPARAMETER = 5;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW52aXJvbm1lbnQtcmVzb3VyY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZW52aXJvbm1lbnQtcmVzb3VyY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLGlEQUFpRDtBQUNqRCwyQ0FBd0M7QUFFeEMsK0NBQW1EO0FBQ25ELHFDQUFnRDtBQUVoRCxrREFBc0U7QUFFdEU7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFhLDRCQUE0QjtJQUd2QyxZQUE2QixnQkFBeUI7UUFBekIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFTO1FBRnJDLFVBQUssR0FBRyxJQUFJLEdBQUcsRUFBNEIsQ0FBQztJQUc3RCxDQUFDO0lBRU0sR0FBRyxDQUFDLG1CQUFnQyxFQUFFLEdBQVEsRUFBRSxHQUFnQjtRQUNyRSxNQUFNLEdBQUcsR0FBRyxHQUFHLG1CQUFtQixDQUFDLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUMzRSxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDZCxRQUFRLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ2hDLENBQUM7UUFDRCxPQUFPLElBQUksb0JBQW9CLENBQUMsbUJBQW1CLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDbEcsQ0FBQztDQUNGO0FBZkQsb0VBZUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQWEsb0JBQW9CO0lBQy9CLFlBQ2tCLFdBQXdCLEVBQ3ZCLEdBQVEsRUFDUixHQUFnQixFQUNoQixLQUF1QixFQUN2QixnQkFBeUI7UUFKMUIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDdkIsUUFBRyxHQUFILEdBQUcsQ0FBSztRQUNSLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFDaEIsVUFBSyxHQUFMLEtBQUssQ0FBa0I7UUFDdkIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFTO0lBRTVDLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxhQUFhO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQzVCLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLE1BQU0sMEJBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDakgsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksS0FBSyxDQUFDLGVBQWUsQ0FBQyxlQUFtQyxFQUFFLGdCQUFvQztRQUNwRyxJQUFJLGVBQWUsS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUNsQyxpQkFBaUI7WUFDakIsT0FBTztRQUNULENBQUM7UUFDRCxNQUFNLGtCQUFrQixHQUFHLGVBQWUsQ0FBQztRQUUzQyxJQUFJLGdCQUFnQixLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ25DLElBQUksQ0FBQztnQkFDSCxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUMsdUJBQXVCLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ25GLE9BQU87WUFDVCxDQUFDO1lBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLHVCQUF1QixFQUFFLENBQUM7b0JBQ3ZDLE1BQU0sQ0FBQyxDQUFDO2dCQUNWLENBQUM7Z0JBRUQseUZBQXlGO2dCQUN6Riw2RkFBNkY7Z0JBQzdGLHNGQUFzRjtnQkFDdEYsMkZBQTJGO2dCQUMzRiw0RkFBNEY7Z0JBQzVGLGtHQUFrRztnQkFDbEcsOERBQThEO2dCQUM5RCxNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDbEQsSUFBSSxjQUFjLENBQUMsS0FBSyxJQUFJLGNBQWMsQ0FBQyxPQUFPLEdBQUcsbURBQW1ELEVBQUUsQ0FBQztvQkFDekcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBQSxlQUFJLEVBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUNmLGdDQUFnQyxnQkFBZ0IsS0FBSyxJQUFBLHlCQUFrQixFQUFDLENBQUMsQ0FBQyxrQ0FBa0MsY0FBYyxFQUFFLENBQzdILENBQUMsQ0FBQztvQkFDSCxVQUFVLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ3JELE9BQU87Z0JBQ1QsQ0FBQztnQkFFRCxNQUFNLElBQUksb0JBQVksQ0FDcEIseURBQXlELGVBQWUsb0RBQW9ELGdCQUFnQixrQ0FBa0MsQ0FBQyxFQUFFLENBQ2xMLENBQUM7WUFDSixDQUFDO1FBQ0gsQ0FBQztRQUVELG1CQUFtQjtRQUNuQixNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNsRCxVQUFVLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFckQsU0FBUyxVQUFVLENBQUMsT0FBZSxFQUFFLFdBQXdCO1lBQzNELE1BQU0sT0FBTyxHQUFHLGlCQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDOUIsSUFBSSxPQUFPLEVBQUUsQ0FBQztnQkFDWixnRUFBZ0U7Z0JBQ2hFLG9DQUFvQztnQkFDcEMsT0FBTyxDQUFDLDBCQUEwQixDQUFDLEVBQUUscUJBQXFCLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7WUFDdEYsQ0FBQztZQUNELElBQUksa0JBQWtCLEdBQUcsT0FBTyxFQUFFLENBQUM7Z0JBQ2pDLE1BQU0sSUFBSSxvQkFBWSxDQUNwQix5REFBeUQsZUFBZSxhQUFhLE9BQU8sZ0NBQWdDLENBQzdILENBQUM7WUFDSixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxhQUFxQjs7UUFDeEQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQzdELElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzNCLE9BQU8sUUFBUSxDQUFDO1FBQ2xCLENBQUM7UUFFRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTNCLElBQUksQ0FBQztZQUNILE1BQU0sTUFBTSxHQUFHLE1BQU0sR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDO1lBRS9ELE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxHQUFHLE1BQUEsTUFBTSxDQUFDLFNBQVMsMENBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDNUQsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztnQkFDcEIsTUFBTSxJQUFJLG9CQUFZLENBQUMsaUJBQWlCLGFBQWEsa0JBQWtCLE1BQUEsTUFBTSxDQUFDLFNBQVMsMENBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUNwRyxDQUFDO1lBRUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0RCxPQUFPLFFBQVEsQ0FBQztRQUNsQixDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLEVBQUUsQ0FBQztnQkFDbkMsTUFBTSxJQUFJLG9CQUFZLENBQ3BCLGlCQUFpQixhQUFhLHVKQUF1SixDQUN0TCxDQUFDO1lBQ0osQ0FBQztZQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ1YsQ0FBQztJQUNILENBQUM7SUFFTSxLQUFLLENBQUMsb0JBQW9CLENBQUMsY0FBc0I7O1FBQ3RELElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDZCxNQUFNLElBQUksb0JBQVksQ0FBQyxxRkFBcUYsQ0FBQyxDQUFDO1FBQ2hILENBQUM7UUFDRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTNCLCtCQUErQjtRQUMvQixJQUFJLENBQUM7WUFDSCxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFBLGdCQUFLLEVBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxjQUFjLDZDQUE2QyxDQUFDLENBQUMsQ0FBQztZQUNySCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sR0FBRyxDQUFDLG9CQUFvQixDQUFDO2dCQUN0RCxlQUFlLEVBQUUsQ0FBQyxjQUFjLENBQUM7YUFDbEMsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxxQkFBcUIsR0FBRyxNQUFBLGdCQUFnQixDQUFDLFlBQWEsQ0FBQyxDQUFDLENBQUMsMENBQUUsYUFBYSxDQUFDO1lBQy9FLElBQUkscUJBQXFCLEVBQUUsQ0FBQztnQkFDMUIsT0FBTyxFQUFFLGFBQWEsRUFBRSxxQkFBcUIsRUFBRSxDQUFDO1lBQ2xELENBQUM7UUFDSCxDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssNkJBQTZCLEVBQUUsQ0FBQztnQkFDN0MsTUFBTSxDQUFDLENBQUM7WUFDVixDQUFDO1FBQ0gsQ0FBQztRQUVELGlGQUFpRjtRQUNqRixNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFBLGdCQUFLLEVBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxjQUFjLDJCQUEyQixDQUFDLENBQUMsQ0FBQztRQUNuRyxNQUFNLFFBQVEsR0FBRyxFQUFFLEdBQUcsRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDO1FBQ3hELE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGdCQUFnQixDQUFDO1lBQzFDLGNBQWM7WUFDZCxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUM7U0FDakIsQ0FBQyxDQUFDO1FBQ0gsTUFBTSxhQUFhLEdBQUcsTUFBQSxRQUFRLENBQUMsVUFBVSwwQ0FBRSxhQUFhLENBQUM7UUFDekQsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ25CLE1BQU0sSUFBSSxvQkFBWSxDQUFDLHdEQUF3RCxhQUFhLEVBQUUsQ0FBQyxDQUFDO1FBQ2xHLENBQUM7UUFFRCx5R0FBeUc7UUFDekcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBQSxnQkFBSyxFQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsY0FBYyx5QkFBeUIsQ0FBQyxDQUFDLENBQUM7UUFDakcsTUFBTSxHQUFHLENBQUMsNkJBQTZCLENBQUM7WUFDdEMsY0FBYztZQUNkLDBCQUEwQixFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRTtTQUNqRCxDQUFDLENBQUM7UUFFSCxPQUFPLEVBQUUsYUFBYSxFQUFFLENBQUM7SUFDM0IsQ0FBQztDQUNGO0FBaktELG9EQWlLQztBQUVELE1BQWEsb0NBQXFDLFNBQVEsb0JBQW9CO0lBQzVFLFlBQVksV0FBd0IsRUFBRSxHQUFRLEVBQUUsR0FBZ0I7UUFDOUQsS0FBSyxDQUFDLFdBQVcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOztPQUVHO0lBQ0ksS0FBSyxDQUFDLGFBQWE7UUFDeEIsTUFBTSxJQUFJLG9CQUFZLENBQ3BCLDhIQUE4SCxDQUMvSCxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBYkQsb0ZBYUM7QUFZRCxTQUFTLFVBQVU7SUFDakIsT0FBTztRQUNMLGFBQWEsRUFBRSxJQUFJLEdBQUcsRUFBRTtRQUN4QixXQUFXLEVBQUUsU0FBUztLQUN2QixDQUFDO0FBQ0osQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxtREFBbUQsR0FBRyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEVudmlyb25tZW50IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vLi4vY2xpL21lc3NhZ2VzJztcbmltcG9ydCB7IE5vdGljZXMgfSBmcm9tICcuLi8uLi9ub3RpY2VzJztcbmltcG9ydCB7IElvTWVzc2FnaW5nIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9jbGktaW8taG9zdCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyB0eXBlIEVjclJlcG9zaXRvcnlJbmZvLCBUb29sa2l0SW5mbyB9IGZyb20gJy4uL3Rvb2xraXQtaW5mbyc7XG5cbi8qKlxuICogUmVnaXN0cnkgY2xhc3MgZm9yIGBFbnZpcm9ubWVudFJlc291cmNlc2AuXG4gKlxuICogVGhlIHN0YXRlIG1hbmFnZW1lbnQgb2YgdGhpcyBjbGFzcyBpcyBhIGJpdCBub24tc3RhbmRhcmQuIFdlIHdhbnQgdG8gY2FjaGVcbiAqIGRhdGEgcmVsYXRlZCB0byB0b29sa2l0IHN0YWNrcyBhbmQgU1NNIHBhcmFtZXRlcnMsIGJ1dCB3ZSBhcmUgbm90IGluIGNoYXJnZVxuICogb2YgZW5zdXJpbmcgY2FjaGluZyBvZiBTREtzLiBTaW5jZSBgRW52aXJvbm1lbnRSZXNvdXJjZXNgIG5lZWRzIGFuIFNESyB0b1xuICogZnVuY3Rpb24sIHdlIHRyZWF0IGl0IGFzIGFuIGVwaGVtZXJhbCBjbGFzcywgYW5kIHN0b3JlIHRoZSBhY3R1YWwgY2FjaGVkIGRhdGFcbiAqIGluIGBFbnZpcm9ubWVudFJlc291cmNlc1JlZ2lzdHJ5YC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVudmlyb25tZW50UmVzb3VyY2VzUmVnaXN0cnkge1xuICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEVudmlyb25tZW50Q2FjaGU+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nKSB7XG4gIH1cblxuICBwdWJsaWMgZm9yKHJlc29sdmVkRW52aXJvbm1lbnQ6IEVudmlyb25tZW50LCBzZGs6IFNESywgbXNnOiBJb01lc3NhZ2luZykge1xuICAgIGNvbnN0IGtleSA9IGAke3Jlc29sdmVkRW52aXJvbm1lbnQuYWNjb3VudH06JHtyZXNvbHZlZEVudmlyb25tZW50LnJlZ2lvbn1gO1xuICAgIGxldCBlbnZDYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFlbnZDYWNoZSkge1xuICAgICAgZW52Q2FjaGUgPSBlbXB0eUNhY2hlKCk7XG4gICAgICB0aGlzLmNhY2hlLnNldChrZXksIGVudkNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFbnZpcm9ubWVudFJlc291cmNlcyhyZXNvbHZlZEVudmlyb25tZW50LCBzZGssIG1zZywgZW52Q2FjaGUsIHRoaXMudG9vbGtpdFN0YWNrTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2Ugd2l0aCB0aGUgYWNjb3VudCBhbmQgcmVnaW9uIHdlJ3JlIGRlcGxveWluZyBpbnRvXG4gKlxuICogTWFuYWdlcyBsb29rdXBzIGZvciBib290c3RyYXBwZWQgcmVzb3VyY2VzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxlZ2FjeSBcIkNESyBUb29sa2l0XCJcbiAqIG9yaWdpbmFsIGJvb3RzdHJhcCBzdGFjayBpZiBuZWNlc3NhcnkuXG4gKlxuICogVGhlIHN0YXRlIG1hbmFnZW1lbnQgb2YgdGhpcyBjbGFzcyBpcyBhIGJpdCBub24tc3RhbmRhcmQuIFdlIHdhbnQgdG8gY2FjaGVcbiAqIGRhdGEgcmVsYXRlZCB0byB0b29sa2l0IHN0YWNrcyBhbmQgU1NNIHBhcmFtZXRlcnMsIGJ1dCB3ZSBhcmUgbm90IGluIGNoYXJnZVxuICogb2YgZW5zdXJpbmcgY2FjaGluZyBvZiBTREtzLiBTaW5jZSBgRW52aXJvbm1lbnRSZXNvdXJjZXNgIG5lZWRzIGFuIFNESyB0b1xuICogZnVuY3Rpb24sIHdlIHRyZWF0IGl0IGFzIGFuIGVwaGVtZXJhbCBjbGFzcywgYW5kIHN0b3JlIHRoZSBhY3R1YWwgY2FjaGVkIGRhdGFcbiAqIGluIGBFbnZpcm9ubWVudFJlc291cmNlc1JlZ2lzdHJ5YC5cbiAqL1xuZXhwb3J0IGNsYXNzIEVudmlyb25tZW50UmVzb3VyY2VzIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGVudmlyb25tZW50OiBFbnZpcm9ubWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNkazogU0RLLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbXNnOiBJb01lc3NhZ2luZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhY2hlOiBFbnZpcm9ubWVudENhY2hlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZyxcbiAgKSB7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCB0aGUgdG9vbGtpdCBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudCwgdXNpbmcgYSBnaXZlbiBTREtcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb29rdXBUb29sa2l0KCkge1xuICAgIGlmICghdGhpcy5jYWNoZS50b29sa2l0SW5mbykge1xuICAgICAgdGhpcy5jYWNoZS50b29sa2l0SW5mbyA9IGF3YWl0IFRvb2xraXRJbmZvLmxvb2t1cCh0aGlzLmVudmlyb25tZW50LCB0aGlzLnNkaywgdGhpcy5tc2csIHRoaXMudG9vbGtpdFN0YWNrTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlLnRvb2xraXRJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgdGhlIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uIG1hdGNoZXMgb3IgZXhjZWVkcyB0aGUgZXhwZWN0ZWQgdmVyc2lvblxuICAgKlxuICAgKiBVc2UgdGhlIFNTTSBwYXJhbWV0ZXIgbmFtZSB0byByZWFkIHRoZSB2ZXJzaW9uIG51bWJlciBpZiBnaXZlbiwgb3RoZXJ3aXNlIHVzZSB0aGUgdmVyc2lvblxuICAgKiBkaXNjb3ZlcmVkIG9uIHRoZSBib290c3RyYXAgc3RhY2suXG4gICAqXG4gICAqIFBhc3MgaW4gdGhlIFNTTSBwYXJhbWV0ZXIgbmFtZSBzbyB3ZSBjYW4gY2FjaGUgdGhlIGxvb2t1cHMgYW4gZG9uJ3QgbmVlZCB0byBkbyB0aGUgc2FtZVxuICAgKiBsb29rdXAgYWdhaW4gYW5kIGFnYWluIGZvciBldmVyeSBhcnRpZmFjdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB2YWxpZGF0ZVZlcnNpb24oZXhwZWN0ZWRWZXJzaW9uOiBudW1iZXIgfCB1bmRlZmluZWQsIHNzbVBhcmFtZXRlck5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChleHBlY3RlZFZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm8gcmVxdWlyZW1lbnRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVmRXhwZWN0ZWRWZXJzaW9uID0gZXhwZWN0ZWRWZXJzaW9uO1xuXG4gICAgaWYgKHNzbVBhcmFtZXRlck5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9WYWxpZGF0ZShhd2FpdCB0aGlzLnZlcnNpb25Gcm9tU3NtUGFyYW1ldGVyKHNzbVBhcmFtZXRlck5hbWUpLCB0aGlzLmVudmlyb25tZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgIGlmIChlLm5hbWUgIT09ICdBY2Nlc3NEZW5pZWRFeGNlcHRpb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgaXMgYSBmYWxsYmFjayEgVGhlIGJvb3RzdHJhcCB0ZW1wbGF0ZSB0aGF0IGdvZXMgYWxvbmcgd2l0aCB0aGlzIGNoYW5nZSBpbnRyb2R1Y2VzXG4gICAgICAgIC8vIGEgbmV3ICdzc206R2V0UGFyYW1ldGVyJyBwZXJtaXNzaW9uLCBidXQgd2hlbiBydW4gdXNpbmcgdGhlIHByZXZpb3VzIGJvb3RzdHJhcCB0ZW1wbGF0ZSB3ZVxuICAgICAgICAvLyB3b24ndCBoYXZlIHRoZSBwZXJtaXNzaW9ucyB5ZXQgdG8gcmVhZCB0aGUgdmVyc2lvbiwgc28gd2Ugd29uJ3QgYmUgYWJsZSB0byBzaG93IHRoZVxuICAgICAgICAvLyBtZXNzYWdlIHRlbGxpbmcgdGhlIHVzZXIgdGhleSBuZWVkIHRvIHVwZGF0ZSEgV2hlbiB3ZSBzZWUgYW4gQWNjZXNzRGVuaWVkRXhjZXB0aW9uLCBmYWxsXG4gICAgICAgIC8vIGJhY2sgdG8gdGhlIHZlcnNpb24gd2UgcmVhZCBmcm9tIFN0YWNrIE91dHB1dHM7IGJ1dCBPTkxZIGlmIHRoZSB2ZXJzaW9uIHdlIGRpc2NvdmVyZWQgdmlhXG4gICAgICAgIC8vIG91dHB1dHMgaXMgbGVnaXRpbWF0ZWx5IGFuIG9sZCB2ZXJzaW9uLiBJZiBpdCdzIG5ld2VyIHRoYW4gdGhhdCwgc29tZXRoaW5nIGVsc2UgbXVzdCBiZSBicm9rZW4sXG4gICAgICAgIC8vIHNvIGxldCBpdCBmYWlsIGFzIGl0IHdvdWxkIGlmIHdlIGRpZG4ndCBoYXZlIHRoaXMgZmFsbGJhY2suXG4gICAgICAgIGNvbnN0IGJvb3RzdHJhcFN0YWNrID0gYXdhaXQgdGhpcy5sb29rdXBUb29sa2l0KCk7XG4gICAgICAgIGlmIChib290c3RyYXBTdGFjay5mb3VuZCAmJiBib290c3RyYXBTdGFjay52ZXJzaW9uIDwgQk9PVFNUUkFQX1RFTVBMQVRFX1ZFUlNJT05fSU5UUk9EVUNJTkdfR0VUUEFSQU1FVEVSKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5tc2cuaW9Ib3N0Lm5vdGlmeSh3YXJuKFxuICAgICAgICAgICAgdGhpcy5tc2cuYWN0aW9uLFxuICAgICAgICAgICAgYENvdWxkIG5vdCByZWFkIFNTTSBwYXJhbWV0ZXIgJHtzc21QYXJhbWV0ZXJOYW1lfTogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9LCBmYWxsaW5nIGJhY2sgdG8gdmVyc2lvbiBmcm9tICR7Ym9vdHN0cmFwU3RhY2t9YCxcbiAgICAgICAgICApKTtcbiAgICAgICAgICBkb1ZhbGlkYXRlKGJvb3RzdHJhcFN0YWNrLnZlcnNpb24sIHRoaXMuZW52aXJvbm1lbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgICAgYFRoaXMgQ0RLIGRlcGxveW1lbnQgcmVxdWlyZXMgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb24gJyR7ZXhwZWN0ZWRWZXJzaW9ufScsIGJ1dCBkdXJpbmcgdGhlIGNvbmZpcm1hdGlvbiB2aWEgU1NNIHBhcmFtZXRlciAke3NzbVBhcmFtZXRlck5hbWV9IHRoZSBmb2xsb3dpbmcgZXJyb3Igb2NjdXJyZWQ6ICR7ZX1gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIFNTTSBwYXJhbWV0ZXJcbiAgICBjb25zdCBib290c3RyYXBTdGFjayA9IGF3YWl0IHRoaXMubG9va3VwVG9vbGtpdCgpO1xuICAgIGRvVmFsaWRhdGUoYm9vdHN0cmFwU3RhY2sudmVyc2lvbiwgdGhpcy5lbnZpcm9ubWVudCk7XG5cbiAgICBmdW5jdGlvbiBkb1ZhbGlkYXRlKHZlcnNpb246IG51bWJlciwgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50KSB7XG4gICAgICBjb25zdCBub3RpY2VzID0gTm90aWNlcy5nZXQoKTtcbiAgICAgIGlmIChub3RpY2VzKSB7XG4gICAgICAgIC8vIGlmIGBOb3RpY2VzYCBoYXNuJ3QgYmVlbiBpbml0aWFsaXplZCB0aGVyZSBpcyBwcm9iYWJseSBhIGdvb2RcbiAgICAgICAgLy8gcmVhc29uIGZvciBpdC4gaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAgICAgIG5vdGljZXMuYWRkQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQoeyBib290c3RyYXBTdGFja1ZlcnNpb246IHZlcnNpb24sIGVudmlyb25tZW50IH0pO1xuICAgICAgfVxuICAgICAgaWYgKGRlZkV4cGVjdGVkVmVyc2lvbiA+IHZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgVGhpcyBDREsgZGVwbG95bWVudCByZXF1aXJlcyBib290c3RyYXAgc3RhY2sgdmVyc2lvbiAnJHtleHBlY3RlZFZlcnNpb259JywgZm91bmQgJyR7dmVyc2lvbn0nLiBQbGVhc2UgcnVuICdjZGsgYm9vdHN0cmFwJy5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgdmVyc2lvbiBmcm9tIGFuIFNTTSBwYXJhbWV0ZXIsIGNhY2hlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHZlcnNpb25Gcm9tU3NtUGFyYW1ldGVyKHBhcmFtZXRlck5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmNhY2hlLnNzbVBhcmFtZXRlcnMuZ2V0KHBhcmFtZXRlck5hbWUpO1xuICAgIGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuXG4gICAgY29uc3Qgc3NtID0gdGhpcy5zZGsuc3NtKCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3NtLmdldFBhcmFtZXRlcih7IE5hbWU6IHBhcmFtZXRlck5hbWUgfSk7XG5cbiAgICAgIGNvbnN0IGFzTnVtYmVyID0gcGFyc2VJbnQoYCR7cmVzdWx0LlBhcmFtZXRlcj8uVmFsdWV9YCwgMTApO1xuICAgICAgaWYgKGlzTmFOKGFzTnVtYmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBTU00gcGFyYW1ldGVyICR7cGFyYW1ldGVyTmFtZX0gbm90IGEgbnVtYmVyOiAke3Jlc3VsdC5QYXJhbWV0ZXI/LlZhbHVlfWApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhY2hlLnNzbVBhcmFtZXRlcnMuc2V0KHBhcmFtZXRlck5hbWUsIGFzTnVtYmVyKTtcbiAgICAgIHJldHVybiBhc051bWJlcjtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLm5hbWUgPT09ICdQYXJhbWV0ZXJOb3RGb3VuZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgICBgU1NNIHBhcmFtZXRlciAke3BhcmFtZXRlck5hbWV9IG5vdCBmb3VuZC4gSGFzIHRoZSBlbnZpcm9ubWVudCBiZWVuIGJvb3RzdHJhcHBlZD8gUGxlYXNlIHJ1biBcXCdjZGsgYm9vdHN0cmFwXFwnIChzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay9sYXRlc3QvZ3VpZGUvYm9vdHN0cmFwcGluZy5odG1sKWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwcmVwYXJlRWNyUmVwb3NpdG9yeShyZXBvc2l0b3J5TmFtZTogc3RyaW5nKTogUHJvbWlzZTxFY3JSZXBvc2l0b3J5SW5mbz4ge1xuICAgIGlmICghdGhpcy5zZGspIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1Rvb2xraXRJbmZvIG5lZWRzIHRvIGhhdmUgYmVlbiBpbml0aWFsaXplZCB3aXRoIGFuIHNkayB0byBjYWxsIHByZXBhcmVFY3JSZXBvc2l0b3J5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGVjciA9IHRoaXMuc2RrLmVjcigpO1xuXG4gICAgLy8gY2hlY2sgaWYgcmVwbyBhbHJlYWR5IGV4aXN0c1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLm1zZy5pb0hvc3Qubm90aWZ5KGRlYnVnKHRoaXMubXNnLmFjdGlvbiwgYCR7cmVwb3NpdG9yeU5hbWV9OiBjaGVja2luZyBpZiBFQ1IgcmVwb3NpdG9yeSBhbHJlYWR5IGV4aXN0c2ApKTtcbiAgICAgIGNvbnN0IGRlc2NyaWJlUmVzcG9uc2UgPSBhd2FpdCBlY3IuZGVzY3JpYmVSZXBvc2l0b3JpZXMoe1xuICAgICAgICByZXBvc2l0b3J5TmFtZXM6IFtyZXBvc2l0b3J5TmFtZV0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUmVwb3NpdG9yeVVyaSA9IGRlc2NyaWJlUmVzcG9uc2UucmVwb3NpdG9yaWVzIVswXT8ucmVwb3NpdG9yeVVyaTtcbiAgICAgIGlmIChleGlzdGluZ1JlcG9zaXRvcnlVcmkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVwb3NpdG9yeVVyaTogZXhpc3RpbmdSZXBvc2l0b3J5VXJpIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnUmVwb3NpdG9yeU5vdEZvdW5kRXhjZXB0aW9uJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgcmVwbyAodGFnIGl0IHNvIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGdhcmJhZ2UgY29sbGVjdCBpbiB0aGUgZnV0dXJlKVxuICAgIGF3YWl0IHRoaXMubXNnLmlvSG9zdC5ub3RpZnkoZGVidWcodGhpcy5tc2cuYWN0aW9uLCBgJHtyZXBvc2l0b3J5TmFtZX06IGNyZWF0aW5nIEVDUiByZXBvc2l0b3J5YCkpO1xuICAgIGNvbnN0IGFzc2V0VGFnID0geyBLZXk6ICdhd3NjZGs6YXNzZXQnLCBWYWx1ZTogJ3RydWUnIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlY3IuY3JlYXRlUmVwb3NpdG9yeSh7XG4gICAgICByZXBvc2l0b3J5TmFtZSxcbiAgICAgIHRhZ3M6IFthc3NldFRhZ10sXG4gICAgfSk7XG4gICAgY29uc3QgcmVwb3NpdG9yeVVyaSA9IHJlc3BvbnNlLnJlcG9zaXRvcnk/LnJlcG9zaXRvcnlVcmk7XG4gICAgaWYgKCFyZXBvc2l0b3J5VXJpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDcmVhdGVSZXBvc2l0b3J5IGRpZCBub3QgcmV0dXJuIGEgcmVwb3NpdG9yeSBVUkkgZm9yICR7cmVwb3NpdG9yeVVyaX1gKTtcbiAgICB9XG5cbiAgICAvLyBjb25maWd1cmUgaW1hZ2Ugc2Nhbm5pbmcgb24gcHVzaCAoaGVscHMgaW4gaWRlbnRpZnlpbmcgc29mdHdhcmUgdnVsbmVyYWJpbGl0aWVzLCBubyBhZGRpdGlvbmFsIGNoYXJnZSlcbiAgICBhd2FpdCB0aGlzLm1zZy5pb0hvc3Qubm90aWZ5KGRlYnVnKHRoaXMubXNnLmFjdGlvbiwgYCR7cmVwb3NpdG9yeU5hbWV9OiBlbmFibGUgaW1hZ2Ugc2Nhbm5pbmdgKSk7XG4gICAgYXdhaXQgZWNyLnB1dEltYWdlU2Nhbm5pbmdDb25maWd1cmF0aW9uKHtcbiAgICAgIHJlcG9zaXRvcnlOYW1lLFxuICAgICAgaW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb246IHsgc2Nhbk9uUHVzaDogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgcmVwb3NpdG9yeVVyaSB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb0Jvb3RzdHJhcFN0YWNrRW52aXJvbm1lbnRSZXNvdXJjZXMgZXh0ZW5kcyBFbnZpcm9ubWVudFJlc291cmNlcyB7XG4gIGNvbnN0cnVjdG9yKGVudmlyb25tZW50OiBFbnZpcm9ubWVudCwgc2RrOiBTREssIG1zZzogSW9NZXNzYWdpbmcpIHtcbiAgICBzdXBlcihlbnZpcm9ubWVudCwgc2RrLCBtc2csIGVtcHR5Q2FjaGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogTG9vayB1cCB0aGUgdG9vbGtpdCBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudCwgdXNpbmcgYSBnaXZlbiBTREtcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb29rdXBUb29sa2l0KCk6IFByb21pc2U8VG9vbGtpdEluZm8+IHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgJ1RyeWluZyB0byBwZXJmb3JtIGFuIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIGEgYm9vdHN0cmFwIHN0YWNrOyB5b3Ugc2hvdWxkIG5vdCBzZWUgdGhpcyBlcnJvciwgdGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQ0RLIENMSS4nLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIHRoYXQgaXMgY2FjaGVkIG9uIGEgcGVyLWVudmlyb25tZW50IGxldmVsXG4gKlxuICogVGhpcyBjYWNoZSBtYXkgYmUgc2hhcmVkIGJldHdlZW4gZGlmZmVyZW50IGluc3RhbmNlcyBvZiB0aGUgYEVudmlyb25tZW50UmVzb3VyY2VzYCBjbGFzcy5cbiAqL1xuaW50ZXJmYWNlIEVudmlyb25tZW50Q2FjaGUge1xuICByZWFkb25seSBzc21QYXJhbWV0ZXJzOiBNYXA8c3RyaW5nLCBudW1iZXI+O1xuICB0b29sa2l0SW5mbz86IFRvb2xraXRJbmZvO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhY2hlKCk6IEVudmlyb25tZW50Q2FjaGUge1xuICByZXR1cm4ge1xuICAgIHNzbVBhcmFtZXRlcnM6IG5ldyBNYXAoKSxcbiAgICB0b29sa2l0SW5mbzogdW5kZWZpbmVkLFxuICB9O1xufVxuXG4vKipcbiAqIFRoZSBib290c3RyYXAgdGVtcGxhdGUgdmVyc2lvbiB0aGF0IGludHJvZHVjZWQgc3NtOkdldFBhcmFtZXRlclxuICovXG5jb25zdCBCT09UU1RSQVBfVEVNUExBVEVfVkVSU0lPTl9JTlRST0RVQ0lOR19HRVRQQVJBTUVURVIgPSA1O1xuIl19