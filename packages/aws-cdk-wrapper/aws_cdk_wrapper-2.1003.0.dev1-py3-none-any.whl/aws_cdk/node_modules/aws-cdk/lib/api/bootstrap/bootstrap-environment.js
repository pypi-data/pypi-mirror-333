"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const console_1 = require("console");
const path = require("path");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
const messages_1 = require("../../cli/messages");
const error_1 = require("../../toolkit/error");
const util_1 = require("../../util");
const mode_1 = require("../plugin/mode");
const toolkit_info_1 = require("../toolkit-info");
class Bootstrapper {
    constructor(source = { source: 'default' }, msg) {
        this.source = source;
        this.msg = msg;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate(json) {
        const template = await this.loadTemplate();
        process.stdout.write(`${(0, util_1.serializeStructure)(template, json)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        var _a, _b, _c, _d, _e;
        const params = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};
        if ((_b = params.trustedAccounts) === null || _b === void 0 ? void 0 : _b.length) {
            throw new error_1.ToolkitError('--trust can only be passed for the modern bootstrap experience.');
        }
        if ((_c = params.cloudFormationExecutionPolicies) === null || _c === void 0 ? void 0 : _c.length) {
            throw new error_1.ToolkitError('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new error_1.ToolkitError('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new error_1.ToolkitError('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const toolkitStackName = (_d = options.toolkitStackName) !== null && _d !== void 0 ? _d : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.msg);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: (_e = options.terminationProtection) !== null && _e !== void 0 ? _e : current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const params = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};
        const bootstrapTemplate = await this.loadTemplate();
        const toolkitStackName = (_b = options.toolkitStackName) !== null && _b !== void 0 ? _b : toolkit_info_1.DEFAULT_TOOLKIT_STACK_NAME;
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, toolkitStackName, this.msg);
        const partition = await current.partition();
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new error_1.ToolkitError("You cannot pass '--bootstrap-kms-key-id' and '--bootstrap-customer-key' together. Specify one or the other");
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const allTrusted = new Set([
            ...(_c = params.trustedAccounts) !== null && _c !== void 0 ? _c : [],
            ...(_d = params.trustedAccountsForLookup) !== null && _d !== void 0 ? _d : [],
        ]);
        const invalid = intersection(allTrusted, new Set(params.untrustedAccounts));
        if (invalid.size > 0) {
            throw new error_1.ToolkitError(`Accounts cannot be both trusted and untrusted. Found: ${[...invalid].join(',')}`);
        }
        const removeUntrusted = (accounts) => accounts.filter(acc => { var _a; return !((_a = params.untrustedAccounts) === null || _a === void 0 ? void 0 : _a.map(String).includes(String(acc))); });
        const trustedAccounts = removeUntrusted((_e = params.trustedAccounts) !== null && _e !== void 0 ? _e : splitCfnArray(current.parameters.TrustedAccounts));
        (0, console_1.info)(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = removeUntrusted((_f = params.trustedAccountsForLookup) !== null && _f !== void 0 ? _f : splitCfnArray(current.parameters.TrustedAccountsForLookup));
        (0, console_1.info)(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = (_g = params.cloudFormationExecutionPolicies) !== null && _g !== void 0 ? _g : splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicitly policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${partition}:iam::aws:policy/AdministratorAccess`;
            await this.msg.ioHost.notify((0, messages_1.warn)(this.msg.action, `Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`));
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new error_1.ToolkitError(`Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:${partition}:iam::aws:policy/<PolicyName>\'.`);
        }
        else {
            // Remind people what the current settings are
            (0, console_1.info)(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = (_h = params.kmsKeyId) !== null && _h !== void 0 ? _h : (params.createCustomerMasterKey === true
            ? CREATE_NEW_KEY
            : params.createCustomerMasterKey === false || currentKmsKeyId === undefined
                ? USE_AWS_MANAGED_KEY
                : undefined);
        /* A permissions boundary can be provided via:
         *    - the flag indicating the example one should be used
         *    - the name indicating the custom permissions boundary to be used
         * Re-bootstrapping will NOT be blocked by either tightening or relaxing the permissions' boundary.
         */
        // InputPermissionsBoundary is an `any` type and if it is not defined it
        // appears as an empty string ''. We need to force it to evaluate an empty string
        // as undefined
        const currentPermissionsBoundary = current.parameters.InputPermissionsBoundary || undefined;
        const inputPolicyName = params.examplePermissionsBoundary
            ? CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY
            : params.customPermissionsBoundary;
        let policyName;
        if (inputPolicyName) {
            // If the example policy is not already in place, it must be created.
            const sdk = (await sdkProvider.forEnvironment(environment, mode_1.Mode.ForWriting)).sdk;
            policyName = await this.getPolicyName(environment, sdk, inputPolicyName, partition, params);
        }
        if (currentPermissionsBoundary !== policyName) {
            if (!currentPermissionsBoundary) {
                await this.msg.ioHost.notify((0, messages_1.warn)(this.msg.action, `Adding new permissions boundary ${policyName}`));
            }
            else if (!policyName) {
                await this.msg.ioHost.notify((0, messages_1.warn)(this.msg.action, `Removing existing permissions boundary ${currentPermissionsBoundary}`));
            }
            else {
                await this.msg.ioHost.notify((0, messages_1.warn)(this.msg.action, `Changing permissions boundary from ${currentPermissionsBoundary} to ${policyName}`));
            }
        }
        return current.update(bootstrapTemplate, {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined
                ? 'true'
                : 'false',
            InputPermissionsBoundary: policyName,
        }, {
            ...options,
            terminationProtection: (_j = options.terminationProtection) !== null && _j !== void 0 ? _j : current.terminationProtection,
        });
    }
    async getPolicyName(environment, sdk, permissionsBoundary, partition, params) {
        var _a;
        if (permissionsBoundary !== CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY) {
            this.validatePolicyName(permissionsBoundary);
            return Promise.resolve(permissionsBoundary);
        }
        // if no Qualifier is supplied, resort to the default one
        const arn = await this.getExamplePermissionsBoundary((_a = params.qualifier) !== null && _a !== void 0 ? _a : 'hnb659fds', partition, environment.account, sdk);
        const policyName = arn.split('/').pop();
        if (!policyName) {
            throw new error_1.ToolkitError('Could not retrieve the example permission boundary!');
        }
        return Promise.resolve(policyName);
    }
    async getExamplePermissionsBoundary(qualifier, partition, account, sdk) {
        var _a;
        const iam = sdk.iam();
        let policyName = `cdk-${qualifier}-permissions-boundary`;
        const arn = `arn:${partition}:iam::${account}:policy/${policyName}`;
        try {
            let getPolicyResp = await iam.getPolicy({ PolicyArn: arn });
            if (getPolicyResp.Policy) {
                return arn;
            }
        }
        catch (e) {
            // https://docs.aws.amazon.com/IAM/latest/APIReference/API_GetPolicy.html#API_GetPolicy_Errors
            if (e.name === 'NoSuchEntity') {
                // noop, proceed with creating the policy
            }
            else {
                throw e;
            }
        }
        const policyDoc = {
            Version: '2012-10-17',
            Statement: [
                {
                    Action: ['*'],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'ExplicitAllowAll',
                },
                {
                    Condition: {
                        StringEquals: {
                            'iam:PermissionsBoundary': `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                        },
                    },
                    Action: [
                        'iam:CreateUser',
                        'iam:CreateRole',
                        'iam:PutRolePermissionsBoundary',
                        'iam:PutUserPermissionsBoundary',
                    ],
                    Resource: '*',
                    Effect: 'Allow',
                    Sid: 'DenyAccessIfRequiredPermBoundaryIsNotBeingApplied',
                },
                {
                    Action: [
                        'iam:CreatePolicyVersion',
                        'iam:DeletePolicy',
                        'iam:DeletePolicyVersion',
                        'iam:SetDefaultPolicyVersion',
                    ],
                    Resource: `arn:${partition}:iam::${account}:policy/cdk-${qualifier}-permissions-boundary`,
                    Effect: 'Deny',
                    Sid: 'DenyPermBoundaryIAMPolicyAlteration',
                },
                {
                    Action: ['iam:DeleteUserPermissionsBoundary', 'iam:DeleteRolePermissionsBoundary'],
                    Resource: '*',
                    Effect: 'Deny',
                    Sid: 'DenyRemovalOfPermBoundaryFromAnyUserOrRole',
                },
            ],
        };
        const request = {
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDoc),
        };
        const createPolicyResponse = await iam.createPolicy(request);
        if ((_a = createPolicyResponse.Policy) === null || _a === void 0 ? void 0 : _a.Arn) {
            return createPolicyResponse.Policy.Arn;
        }
        else {
            throw new error_1.ToolkitError(`Could not retrieve the example permission boundary ${arn}!`);
        }
    }
    validatePolicyName(permissionsBoundary) {
        // https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html
        // Added support for policy names with a path
        // See https://github.com/aws/aws-cdk/issues/26320
        const regexp = /[\w+\/=,.@-]+/;
        const matches = regexp.exec(permissionsBoundary);
        if (!(matches && matches.length === 1 && matches[0] === permissionsBoundary)) {
            throw new error_1.ToolkitError(`The permissions boundary name ${permissionsBoundary} does not match the IAM conventions.`);
        }
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = (0, deploy_bootstrap_1.bootstrapVersionFromTemplate)(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    async loadTemplate(params = {}) {
        switch (this.source.source) {
            case 'custom':
                return (0, util_1.loadStructuredFile)(this.source.templateFile);
            case 'default':
                return (0, util_1.loadStructuredFile)(path.join((0, util_1.bundledPackageRootDir)(__dirname), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return (0, legacy_template_1.legacyBootstrapTemplate)(params);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default key
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Parameter value indicating the use of the default, CDK provided permissions boundary for bootstrap-template.yml
 */
const CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY = 'CDK_BOOTSTRAP_PERMISSIONS_BOUNDARY';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
function intersection(xs, ys) {
    return new Set(Array.from(xs).filter(x => ys.has(x)));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUErQjtBQUMvQiw2QkFBNkI7QUFHN0IseURBQWtGO0FBQ2xGLHVEQUE0RDtBQUM1RCxpREFBMEM7QUFFMUMsK0NBQW1EO0FBQ25ELHFDQUEyRjtBQUczRix5Q0FBc0M7QUFDdEMsa0RBQTZEO0FBSTdELE1BQWEsWUFBWTtJQUN2QixZQUNtQixTQUEwQixFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFDL0MsR0FBZ0I7UUFEaEIsV0FBTSxHQUFOLE1BQU0sQ0FBeUM7UUFDL0MsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUVuQyxDQUFDO0lBRU0sb0JBQW9CLENBQ3pCLFdBQThCLEVBQzlCLFdBQXdCLEVBQ3hCLFVBQXVDLEVBQUU7UUFFekMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQzNCLEtBQUssUUFBUTtnQkFDWCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFNBQVM7Z0JBQ1osT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ25FLENBQUM7SUFDSCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFhO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzNDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBQSx5QkFBa0IsRUFBQyxRQUFRLEVBQUUsSUFBSSxD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LElBQUksR0FBRyxDQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZm8gfSBmcm9tICdjb25zb2xlJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHR5cGUgeyBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMsIEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzIH0gZnJvbSAnLi9ib290c3RyYXAtcHJvcHMnO1xuaW1wb3J0IHsgQm9vdHN0cmFwU3RhY2ssIGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUgfSBmcm9tICcuL2RlcGxveS1ib290c3RyYXAnO1xuaW1wb3J0IHsgbGVnYWN5Qm9vdHN0cmFwVGVtcGxhdGUgfSBmcm9tICcuL2xlZ2FjeS10ZW1wbGF0ZSc7XG5pbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vLi4vY2xpL21lc3NhZ2VzJztcbmltcG9ydCB7IElvTWVzc2FnaW5nIH0gZnJvbSAnLi4vLi4vdG9vbGtpdC9jbGktaW8taG9zdCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IGJ1bmRsZWRQYWNrYWdlUm9vdERpciwgbG9hZFN0cnVjdHVyZWRGaWxlLCBzZXJpYWxpemVTdHJ1Y3R1cmUgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB0eXBlIHsgU0RLLCBTZGtQcm92aWRlciB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB0eXBlIHsgU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL3BsdWdpbi9tb2RlJztcbmltcG9ydCB7IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FIH0gZnJvbSAnLi4vdG9vbGtpdC1pbmZvJztcblxuZXhwb3J0IHR5cGUgQm9vdHN0cmFwU291cmNlID0geyBzb3VyY2U6ICdsZWdhY3knIH0gfCB7IHNvdXJjZTogJ2RlZmF1bHQnIH0gfCB7IHNvdXJjZTogJ2N1c3RvbSc7IHRlbXBsYXRlRmlsZTogc3RyaW5nIH07XG5cbmV4cG9ydCBjbGFzcyBCb290c3RyYXBwZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNvdXJjZTogQm9vdHN0cmFwU291cmNlID0geyBzb3VyY2U6ICdkZWZhdWx0JyB9LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbXNnOiBJb01lc3NhZ2luZyxcbiAgKSB7XG4gIH1cblxuICBwdWJsaWMgYm9vdHN0cmFwRW52aXJvbm1lbnQoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBzd2l0Y2ggKHRoaXMuc291cmNlLnNvdXJjZSkge1xuICAgICAgY2FzZSAnbGVnYWN5JzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnYWN5Qm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZXJuQm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2hvd1RlbXBsYXRlKGpzb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMubG9hZFRlbXBsYXRlKCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7c2VyaWFsaXplU3RydWN0dXJlKHRlbXBsYXRlLCBqc29uKX1cXG5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgbGVnYWN5IGJvb3RzdHJhcCBzdGFja1xuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsZWdhY3lCb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSxcbiAgKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLnBhcmFtZXRlcnMgPz8ge307XG5cbiAgICBpZiAocGFyYW1zLnRydXN0ZWRBY2NvdW50cz8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCctLXRydXN0IGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCctLWJvb3RzdHJhcC1jdXN0b21lci1rZXkgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnF1YWxpZmllcikge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignLS1xdWFsaWZpZXIgY2FuIG9ubHkgYmUgcGFzc2VkIGZvciB0aGUgbW9kZXJuIGJvb3RzdHJhcCBleHBlcmllbmNlLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHRvb2xraXRTdGFja05hbWUgPSBvcHRpb25zLnRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IEJvb3RzdHJhcFN0YWNrLmxvb2t1cChzZGtQcm92aWRlciwgZW52aXJvbm1lbnQsIHRvb2xraXRTdGFja05hbWUsIHRoaXMubXNnKTtcbiAgICByZXR1cm4gY3VycmVudC51cGRhdGUoXG4gICAgICBhd2FpdCB0aGlzLmxvYWRUZW1wbGF0ZShwYXJhbXMpLFxuICAgICAge30sXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVwbG95IENJL0NELXJlYWR5IGJvb3RzdHJhcCBzdGFjayBmcm9tIHRlbXBsYXRlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1vZGVybkJvb3RzdHJhcChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9LFxuICApOiBQcm9taXNlPFN1Y2Nlc3NmdWxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1ldGVycyA/PyB7fTtcblxuICAgIGNvbnN0IGJvb3RzdHJhcFRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKTtcblxuICAgIGNvbnN0IHRvb2xraXRTdGFja05hbWUgPSBvcHRpb25zLnRvb2xraXRTdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG4gICAgY29uc3QgY3VycmVudCA9IGF3YWl0IEJvb3RzdHJhcFN0YWNrLmxvb2t1cChzZGtQcm92aWRlciwgZW52aXJvbm1lbnQsIHRvb2xraXRTdGFja05hbWUsIHRoaXMubXNnKTtcbiAgICBjb25zdCBwYXJ0aXRpb24gPSBhd2FpdCBjdXJyZW50LnBhcnRpdGlvbigpO1xuXG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5rbXNLZXlJZCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgXCJZb3UgY2Fubm90IHBhc3MgJy0tYm9vdHN0cmFwLWttcy1rZXktaWQnIGFuZCAnLS1ib290c3RyYXAtY3VzdG9tZXIta2V5JyB0b2dldGhlci4gU3BlY2lmeSBvbmUgb3IgdGhlIG90aGVyXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIElmIHBlb3BsZSByZS1ib290c3RyYXAsIGV4aXN0aW5nIHBhcmFtZXRlciB2YWx1ZXMgYXJlIHJldXNlZCBzbyB0aGF0IHBlb3BsZSBkb24ndCBhY2NpZGVudGFsbHkgY2hhbmdlIHRoZSBjb25maWd1cmF0aW9uXG4gICAgLy8gb24gdGhlaXIgYm9vdHN0cmFwIHN0YWNrICh0aGlzIGhhcHBlbnMgYXV0b21hdGljYWxseSBpbiBkZXBsb3lTdGFjaykuIEhvd2V2ZXIsIHRvIGRvIHByb3BlciB2YWxpZGF0aW9uIG9uIHRoZVxuICAgIC8vIGNvbWJpbmVkIGFyZ3VtZW50cyAoc3VjaCB0aGF0IGlmIC0tdHJ1c3QgaGFzIGJlZW4gZ2l2ZW4sIC0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGlzIG5lY2Vzc2FyeSBhcyB3ZWxsKVxuICAgIC8vIHdlIG5lZWQgdG8gdGFrZSB0aGlzIHBhcmFtZXRlciByZXVzZSBpbnRvIGFjY291bnQuXG4gICAgLy9cbiAgICAvLyBJZGVhbGx5IHdlJ2QgZG8gdGhpcyBpbnNpZGUgdGhlIHRlbXBsYXRlLCBidXQgdGhlIGBSdWxlc2Agc2VjdGlvbiBvZiBDRk5cbiAgICAvLyB0ZW1wbGF0ZXMgZG9lc24ndCBzZWVtIHRvIGJlIGFibGUgdG8gZXhwcmVzcyB0aGUgY29uZGl0aW9ucyB0aGF0IHdlIG5lZWRcbiAgICAvLyAoY2FuJ3QgdXNlIEZuOjpKb2luIG9yIHJlZmVyZW5jZSBDb25kaXRpb25zKSBzbyB3ZSBkbyBpdCBoZXJlIGluc3RlYWQuXG4gICAgY29uc3QgYWxsVHJ1c3RlZCA9IG5ldyBTZXQoW1xuICAgICAgLi4ucGFyYW1zLnRydXN0ZWRBY2NvdW50cyA/PyBbXSxcbiAgICAgIC4uLnBhcmFtcy50cnVzdGVkQWNjb3VudHNGb3JMb29rdXAgPz8gW10sXG4gICAgXSk7XG4gICAgY29uc3QgaW52YWxpZCA9IGludGVyc2VjdGlvbihhbGxUcnVzdGVkLCBuZXcgU2V0KHBhcmFtcy51bnRydXN0ZWRBY2NvdW50cykpO1xuICAgIGlmIChpbnZhbGlkLnNpemUgPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBBY2NvdW50cyBjYW5ub3QgYmUgYm90aCB0cnVzdGVkIGFuZCB1bnRydXN0ZWQuIEZvdW5kOiAke1suLi5pbnZhbGlkXS5qb2luKCcsJyl9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVtb3ZlVW50cnVzdGVkID0gKGFjY291bnRzOiBzdHJpbmdbXSkgPT5cbiAgICAgIGFjY291bnRzLmZpbHRlcihhY2MgPT4gIXBhcmFtcy51bnRydXN0ZWRBY2NvdW50cz8ubWFwKFN0cmluZykuaW5jbHVkZXMoU3RyaW5nKGFjYykpKTtcblxuICAgIGNvbnN0IHRydXN0ZWRBY2NvdW50cyA9IHJlbW92ZVVudHJ1c3RlZChwYXJhbXMudHJ1c3RlZEFjY291bnRzID8/IHNwbGl0Q2ZuQXJyYXkoY3VycmVudC5wYXJhbWV0ZXJzLlRydXN0ZWRBY2NvdW50cykpO1xuICAgIGluZm8oYFRydXN0ZWQgYWNjb3VudHMgZm9yIGRlcGxveW1lbnQ6ICR7dHJ1c3RlZEFjY291bnRzLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHMuam9pbignLCAnKSA6ICcobm9uZSknfWApO1xuXG4gICAgY29uc3QgdHJ1c3RlZEFjY291bnRzRm9yTG9va3VwID0gcmVtb3ZlVW50cnVzdGVkKFxuICAgICAgcGFyYW1zLnRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCA/PyBzcGxpdENmbkFycmF5KGN1cnJlbnQucGFyYW1ldGVycy5UcnVzdGVkQWNjb3VudHNGb3JMb29rdXApLFxuICAgICk7XG4gICAgaW5mbyhcbiAgICAgIGBUcnVzdGVkIGFjY291bnRzIGZvciBsb29rdXA6ICR7dHJ1c3RlZEFjY291bnRzRm9yTG9va3VwLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAuam9pbignLCAnKSA6ICcobm9uZSknfWAsXG4gICAgKTtcblxuICAgIGNvbnN0IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPVxuICAgICAgcGFyYW1zLmNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMgPz8gc3BsaXRDZm5BcnJheShjdXJyZW50LnBhcmFtZXRlcnMuQ2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyk7XG4gICAgaWYgKHRydXN0ZWRBY2NvdW50cy5sZW5ndGggPT09IDAgJiYgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEZvciBzZWxmLXRydXN0IGl0J3Mgb2theSB0byBkZWZhdWx0IHRvIEFkbWluaXN0cmF0b3JBY2Nlc3MsIGFuZCBpdCBpbXByb3ZlcyB0aGUgdXNhYmlsaXR5IG9mIGJvb3RzdHJhcHBpbmcgYSBsb3QuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgbWFrZSB0aGUgaW1wbGljaXRseSBwb2xpY3kgYSBwaHlzaWNhbCBwYXJhbWV0ZXIuIFRoZSB0ZW1wbGF0ZSB3aWxsIGluZmVyIGl0IGluc3RlYWQsXG4gICAgICAvLyB3ZSBzaW1wbHkgZG8gdGhlIFVJIGFkdmVydGlzaW5nIHRoYXQgYmVoYXZpb3IgaGVyZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBESUQgbWFrZSBpdCBhbiBleHBsaWNpdCBwYXJhbWV0ZXIsIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHdoZXRoZXJcbiAgICAgIC8vIHdlIGluZmVycmVkIGl0IG9yIHdoZXRoZXIgdGhlIHVzZXIgdG9sZCB1cywgYW5kIHRoZSBzZXF1ZW5jZTpcbiAgICAgIC8vXG4gICAgICAvLyAkIGNkayBib290c3RyYXBcbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcCAtLXRydXN0IDEyMzRcbiAgICAgIC8vXG4gICAgICAvLyBXb3VsZCBsZWF2ZSBBZG1pbmlzdHJhdG9yQWNjZXNzIHBvbGljaWVzIHdpdGggYSB0cnVzdCByZWxhdGlvbnNoaXAsIHdpdGhvdXQgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgICAgLy8gYXBwcm92aW5nIHRoZSB0cnVzdCBwb2xpY3kuXG4gICAgICBjb25zdCBpbXBsaWNpdFBvbGljeSA9IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6YXdzOnBvbGljeS9BZG1pbmlzdHJhdG9yQWNjZXNzYDtcbiAgICAgIGF3YWl0IHRoaXMubXNnLmlvSG9zdC5ub3RpZnkod2FybihcbiAgICAgICAgdGhpcy5tc2cuYWN0aW9uLFxuICAgICAgICBgVXNpbmcgZGVmYXVsdCBleGVjdXRpb24gcG9saWN5IG9mICcke2ltcGxpY2l0UG9saWN5fScuIFBhc3MgJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzJyB0byBjdXN0b21pemUuYCxcbiAgICAgICkpO1xuICAgIH0gZWxzZSBpZiAoY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgIGBQbGVhc2UgcGFzcyBcXCctLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llc1xcJyB3aGVuIHVzaW5nIFxcJy0tdHJ1c3RcXCcgdG8gc3BlY2lmeSBkZXBsb3ltZW50IHBlcm1pc3Npb25zLiBUcnkgYSBtYW5hZ2VkIHBvbGljeSBvZiB0aGUgZm9ybSBcXCdhcm46JHtwYXJ0aXRpb259OmlhbTo6YXdzOnBvbGljeS88UG9saWN5TmFtZT5cXCcuYCxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbWluZCBwZW9wbGUgd2hhdCB0aGUgY3VycmVudCBzZXR0aW5ncyBhcmVcbiAgICAgIGluZm8oYEV4ZWN1dGlvbiBwb2xpY2llczogJHtjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmpvaW4oJywgJyl9YCk7XG4gICAgfVxuXG4gICAgLy8gKiBJZiBhbiBBUk4gaXMgZ2l2ZW4sIHRoYXQgQVJOLiBPdGhlcndpc2U6XG4gICAgLy8gICAqICctJyBpZiBjdXN0b21lcktleSA9IGZhbHNlXG4gICAgLy8gICAqICcnIGlmIGN1c3RvbWVyS2V5ID0gdHJ1ZVxuICAgIC8vICAgKiBpZiBjdXN0b21lcktleSBpcyBhbHNvIG5vdCBnaXZlblxuICAgIC8vICAgICAqIHVuZGVmaW5lZCBpZiB3ZSBhbHJlYWR5IGhhZCBhIHZhbHVlIGluIHBsYWNlIChyZXVzaW5nIHdoYXQgd2UgaGFkKVxuICAgIC8vICAgICAqICctJyBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGRlcGxveWluZyB0aGlzIHN0YWNrIChvciB1cGdyYWRpbmcgZnJvbSBvbGQgdG8gbmV3IGJvb3RzdHJhcClcbiAgICBjb25zdCBjdXJyZW50S21zS2V5SWQgPSBjdXJyZW50LnBhcmFtZXRlcnMuRmlsZUFzc2V0c0J1Y2tldEttc0tleUlkO1xuICAgIGNvbnN0IGttc0tleUlkID1cbiAgICAgIHBhcmFtcy5rbXNLZXlJZCA/P1xuICAgICAgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSA9PT0gdHJ1ZVxuICAgICAgICA/IENSRUFURV9ORVdfS0VZXG4gICAgICAgIDogcGFyYW1zLmNyZWF0ZUN1c3RvbWVyTWFzdGVyS2V5ID09PSBmYWxzZSB8fCBjdXJyZW50S21zS2V5SWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gVVNFX0FXU19NQU5BR0VEX0tFWVxuICAgICAgICAgIDogdW5kZWZpbmVkKTtcblxuICAgIC8qIEEgcGVybWlzc2lvbnMgYm91bmRhcnkgY2FuIGJlIHByb3ZpZGVkIHZpYTpcbiAgICAgKiAgICAtIHRoZSBmbGFnIGluZGljYXRpbmcgdGhlIGV4YW1wbGUgb25lIHNob3VsZCBiZSB1c2VkXG4gICAgICogICAgLSB0aGUgbmFtZSBpbmRpY2F0aW5nIHRoZSBjdXN0b20gcGVybWlzc2lvbnMgYm91bmRhcnkgdG8gYmUgdXNlZFxuICAgICAqIFJlLWJvb3RzdHJhcHBpbmcgd2lsbCBOT1QgYmUgYmxvY2tlZCBieSBlaXRoZXIgdGlnaHRlbmluZyBvciByZWxheGluZyB0aGUgcGVybWlzc2lvbnMnIGJvdW5kYXJ5LlxuICAgICAqL1xuXG4gICAgLy8gSW5wdXRQZXJtaXNzaW9uc0JvdW5kYXJ5IGlzIGFuIGBhbnlgIHR5cGUgYW5kIGlmIGl0IGlzIG5vdCBkZWZpbmVkIGl0XG4gICAgLy8gYXBwZWFycyBhcyBhbiBlbXB0eSBzdHJpbmcgJycuIFdlIG5lZWQgdG8gZm9yY2UgaXQgdG8gZXZhbHVhdGUgYW4gZW1wdHkgc3RyaW5nXG4gICAgLy8gYXMgdW5kZWZpbmVkXG4gICAgY29uc3QgY3VycmVudFBlcm1pc3Npb25zQm91bmRhcnk6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGN1cnJlbnQucGFyYW1ldGVycy5JbnB1dFBlcm1pc3Npb25zQm91bmRhcnkgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlucHV0UG9saWN5TmFtZSA9IHBhcmFtcy5leGFtcGxlUGVybWlzc2lvbnNCb3VuZGFyeVxuICAgICAgPyBDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZXG4gICAgICA6IHBhcmFtcy5jdXN0b21QZXJtaXNzaW9uc0JvdW5kYXJ5O1xuICAgIGxldCBwb2xpY3lOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKGlucHV0UG9saWN5TmFtZSkge1xuICAgICAgLy8gSWYgdGhlIGV4YW1wbGUgcG9saWN5IGlzIG5vdCBhbHJlYWR5IGluIHBsYWNlLCBpdCBtdXN0IGJlIGNyZWF0ZWQuXG4gICAgICBjb25zdCBzZGsgPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIE1vZGUuRm9yV3JpdGluZykpLnNkaztcbiAgICAgIHBvbGljeU5hbWUgPSBhd2FpdCB0aGlzLmdldFBvbGljeU5hbWUoZW52aXJvbm1lbnQsIHNkaywgaW5wdXRQb2xpY3lOYW1lLCBwYXJ0aXRpb24sIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGVybWlzc2lvbnNCb3VuZGFyeSAhPT0gcG9saWN5TmFtZSkge1xuICAgICAgaWYgKCFjdXJyZW50UGVybWlzc2lvbnNCb3VuZGFyeSkge1xuICAgICAgICBhd2FpdCB0aGlzLm1zZy5pb0hvc3Qubm90aWZ5KHdhcm4oXG4gICAgICAgICAgdGhpcy5tc2cuYWN0aW9uLFxuICAgICAgICAgIGBBZGRpbmcgbmV3IHBlcm1pc3Npb25zIGJvdW5kYXJ5ICR7cG9saWN5TmFtZX1gLFxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSBpZiAoIXBvbGljeU5hbWUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5tc2cuaW9Ib3N0Lm5vdGlmeSh3YXJuKFxuICAgICAgICAgIHRoaXMubXNnLmFjdGlvbixcbiAgICAgICAgICBgUmVtb3ZpbmcgZXhpc3RpbmcgcGVybWlzc2lvbnMgYm91bmRhcnkgJHtjdXJyZW50UGVybWlzc2lvbnNCb3VuZGFyeX1gLFxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHRoaXMubXNnLmlvSG9zdC5ub3RpZnkod2FybihcbiAgICAgICAgICB0aGlzLm1zZy5hY3Rpb24sXG4gICAgICAgICAgYENoYW5naW5nIHBlcm1pc3Npb25zIGJvdW5kYXJ5IGZyb20gJHtjdXJyZW50UGVybWlzc2lvbnNCb3VuZGFyeX0gdG8gJHtwb2xpY3lOYW1lfWAsXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50LnVwZGF0ZShcbiAgICAgIGJvb3RzdHJhcFRlbXBsYXRlLFxuICAgICAge1xuICAgICAgICBGaWxlQXNzZXRzQnVja2V0TmFtZTogcGFyYW1zLmJ1Y2tldE5hbWUsXG4gICAgICAgIEZpbGVBc3NldHNCdWNrZXRLbXNLZXlJZDoga21zS2V5SWQsXG4gICAgICAgIC8vIEVtcHR5IGFycmF5IGJlY29tZXMgZW1wdHkgc3RyaW5nXG4gICAgICAgIFRydXN0ZWRBY2NvdW50czogdHJ1c3RlZEFjY291bnRzLmpvaW4oJywnKSxcbiAgICAgICAgVHJ1c3RlZEFjY291bnRzRm9yTG9va3VwOiB0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAuam9pbignLCcpLFxuICAgICAgICBDbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzOiBjbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzLmpvaW4oJywnKSxcbiAgICAgICAgUXVhbGlmaWVyOiBwYXJhbXMucXVhbGlmaWVyLFxuICAgICAgICBQdWJsaWNBY2Nlc3NCbG9ja0NvbmZpZ3VyYXRpb246XG4gICAgICAgICAgcGFyYW1zLnB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbiB8fCBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gJ3RydWUnXG4gICAgICAgICAgICA6ICdmYWxzZScsXG4gICAgICAgIElucHV0UGVybWlzc2lvbnNCb3VuZGFyeTogcG9saWN5TmFtZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHRlcm1pbmF0aW9uUHJvdGVjdGlvbjogb3B0aW9ucy50ZXJtaW5hdGlvblByb3RlY3Rpb24gPz8gY3VycmVudC50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFBvbGljeU5hbWUoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNkazogU0RLLFxuICAgIHBlcm1pc3Npb25zQm91bmRhcnk6IHN0cmluZyxcbiAgICBwYXJ0aXRpb246IHN0cmluZyxcbiAgICBwYXJhbXM6IEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzLFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmIChwZXJtaXNzaW9uc0JvdW5kYXJ5ICE9PSBDREtfQk9PVFNUUkFQX1BFUk1JU1NJT05TX0JPVU5EQVJZKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlUG9saWN5TmFtZShwZXJtaXNzaW9uc0JvdW5kYXJ5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGVybWlzc2lvbnNCb3VuZGFyeSk7XG4gICAgfVxuICAgIC8vIGlmIG5vIFF1YWxpZmllciBpcyBzdXBwbGllZCwgcmVzb3J0IHRvIHRoZSBkZWZhdWx0IG9uZVxuICAgIGNvbnN0IGFybiA9IGF3YWl0IHRoaXMuZ2V0RXhhbXBsZVBlcm1pc3Npb25zQm91bmRhcnkoXG4gICAgICBwYXJhbXMucXVhbGlmaWVyID8/ICdobmI2NTlmZHMnLFxuICAgICAgcGFydGl0aW9uLFxuICAgICAgZW52aXJvbm1lbnQuYWNjb3VudCxcbiAgICAgIHNkayxcbiAgICApO1xuICAgIGNvbnN0IHBvbGljeU5hbWUgPSBhcm4uc3BsaXQoJy8nKS5wb3AoKTtcbiAgICBpZiAoIXBvbGljeU5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0NvdWxkIG5vdCByZXRyaWV2ZSB0aGUgZXhhbXBsZSBwZXJtaXNzaW9uIGJvdW5kYXJ5IScpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBvbGljeU5hbWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRFeGFtcGxlUGVybWlzc2lvbnNCb3VuZGFyeShcbiAgICBxdWFsaWZpZXI6IHN0cmluZyxcbiAgICBwYXJ0aXRpb246IHN0cmluZyxcbiAgICBhY2NvdW50OiBzdHJpbmcsXG4gICAgc2RrOiBTREssXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgaWFtID0gc2RrLmlhbSgpO1xuXG4gICAgbGV0IHBvbGljeU5hbWUgPSBgY2RrLSR7cXVhbGlmaWVyfS1wZXJtaXNzaW9ucy1ib3VuZGFyeWA7XG4gICAgY29uc3QgYXJuID0gYGFybjoke3BhcnRpdGlvbn06aWFtOjoke2FjY291bnR9OnBvbGljeS8ke3BvbGljeU5hbWV9YDtcblxuICAgIHRyeSB7XG4gICAgICBsZXQgZ2V0UG9saWN5UmVzcCA9IGF3YWl0IGlhbS5nZXRQb2xpY3koeyBQb2xpY3lBcm46IGFybiB9KTtcbiAgICAgIGlmIChnZXRQb2xpY3lSZXNwLlBvbGljeSkge1xuICAgICAgICByZXR1cm4gYXJuO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0lBTS9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9HZXRQb2xpY3kuaHRtbCNBUElfR2V0UG9saWN5X0Vycm9yc1xuICAgICAgaWYgKGUubmFtZSA9PT0gJ05vU3VjaEVudGl0eScpIHtcbiAgICAgICAgLy8gbm9vcCwgcHJvY2VlZCB3aXRoIGNyZWF0aW5nIHRoZSBwb2xpY3lcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcG9saWN5RG9jID0ge1xuICAgICAgVmVyc2lvbjogJzIwMTItMTAtMTcnLFxuICAgICAgU3RhdGVtZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICBBY3Rpb246IFsnKiddLFxuICAgICAgICAgIFJlc291cmNlOiAnKicsXG4gICAgICAgICAgRWZmZWN0OiAnQWxsb3cnLFxuICAgICAgICAgIFNpZDogJ0V4cGxpY2l0QWxsb3dBbGwnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgQ29uZGl0aW9uOiB7XG4gICAgICAgICAgICBTdHJpbmdFcXVhbHM6IHtcbiAgICAgICAgICAgICAgJ2lhbTpQZXJtaXNzaW9uc0JvdW5kYXJ5JzogYGFybjoke3BhcnRpdGlvbn06aWFtOjoke2FjY291bnR9OnBvbGljeS9jZGstJHtxdWFsaWZpZXJ9LXBlcm1pc3Npb25zLWJvdW5kYXJ5YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBBY3Rpb246IFtcbiAgICAgICAgICAgICdpYW06Q3JlYXRlVXNlcicsXG4gICAgICAgICAgICAnaWFtOkNyZWF0ZVJvbGUnLFxuICAgICAgICAgICAgJ2lhbTpQdXRSb2xlUGVybWlzc2lvbnNCb3VuZGFyeScsXG4gICAgICAgICAgICAnaWFtOlB1dFVzZXJQZXJtaXNzaW9uc0JvdW5kYXJ5JyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFJlc291cmNlOiAnKicsXG4gICAgICAgICAgRWZmZWN0OiAnQWxsb3cnLFxuICAgICAgICAgIFNpZDogJ0RlbnlBY2Nlc3NJZlJlcXVpcmVkUGVybUJvdW5kYXJ5SXNOb3RCZWluZ0FwcGxpZWQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgQWN0aW9uOiBbXG4gICAgICAgICAgICAnaWFtOkNyZWF0ZVBvbGljeVZlcnNpb24nLFxuICAgICAgICAgICAgJ2lhbTpEZWxldGVQb2xpY3knLFxuICAgICAgICAgICAgJ2lhbTpEZWxldGVQb2xpY3lWZXJzaW9uJyxcbiAgICAgICAgICAgICdpYW06U2V0RGVmYXVsdFBvbGljeVZlcnNpb24nLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgUmVzb3VyY2U6IGBhcm46JHtwYXJ0aXRpb259OmlhbTo6JHthY2NvdW50fTpwb2xpY3kvY2RrLSR7cXVhbGlmaWVyfS1wZXJtaXNzaW9ucy1ib3VuZGFyeWAsXG4gICAgICAgICAgRWZmZWN0OiAnRGVueScsXG4gICAgICAgICAgU2lkOiAnRGVueVBlcm1Cb3VuZGFyeUlBTVBvbGljeUFsdGVyYXRpb24nLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgQWN0aW9uOiBbJ2lhbTpEZWxldGVVc2VyUGVybWlzc2lvbnNCb3VuZGFyeScsICdpYW06RGVsZXRlUm9sZVBlcm1pc3Npb25zQm91bmRhcnknXSxcbiAgICAgICAgICBSZXNvdXJjZTogJyonLFxuICAgICAgICAgIEVmZmVjdDogJ0RlbnknLFxuICAgICAgICAgIFNpZDogJ0RlbnlSZW1vdmFsT2ZQZXJtQm91bmRhcnlGcm9tQW55VXNlck9yUm9sZScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIFBvbGljeU5hbWU6IHBvbGljeU5hbWUsXG4gICAgICBQb2xpY3lEb2N1bWVudDogSlNPTi5zdHJpbmdpZnkocG9saWN5RG9jKSxcbiAgICB9O1xuICAgIGNvbnN0IGNyZWF0ZVBvbGljeVJlc3BvbnNlID0gYXdhaXQgaWFtLmNyZWF0ZVBvbGljeShyZXF1ZXN0KTtcbiAgICBpZiAoY3JlYXRlUG9saWN5UmVzcG9uc2UuUG9saWN5Py5Bcm4pIHtcbiAgICAgIHJldHVybiBjcmVhdGVQb2xpY3lSZXNwb25zZS5Qb2xpY3kuQXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDb3VsZCBub3QgcmV0cmlldmUgdGhlIGV4YW1wbGUgcGVybWlzc2lvbiBib3VuZGFyeSAke2Fybn0hYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB2YWxpZGF0ZVBvbGljeU5hbWUocGVybWlzc2lvbnNCb3VuZGFyeTogc3RyaW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0lBTS9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9DcmVhdGVQb2xpY3kuaHRtbFxuICAgIC8vIEFkZGVkIHN1cHBvcnQgZm9yIHBvbGljeSBuYW1lcyB3aXRoIGEgcGF0aFxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzI2MzIwXG4gICAgY29uc3QgcmVnZXhwOiBSZWdFeHAgPSAvW1xcdytcXC89LC5ALV0rLztcbiAgICBjb25zdCBtYXRjaGVzID0gcmVnZXhwLmV4ZWMocGVybWlzc2lvbnNCb3VuZGFyeSk7XG4gICAgaWYgKCEobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gMSAmJiBtYXRjaGVzWzBdID09PSBwZXJtaXNzaW9uc0JvdW5kYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGhlIHBlcm1pc3Npb25zIGJvdW5kYXJ5IG5hbWUgJHtwZXJtaXNzaW9uc0JvdW5kYXJ5fSBkb2VzIG5vdCBtYXRjaCB0aGUgSUFNIGNvbnZlbnRpb25zLmApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3VzdG9tQm9vdHN0cmFwKFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsXG4gICAgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8U3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgLy8gTG9vayBhdCB0aGUgdGVtcGxhdGUsIGRlY2lkZSB3aGV0aGVyIGl0J3MgbW9zdCBsaWtlbHkgYSBsZWdhY3kgb3IgbW9kZXJuIGJvb3RzdHJhcFxuICAgIC8vIHRlbXBsYXRlLCBhbmQgdXNlIHRoZSByaWdodCBib290c3RyYXBwZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgdmVyc2lvbiA9IGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUoYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKSk7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxlZ2FjeUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlcm5Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRUZW1wbGF0ZShwYXJhbXM6IEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHN3aXRjaCAodGhpcy5zb3VyY2Uuc291cmNlKSB7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHRoaXMuc291cmNlLnRlbXBsYXRlRmlsZSk7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIGxvYWRTdHJ1Y3R1cmVkRmlsZShwYXRoLmpvaW4oYnVuZGxlZFBhY2thZ2VSb290RGlyKF9fZGlybmFtZSksICdsaWInLCAnYXBpJywgJ2Jvb3RzdHJhcCcsICdib290c3RyYXAtdGVtcGxhdGUueWFtbCcpKTtcbiAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgIHJldHVybiBsZWdhY3lCb290c3RyYXBUZW1wbGF0ZShwYXJhbXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hZ2ljIHBhcmFtZXRlciB2YWx1ZSB0aGF0IHdpbGwgY2F1c2UgdGhlIGJvb3RzdHJhcC10ZW1wbGF0ZS55bWwgdG8gTk9UIGNyZWF0ZSBhIENNSyBidXQgdXNlIHRoZSBkZWZhdWx0IGtleVxuICovXG5jb25zdCBVU0VfQVdTX01BTkFHRURfS0VZID0gJ0FXU19NQU5BR0VEX0tFWSc7XG5cbi8qKlxuICogTWFnaWMgcGFyYW1ldGVyIHZhbHVlIHRoYXQgd2lsbCBjYXVzZSB0aGUgYm9vdHN0cmFwLXRlbXBsYXRlLnltbCB0byBjcmVhdGUgYSBDTUtcbiAqL1xuY29uc3QgQ1JFQVRFX05FV19LRVkgPSAnJztcbi8qKlxuICogUGFyYW1ldGVyIHZhbHVlIGluZGljYXRpbmcgdGhlIHVzZSBvZiB0aGUgZGVmYXVsdCwgQ0RLIHByb3ZpZGVkIHBlcm1pc3Npb25zIGJvdW5kYXJ5IGZvciBib290c3RyYXAtdGVtcGxhdGUueW1sXG4gKi9cbmNvbnN0IENES19CT09UU1RSQVBfUEVSTUlTU0lPTlNfQk9VTkRBUlkgPSAnQ0RLX0JPT1RTVFJBUF9QRVJNSVNTSU9OU19CT1VOREFSWSc7XG5cbi8qKlxuICogU3BsaXQgYW4gYXJyYXktbGlrZSBDbG91ZEZvcm1hdGlvbiBwYXJhbWV0ZXIgb24gLFxuICpcbiAqIEFuIGVtcHR5IHN0cmluZyBpcyB0aGUgZW1wdHkgYXJyYXkgKGluc3RlYWQgb2YgYFsnJ11gKS5cbiAqL1xuZnVuY3Rpb24gc3BsaXRDZm5BcnJheSh4czogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nW10ge1xuICBpZiAoeHMgPT09ICcnIHx8IHhzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHhzLnNwbGl0KCcsJyk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbjxBPih4czogU2V0PEE+LCB5czogU2V0PEE+KTogU2V0PEE+IHtcbiAgcmV0dXJuIG5ldyBTZXQ8QT4oQXJyYXkuZnJvbSh4cykuZmlsdGVyKHggPT4geXMuaGFzKHgpKSk7XG59XG4iXX0=