"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackCollection = exports.CloudAssembly = exports.ExtendedStackSelection = exports.DefaultSelection = void 0;
exports.sanitizePatterns = sanitizePatterns;
const cx_api_1 = require("@aws-cdk/cx-api");
const chalk = require("chalk");
const minimatch_1 = require("minimatch");
const semver = require("semver");
const logging_1 = require("../../logging");
const error_1 = require("../../toolkit/error");
const util_1 = require("../../util");
var DefaultSelection;
(function (DefaultSelection) {
    /**
     * Returns an empty selection in case there are no selectors.
     */
    DefaultSelection["None"] = "none";
    /**
     * If the app includes a single stack, returns it. Otherwise throws an exception.
     * This behavior is used by "deploy".
     */
    DefaultSelection["OnlySingle"] = "single";
    /**
     * Returns all stacks in the main (top level) assembly only.
     */
    DefaultSelection["MainAssembly"] = "main";
    /**
     * If no selectors are provided, returns all stacks in the app,
     * including stacks inside nested assemblies.
     */
    DefaultSelection["AllStacks"] = "all";
})(DefaultSelection || (exports.DefaultSelection = DefaultSelection = {}));
/**
 * When selecting stacks, what other stacks to include because of dependencies
 */
var ExtendedStackSelection;
(function (ExtendedStackSelection) {
    /**
     * Don't select any extra stacks
     */
    ExtendedStackSelection[ExtendedStackSelection["None"] = 0] = "None";
    /**
     * Include stacks that this stack depends on
     */
    ExtendedStackSelection[ExtendedStackSelection["Upstream"] = 1] = "Upstream";
    /**
     * Include stacks that depend on this stack
     */
    ExtendedStackSelection[ExtendedStackSelection["Downstream"] = 2] = "Downstream";
})(ExtendedStackSelection || (exports.ExtendedStackSelection = ExtendedStackSelection = {}));
/**
 * A single Cloud Assembly and the operations we do on it to deploy the artifacts inside
 */
class CloudAssembly {
    constructor(assembly) {
        this.assembly = assembly;
        this.directory = assembly.directory;
    }
    async selectStacks(selector, options) {
        var _a;
        const asm = this.assembly;
        const topLevelStacks = asm.stacks;
        const stacks = semver.major(asm.version) < 10 ? asm.stacks : asm.stacksRecursively;
        const allTopLevel = (_a = selector.allTopLevel) !== null && _a !== void 0 ? _a : false;
        const patterns = sanitizePatterns(selector.patterns);
        if (stacks.length === 0) {
            if (options.ignoreNoStacks) {
                return new StackCollection(this, []);
            }
            throw new error_1.ToolkitError('This app contains no stacks');
        }
        if (allTopLevel) {
            return this.selectTopLevelStacks(stacks, topLevelStacks, options.extend);
        }
        else if (patterns.length > 0) {
            return this.selectMatchingStacks(stacks, patterns, options.extend);
        }
        else {
            return this.selectDefaultStacks(stacks, topLevelStacks, options.defaultBehavior);
        }
    }
    selectTopLevelStacks(stacks, topLevelStacks, extend = ExtendedStackSelection.None) {
        if (topLevelStacks.length > 0) {
            return this.extendStacks(topLevelStacks, stacks, extend);
        }
        else {
            throw new error_1.ToolkitError('No stack found in the main cloud assembly. Use "list" to print manifest');
        }
    }
    selectMatchingStacks(stacks, patterns, extend = ExtendedStackSelection.None) {
        const matchingPattern = (pattern) => (stack) => (0, minimatch_1.minimatch)(stack.hierarchicalId, pattern);
        const matchedStacks = (0, util_1.flatten)(patterns.map(pattern => stacks.filter(matchingPattern(pattern))));
        return this.extendStacks(matchedStacks, stacks, extend);
    }
    selectDefaultStacks(stacks, topLevelStacks, defaultSelection) {
        switch (defaultSelection) {
            case DefaultSelection.MainAssembly:
                return new StackCollection(this, topLevelStacks);
            case DefaultSelection.AllStacks:
                return new StackCollection(this, stacks);
            case DefaultSelection.None:
                return new StackCollection(this, []);
            case DefaultSelection.OnlySingle:
                if (topLevelStacks.length === 1) {
                    return new StackCollection(this, topLevelStacks);
                }
                else {
                    throw new error_1.ToolkitError('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported) or specify `--all`\n' +
                        `Stacks: ${stacks.map(x => x.hierarchicalId).join(' Â· ')}`);
                }
            default:
                throw new error_1.ToolkitError(`invalid default behavior: ${defaultSelection}`);
        }
    }
    extendStacks(matched, all, extend = ExtendedStackSelection.None) {
        const allStacks = new Map();
        for (const stack of all) {
            allStacks.set(stack.hierarchicalId, stack);
        }
        const index = indexByHierarchicalId(matched);
        switch (extend) {
            case ExtendedStackSelection.Downstream:
                includeDownstreamStacks(index, allStacks);
                break;
            case ExtendedStackSelection.Upstream:
                includeUpstreamStacks(index, allStacks);
                break;
        }
        // Filter original array because it is in the right order
        const selectedList = all.filter(s => index.has(s.hierarchicalId));
        return new StackCollection(this, selectedList);
    }
    /**
     * Select a single stack by its ID
     */
    stackById(stackId) {
        return new StackCollection(this, [this.assembly.getStackArtifact(stackId)]);
    }
}
exports.CloudAssembly = CloudAssembly;
/**
 * A collection of stacks and related artifacts
 *
 * In practice, not all artifacts in the CloudAssembly are created equal;
 * stacks can be selected independently, but other artifacts such as asset
 * bundles cannot.
 */
class StackCollection {
    constructor(assembly, stackArtifacts) {
        this.assembly = assembly;
        this.stackArtifacts = stackArtifacts;
    }
    get stackCount() {
        return this.stackArtifacts.length;
    }
    get firstStack() {
        if (this.stackCount < 1) {
            throw new error_1.ToolkitError('StackCollection contains no stack artifacts (trying to access the first one)');
        }
        return this.stackArtifacts[0];
    }
    get stackIds() {
        return this.stackArtifacts.map(s => s.id);
    }
    get hierarchicalIds() {
        return this.stackArtifacts.map(s => s.hierarchicalId);
    }
    withDependencies() {
        var _a, _b;
        const allData = [];
        for (const stack of this.stackArtifacts) {
            const data = {
                id: (_a = stack.displayName) !== null && _a !== void 0 ? _a : stack.id,
                name: stack.stackName,
                environment: stack.environment,
                dependencies: [],
            };
            for (const dependencyId of stack.dependencies.map(x => x.id)) {
                if (dependencyId.includes('.assets')) {
                    continue;
                }
                const depStack = this.assembly.stackById(dependencyId);
                if (depStack.firstStack.dependencies.filter((dep) => !(dep.id).includes('.assets')).length > 0) {
                    for (const stackDetail of depStack.withDependencies()) {
                        data.dependencies.push({
                            id: stackDetail.id,
                            dependencies: stackDetail.dependencies,
                        });
                    }
                }
                else {
                    data.dependencies.push({
                        id: (_b = depStack.firstStack.displayName) !== null && _b !== void 0 ? _b : depStack.firstStack.id,
                        dependencies: [],
                    });
                }
            }
            allData.push(data);
        }
        return allData;
    }
    reversed() {
        const arts = [...this.stackArtifacts];
        arts.reverse();
        return new StackCollection(this.assembly, arts);
    }
    filter(predicate) {
        return new StackCollection(this.assembly, this.stackArtifacts.filter(predicate));
    }
    concat(...others) {
        return new StackCollection(this.assembly, this.stackArtifacts.concat(...others.map(o => o.stackArtifacts)));
    }
    /**
     * Extracts 'aws:cdk:warning|info|error' metadata entries from the stack synthesis
     */
    async validateMetadata(failAt = 'error', logger = async () => {
    }) {
        let warnings = false;
        let errors = false;
        for (const stack of this.stackArtifacts) {
            for (const message of stack.messages) {
                switch (message.level) {
                    case cx_api_1.SynthesisMessageLevel.WARNING:
                        warnings = true;
                        await logger('warn', message);
                        break;
                    case cx_api_1.SynthesisMessageLevel.ERROR:
                        errors = true;
                        await logger('error', message);
                        break;
                    case cx_api_1.SynthesisMessageLevel.INFO:
                        await logger('info', message);
                        break;
                }
            }
        }
        if (errors && failAt != 'none') {
            throw new error_1.AssemblyError('Found errors');
        }
        if (warnings && failAt === 'warn') {
            throw new error_1.AssemblyError('Found warnings (--strict mode)');
        }
    }
}
exports.StackCollection = StackCollection;
function indexByHierarchicalId(stacks) {
    const result = new Map();
    for (const stack of stacks) {
        result.set(stack.hierarchicalId, stack);
    }
    return result;
}
/**
 * Calculate the transitive closure of stack dependents.
 *
 * Modifies `selectedStacks` in-place.
 */
function includeDownstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress;
    do {
        madeProgress = false;
        for (const [id, stack] of allStacks) {
            // Select this stack if it's not selected yet AND it depends on a stack that's in the selected set
            if (!selectedStacks.has(id) && (stack.dependencies || []).some(dep => selectedStacks.has(dep.id))) {
                selectedStacks.set(id, stack);
                added.push(id);
                madeProgress = true;
            }
        }
    } while (madeProgress);
    if (added.length > 0) {
        (0, logging_1.info)('Including depending stacks: %s', chalk.bold(added.join(', ')));
    }
}
/**
 * Calculate the transitive closure of stack dependencies.
 *
 * Modifies `selectedStacks` in-place.
 */
function includeUpstreamStacks(selectedStacks, allStacks) {
    const added = new Array();
    let madeProgress = true;
    while (madeProgress) {
        madeProgress = false;
        for (const stack of selectedStacks.values()) {
            // Select an additional stack if it's not selected yet and a dependency of a selected stack (and exists, obviously)
            for (const dependencyId of stack.dependencies.map(x => { var _a; return (_a = x.manifest.displayName) !== null && _a !== void 0 ? _a : x.id; })) {
                if (!selectedStacks.has(dependencyId) && allStacks.has(dependencyId)) {
                    added.push(dependencyId);
                    selectedStacks.set(dependencyId, allStacks.get(dependencyId));
                    madeProgress = true;
                }
            }
        }
    }
    if (added.length > 0) {
        (0, logging_1.info)('Including dependency stacks: %s', chalk.bold(added.join(', ')));
    }
}
function sanitizePatterns(patterns) {
    let sanitized = patterns.filter(s => s != null); // filter null/undefined
    sanitized = [...new Set(sanitized)]; // make them unique
    return sanitized;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWQtYXNzZW1ibHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZC1hc3NlbWJseS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUF1YkEsNENBSUM7QUExYkQsNENBQXdEO0FBQ3hELCtCQUErQjtBQUMvQix5Q0FBc0M7QUFDdEMsaUNBQWlDO0FBQ2pDLDJDQUFxQztBQUNyQywrQ0FBa0U7QUFDbEUscUNBQXFDO0FBRXJDLElBQVksZ0JBc0JYO0FBdEJELFdBQVksZ0JBQWdCO0lBQzFCOztPQUVHO0lBQ0gsaUNBQWEsQ0FBQTtJQUViOzs7T0FHRztJQUNILHlDQUFxQixDQUFBO0lBRXJCOztPQUVHO0lBQ0gseUNBQXFCLENBQUE7SUFFckI7OztPQUdHO0lBQ0gscUNBQWlCLENBQUE7QUFDbkIsQ0FBQyxFQXRCVyxnQkFBZ0IsZ0NBQWhCLGdCQUFnQixRQXNCM0I7QUFzQkQ7O0dBRUc7QUFDSCxJQUFZLHNCQWVYO0FBZkQsV0FBWSxzQkFBc0I7SUFDaEM7O09BRUc7SUFDSCxtRUFBSSxDQUFBO0lBRUo7O09BRUc7SUFDSCwyRUFBUSxDQUFBO0lBRVI7O09BRUc7SUFDSCwrRUFBVSxDQUFBO0FBQ1osQ0FBQyxFQWZXLHNCQUFzQixzQ0FBdEIsc0JBQXNCLFFBZWpDO0FBa0JEOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBTXhCLFlBQTRCLFFBQTZCO1FBQTdCLGFBQVEsR0FBUixRQUFRLENBQXFCO1FBQ3ZELElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztJQUN0QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxRQUF1QixFQUFFLE9BQTRCOztRQUM3RSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzFCLE1BQU0sY0FBYyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7UUFDbEMsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUM7UUFDbkYsTUFBTSxXQUFXLEdBQUcsTUFBQSxRQUFRLENBQUMsV0FBVyxtQ0FBSSxLQUFLLENBQUM7UUFDbEQsTUFBTSxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXJELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN4QixJQUFJLE9BQU8sQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDM0IsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkMsQ0FBQztZQUNELE1BQU0sSUFBSSxvQkFBWSxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDeEQsQ0FBQztRQUVELElBQUksV0FBVyxFQUFFLENBQUM7WUFDaEIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0UsQ0FBQzthQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUMvQixPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyRSxDQUFDO2FBQU0sQ0FBQztZQUNOLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ25GLENBQUM7SUFDSCxDQUFDO0lBRU8sb0JBQW9CLENBQzFCLE1BQTJDLEVBQzNDLGNBQW1ELEVBQ25ELFNBQWlDLHNCQUFzQixDQUFDLElBQUk7UUFFNUQsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzNELENBQUM7YUFBTSxDQUFDO1lBQ04sTUFBTSxJQUFJLG9CQUFZLENBQUMseUVBQXlFLENBQUMsQ0FBQztRQUNwRyxDQUFDO0lBQ0gsQ0FBQztJQUVTLG9CQUFvQixDQUM1QixNQUEyQyxFQUMzQyxRQUFrQixFQUNsQixTQUFpQyxzQkFBc0IsQ0FBQyxJQUFJO1FBRTVELE1BQU0sZUFBZSxHQUFHLENBQUMsT0FBZSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEtBQXdDLEVBQUUsRUFBRSxDQUFDLElBQUEscUJBQVMsRUFBQyxLQUFLLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3BJLE1BQU0sYUFBYSxHQUFHLElBQUEsY0FBTyxFQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVoRyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRU8sbUJBQW1CLENBQ3pCLE1BQTJDLEVBQzNDLGNBQW1ELEVBQ25ELGdCQUFrQztRQUVsQyxRQUFRLGdCQUFnQixFQUFFLENBQUM7WUFDekIsS0FBSyxnQkFBZ0IsQ0FBQyxZQUFZO2dCQUNoQyxPQUFPLElBQUksZUFBZSxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsQ0FBQztZQUNuRCxLQUFLLGdCQUFnQixDQUFDLFNBQVM7Z0JBQzdCLE9BQU8sSUFBSSxlQUFlLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzNDLEtBQUssZ0JBQWdCLENBQUMsSUFBSTtnQkFDeEIsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkMsS0FBSyxnQkFBZ0IsQ0FBQyxVQUFVO2dCQUM5QixJQUFJLGNBQWMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7b0JBQ2hDLE9BQU8sSUFBSSxlQUFlLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDO2dCQUNuRCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sTUFBTSxJQUFJLG9CQUFZLENBQUMsOEhBQThIO3dCQUNySixXQUFXLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDOUQsQ0FBQztZQUNIO2dCQUNFLE1BQU0sSUFBSSxvQkFBWSxDQUFDLDZCQUE2QixnQkFBZ0IsRUFBRSxDQUFDLENBQUM7UUFDNUUsQ0FBQztJQUNILENBQUM7SUFFUyxZQUFZLENBQ3BCLE9BQTRDLEVBQzVDLEdBQXdDLEVBQ3hDLFNBQWlDLHNCQUFzQixDQUFDLElBQUk7UUFFNUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLEVBQTZDLENBQUM7UUFDdkUsS0FBSyxNQUFNLEtBQUssSUFBSSxHQUFHLEVBQUUsQ0FBQztZQUN4QixTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDN0MsQ0FBQztRQUVELE1BQU0sS0FBSyxHQUFHLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTdDLFFBQVEsTUFBTSxFQUFFLENBQUM7WUFDZixLQUFLLHNCQUFzQixDQUFDLFVBQVU7Z0JBQ3BDLHVCQUF1QixDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDMUMsTUFBTTtZQUNSLEtBQUssc0JBQXNCLENBQUMsUUFBUTtnQkFDbEMscUJBQXFCLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2dCQUN4QyxNQUFNO1FBQ1YsQ0FBQztRQUVELHlEQUF5RDtRQUN6RCxNQUFNLFlBQVksR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUVsRSxPQUFPLElBQUksZUFBZSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxTQUFTLENBQUMsT0FBZTtRQUM5QixPQUFPLElBQUksZUFBZSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlFLENBQUM7Q0FDRjtBQWpIRCxzQ0FpSEM7QUFvQkQ7Ozs7OztHQU1HO0FBQ0gsTUFBYSxlQUFlO0lBQzFCLFlBQTRCLFFBQXVCLEVBQWtCLGNBQW1EO1FBQTVGLGFBQVEsR0FBUixRQUFRLENBQWU7UUFBa0IsbUJBQWMsR0FBZCxjQUFjLENBQXFDO0lBQ3hILENBQUM7SUFFRCxJQUFXLFVBQVU7UUFDbkIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQztJQUNwQyxDQUFDO0lBRUQsSUFBVyxVQUFVO1FBQ25CLElBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN4QixNQUFNLElBQUksb0JBQVksQ0FBQyw4RUFBOEUsQ0FBQyxDQUFDO1FBQ3pHLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVELElBQVcsUUFBUTtRQUNqQixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRCxJQUFXLGVBQWU7UUFDeEIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRU0sZ0JBQWdCOztRQUNyQixNQUFNLE9BQU8sR0FBbUIsRUFBRSxDQUFDO1FBRW5DLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3hDLE1BQU0sSUFBSSxHQUFpQjtnQkFDekIsRUFBRSxFQUFFLE1BQUEsS0FBSyxDQUFDLFdBQVcsbUNBQUksS0FBSyxDQUFDLEVBQUU7Z0JBQ2pDLElBQUksRUFBRSxLQUFLLENBQUMsU0FBUztnQkFDckIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXO2dCQUM5QixZQUFZLEVBQUUsRUFBRTthQUNqQixDQUFDO1lBRUYsS0FBSyxNQUFNLFlBQVksSUFBSSxLQUFLLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUM3RCxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztvQkFDckMsU0FBUztnQkFDWCxDQUFDO2dCQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUV2RCxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7b0JBQy9GLEtBQUssTUFBTSxXQUFXLElBQUksUUFBUSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQzt3QkFDdEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7NEJBQ3JCLEVBQUUsRUFBRSxXQUFXLENBQUMsRUFBRTs0QkFDbEIsWUFBWSxFQUFFLFdBQVcsQ0FBQyxZQUFZO3lCQUN2QyxDQUFDLENBQUM7b0JBQ0wsQ0FBQztnQkFDSCxDQUFDO3FCQUFNLENBQUM7b0JBQ04sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7d0JBQ3JCLEVBQUUsRUFBRSxNQUFBLFFBQVEsQ0FBQyxVQUFVLENBQUMsV0FBVyxtQ0FBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7d0JBQzdELFlBQVksRUFBRSxFQUFFO3FCQUNqQixDQUFDLENBQUM7Z0JBQ0wsQ0FBQztZQUNILENBQUM7WUFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLENBQUM7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRU0sUUFBUTtRQUNiLE1BQU0sSUFBSSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFTSxNQUFNLENBQUMsU0FBOEQ7UUFDMUUsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDbkYsQ0FBQztJQUVNLE1BQU0sQ0FBQyxHQUFHLE1BQXlCO1FBQ3hDLE9BQU8sSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlHLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FDM0IsU0FBb0MsT0FBTyxFQUMzQyxTQUEyRixLQUFLLElBQUksRUFBRTtJQUN0RyxDQUFDO1FBRUQsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQztRQUVuQixLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN4QyxLQUFLLE1BQU0sT0FBTyxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDckMsUUFBUSxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7b0JBQ3RCLEtBQUssOEJBQXFCLENBQUMsT0FBTzt3QkFDaEMsUUFBUSxHQUFHLElBQUksQ0FBQzt3QkFDaEIsTUFBTSxNQUFNLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO3dCQUM5QixNQUFNO29CQUNSLEtBQUssOEJBQXFCLENBQUMsS0FBSzt3QkFDOUIsTUFBTSxHQUFHLElBQUksQ0FBQzt3QkFDZCxNQUFNLE1BQU0sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7d0JBQy9CLE1BQU07b0JBQ1IsS0FBSyw4QkFBcUIsQ0FBQyxJQUFJO3dCQUM3QixNQUFNLE1BQU0sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7d0JBQzlCLE1BQU07Z0JBQ1YsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sRUFBRSxDQUFDO1lBQy9CLE1BQU0sSUFBSSxxQkFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzFDLENBQUM7UUFFRCxJQUFJLFFBQVEsSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDbEMsTUFBTSxJQUFJLHFCQUFhLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUM1RCxDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBakhELDBDQWlIQztBQXlCRCxTQUFTLHFCQUFxQixDQUFDLE1BQTJDO0lBQ3hFLE1BQU0sTUFBTSxHQUFHLElBQUksR0FBRyxFQUE2QyxDQUFDO0lBRXBFLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLENBQUM7UUFDM0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsdUJBQXVCLENBQzlCLGNBQThELEVBQzlELFNBQXlEO0lBQ3pELE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7SUFFbEMsSUFBSSxZQUFZLENBQUM7SUFDakIsR0FBRyxDQUFDO1FBQ0YsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUVyQixLQUFLLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLElBQUksU0FBUyxFQUFFLENBQUM7WUFDcEMsa0dBQWtHO1lBQ2xHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUM7Z0JBQ2xHLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUM5QixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUNmLFlBQVksR0FBRyxJQUFJLENBQUM7WUFDdEIsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDLFFBQVEsWUFBWSxFQUFFO0lBRXZCLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUNyQixJQUFBLGNBQUksRUFBQyxnQ0FBZ0MsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7QUFDSCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMscUJBQXFCLENBQzVCLGNBQThELEVBQzlELFNBQXlEO0lBQ3pELE1BQU0sS0FBSyxHQUFHLElBQUksS0FBSyxFQUFVLENBQUM7SUFDbEMsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDO0lBQ3hCLE9BQU8sWUFBWSxFQUFFLENBQUM7UUFDcEIsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUVyQixLQUFLLE1BQU0sS0FBSyxJQUFJLGNBQWMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDO1lBQzVDLG1IQUFtSDtZQUNuSCxLQUFLLE1BQU0sWUFBWSxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQUMsT0FBQSxNQUFBLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBVyxtQ0FBSSxDQUFDLENBQUMsRUFBRSxDQUFBLEVBQUEsQ0FBQyxFQUFFLENBQUM7Z0JBQ3ZGLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztvQkFDckUsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztvQkFDekIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUUsQ0FBQyxDQUFDO29CQUMvRCxZQUFZLEdBQUcsSUFBSSxDQUFDO2dCQUN0QixDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1FBQ3JCLElBQUEsY0FBSSxFQUFDLGlDQUFpQyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFnQixnQkFBZ0IsQ0FBQyxRQUFrQjtJQUNqRCxJQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsd0JBQXdCO0lBQ3pFLFNBQVMsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQjtJQUN4RCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgU3ludGhlc2lzTWVzc2FnZUxldmVsIH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IG1pbmltYXRjaCB9IGZyb20gJ21pbmltYXRjaCc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB7IGluZm8gfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IEFzc2VtYmx5RXJyb3IsIFRvb2xraXRFcnJvciB9IGZyb20gJy4uLy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5leHBvcnQgZW51bSBEZWZhdWx0U2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW1wdHkgc2VsZWN0aW9uIGluIGNhc2UgdGhlcmUgYXJlIG5vIHNlbGVjdG9ycy5cbiAgICovXG4gIE5vbmUgPSAnbm9uZScsXG5cbiAgLyoqXG4gICAqIElmIHRoZSBhcHAgaW5jbHVkZXMgYSBzaW5nbGUgc3RhY2ssIHJldHVybnMgaXQuIE90aGVyd2lzZSB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgKiBUaGlzIGJlaGF2aW9yIGlzIHVzZWQgYnkgXCJkZXBsb3lcIi5cbiAgICovXG4gIE9ubHlTaW5nbGUgPSAnc2luZ2xlJyxcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgc3RhY2tzIGluIHRoZSBtYWluICh0b3AgbGV2ZWwpIGFzc2VtYmx5IG9ubHkuXG4gICAqL1xuICBNYWluQXNzZW1ibHkgPSAnbWFpbicsXG5cbiAgLyoqXG4gICAqIElmIG5vIHNlbGVjdG9ycyBhcmUgcHJvdmlkZWQsIHJldHVybnMgYWxsIHN0YWNrcyBpbiB0aGUgYXBwLFxuICAgKiBpbmNsdWRpbmcgc3RhY2tzIGluc2lkZSBuZXN0ZWQgYXNzZW1ibGllcy5cbiAgICovXG4gIEFsbFN0YWNrcyA9ICdhbGwnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFN0YWNrc09wdGlvbnMge1xuICAvKipcbiAgICogRXh0ZW5kIHRoZSBzZWxlY3Rpb24gdG8gdXBzdHJlYWQvZG93bnN0cmVhbSBzdGFja3NcbiAgICogQGRlZmF1bHQgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIG9ubHkgc2VsZWN0IHRoZSBzcGVjaWZpZWQgc3RhY2tzLlxuICAgKi9cbiAgZXh0ZW5kPzogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbjtcblxuICAvKipcbiAgICogVGhlIGJlaGF2aW9yIGlmIG5vIHNlbGVjdG9ycyBhcmUgcHJvdmlkZWQuXG4gICAqL1xuICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb247XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGVwbG95IGlmIHRoZSBhcHAgY29udGFpbnMgbm8gc3RhY2tzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlTm9TdGFja3M/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFdoZW4gc2VsZWN0aW5nIHN0YWNrcywgd2hhdCBvdGhlciBzdGFja3MgdG8gaW5jbHVkZSBiZWNhdXNlIG9mIGRlcGVuZGVuY2llc1xuICovXG5leHBvcnQgZW51bSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uIHtcbiAgLyoqXG4gICAqIERvbid0IHNlbGVjdCBhbnkgZXh0cmEgc3RhY2tzXG4gICAqL1xuICBOb25lLFxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIHN0YWNrcyB0aGF0IHRoaXMgc3RhY2sgZGVwZW5kcyBvblxuICAgKi9cbiAgVXBzdHJlYW0sXG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgc3RhY2tzIHRoYXQgZGVwZW5kIG9uIHRoaXMgc3RhY2tcbiAgICovXG4gIERvd25zdHJlYW0sXG59XG5cbi8qKlxuICogQSBzcGVjaWZpY2F0aW9uIG9mIHdoaWNoIHN0YWNrcyBzaG91bGQgYmUgc2VsZWN0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGFja1NlbGVjdG9yIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgYWxsIHN0YWNrcyBhdCB0aGUgdG9wIGxldmVsIGFzc2VtYmx5IHNob3VsZFxuICAgKiBiZSBzZWxlY3RlZCBhbmQgbm90aGluZyBlbHNlXG4gICAqL1xuICBhbGxUb3BMZXZlbD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBwYXR0ZXJucyB0byBtYXRjaCB0aGUgc3RhY2sgaGllcmFyY2hpY2FsIGlkc1xuICAgKi9cbiAgcGF0dGVybnM6IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIEEgc2luZ2xlIENsb3VkIEFzc2VtYmx5IGFuZCB0aGUgb3BlcmF0aW9ucyB3ZSBkbyBvbiBpdCB0byBkZXBsb3kgdGhlIGFydGlmYWN0cyBpbnNpZGVcbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkQXNzZW1ibHkge1xuICAvKipcbiAgICogVGhlIGRpcmVjdG9yeSB0aGlzIENsb3VkQXNzZW1ibHkgd2FzIHJlYWQgZnJvbVxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGRpcmVjdG9yeTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBhc3NlbWJseTogY3hhcGkuQ2xvdWRBc3NlbWJseSkge1xuICAgIHRoaXMuZGlyZWN0b3J5ID0gYXNzZW1ibHkuZGlyZWN0b3J5O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHNlbGVjdFN0YWNrcyhzZWxlY3RvcjogU3RhY2tTZWxlY3Rvciwgb3B0aW9uczogU2VsZWN0U3RhY2tzT3B0aW9ucyk6IFByb21pc2U8U3RhY2tDb2xsZWN0aW9uPiB7XG4gICAgY29uc3QgYXNtID0gdGhpcy5hc3NlbWJseTtcbiAgICBjb25zdCB0b3BMZXZlbFN0YWNrcyA9IGFzbS5zdGFja3M7XG4gICAgY29uc3Qgc3RhY2tzID0gc2VtdmVyLm1ham9yKGFzbS52ZXJzaW9uKSA8IDEwID8gYXNtLnN0YWNrcyA6IGFzbS5zdGFja3NSZWN1cnNpdmVseTtcbiAgICBjb25zdCBhbGxUb3BMZXZlbCA9IHNlbGVjdG9yLmFsbFRvcExldmVsID8/IGZhbHNlO1xuICAgIGNvbnN0IHBhdHRlcm5zID0gc2FuaXRpemVQYXR0ZXJucyhzZWxlY3Rvci5wYXR0ZXJucyk7XG5cbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKG9wdGlvbnMuaWdub3JlTm9TdGFja3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgW10pO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignVGhpcyBhcHAgY29udGFpbnMgbm8gc3RhY2tzJyk7XG4gICAgfVxuXG4gICAgaWYgKGFsbFRvcExldmVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RUb3BMZXZlbFN0YWNrcyhzdGFja3MsIHRvcExldmVsU3RhY2tzLCBvcHRpb25zLmV4dGVuZCk7XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RNYXRjaGluZ1N0YWNrcyhzdGFja3MsIHBhdHRlcm5zLCBvcHRpb25zLmV4dGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdERlZmF1bHRTdGFja3Moc3RhY2tzLCB0b3BMZXZlbFN0YWNrcywgb3B0aW9ucy5kZWZhdWx0QmVoYXZpb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2VsZWN0VG9wTGV2ZWxTdGFja3MoXG4gICAgc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSxcbiAgICB0b3BMZXZlbFN0YWNrczogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0W10sXG4gICAgZXh0ZW5kOiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uID0gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lLFxuICApOiBTdGFja0NvbGxlY3Rpb24ge1xuICAgIGlmICh0b3BMZXZlbFN0YWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRlbmRTdGFja3ModG9wTGV2ZWxTdGFja3MsIHN0YWNrcywgZXh0ZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignTm8gc3RhY2sgZm91bmQgaW4gdGhlIG1haW4gY2xvdWQgYXNzZW1ibHkuIFVzZSBcImxpc3RcIiB0byBwcmludCBtYW5pZmVzdCcpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBzZWxlY3RNYXRjaGluZ1N0YWNrcyhcbiAgICBzdGFja3M6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdLFxuICAgIHBhdHRlcm5zOiBzdHJpbmdbXSxcbiAgICBleHRlbmQ6IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24gPSBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmUsXG4gICk6IFN0YWNrQ29sbGVjdGlvbiB7XG4gICAgY29uc3QgbWF0Y2hpbmdQYXR0ZXJuID0gKHBhdHRlcm46IHN0cmluZykgPT4gKHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QpID0+IG1pbmltYXRjaChzdGFjay5oaWVyYXJjaGljYWxJZCwgcGF0dGVybik7XG4gICAgY29uc3QgbWF0Y2hlZFN0YWNrcyA9IGZsYXR0ZW4ocGF0dGVybnMubWFwKHBhdHRlcm4gPT4gc3RhY2tzLmZpbHRlcihtYXRjaGluZ1BhdHRlcm4ocGF0dGVybikpKSk7XG5cbiAgICByZXR1cm4gdGhpcy5leHRlbmRTdGFja3MobWF0Y2hlZFN0YWNrcywgc3RhY2tzLCBleHRlbmQpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZWxlY3REZWZhdWx0U3RhY2tzKFxuICAgIHN0YWNrczogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0W10sXG4gICAgdG9wTGV2ZWxTdGFja3M6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdLFxuICAgIGRlZmF1bHRTZWxlY3Rpb246IERlZmF1bHRTZWxlY3Rpb24sXG4gICkge1xuICAgIHN3aXRjaCAoZGVmYXVsdFNlbGVjdGlvbikge1xuICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLk1haW5Bc3NlbWJseTpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgdG9wTGV2ZWxTdGFja3MpO1xuICAgICAgY2FzZSBEZWZhdWx0U2VsZWN0aW9uLkFsbFN0YWNrczpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgc3RhY2tzKTtcbiAgICAgIGNhc2UgRGVmYXVsdFNlbGVjdGlvbi5Ob25lOlxuICAgICAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCBbXSk7XG4gICAgICBjYXNlIERlZmF1bHRTZWxlY3Rpb24uT25seVNpbmdsZTpcbiAgICAgICAgaWYgKHRvcExldmVsU3RhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tDb2xsZWN0aW9uKHRoaXMsIHRvcExldmVsU3RhY2tzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdTaW5jZSB0aGlzIGFwcCBpbmNsdWRlcyBtb3JlIHRoYW4gYSBzaW5nbGUgc3RhY2ssIHNwZWNpZnkgd2hpY2ggc3RhY2tzIHRvIHVzZSAod2lsZGNhcmRzIGFyZSBzdXBwb3J0ZWQpIG9yIHNwZWNpZnkgYC0tYWxsYFxcbicgK1xuICAgICAgICAgIGBTdGFja3M6ICR7c3RhY2tzLm1hcCh4ID0+IHguaGllcmFyY2hpY2FsSWQpLmpvaW4oJyDCtyAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgaW52YWxpZCBkZWZhdWx0IGJlaGF2aW9yOiAke2RlZmF1bHRTZWxlY3Rpb259YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGV4dGVuZFN0YWNrcyhcbiAgICBtYXRjaGVkOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSxcbiAgICBhbGw6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdFtdLFxuICAgIGV4dGVuZDogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbiA9IEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uTm9uZSxcbiAgKSB7XG4gICAgY29uc3QgYWxsU3RhY2tzID0gbmV3IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4oKTtcbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIGFsbCkge1xuICAgICAgYWxsU3RhY2tzLnNldChzdGFjay5oaWVyYXJjaGljYWxJZCwgc3RhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gaW5kZXhCeUhpZXJhcmNoaWNhbElkKG1hdGNoZWQpO1xuXG4gICAgc3dpdGNoIChleHRlbmQpIHtcbiAgICAgIGNhc2UgRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Eb3duc3RyZWFtOlxuICAgICAgICBpbmNsdWRlRG93bnN0cmVhbVN0YWNrcyhpbmRleCwgYWxsU3RhY2tzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24uVXBzdHJlYW06XG4gICAgICAgIGluY2x1ZGVVcHN0cmVhbVN0YWNrcyhpbmRleCwgYWxsU3RhY2tzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIG9yaWdpbmFsIGFycmF5IGJlY2F1c2UgaXQgaXMgaW4gdGhlIHJpZ2h0IG9yZGVyXG4gICAgY29uc3Qgc2VsZWN0ZWRMaXN0ID0gYWxsLmZpbHRlcihzID0+IGluZGV4LmhhcyhzLmhpZXJhcmNoaWNhbElkKSk7XG5cbiAgICByZXR1cm4gbmV3IFN0YWNrQ29sbGVjdGlvbih0aGlzLCBzZWxlY3RlZExpc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHNpbmdsZSBzdGFjayBieSBpdHMgSURcbiAgICovXG4gIHB1YmxpYyBzdGFja0J5SWQoc3RhY2tJZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcywgW3RoaXMuYXNzZW1ibHkuZ2V0U3RhY2tBcnRpZmFjdChzdGFja0lkKV0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGRlcGVuZGVuY2llcyBvZiBhIHN0YWNrLlxuICovXG5leHBvcnQgdHlwZSBTdGFja0RlcGVuZGVuY3kgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGRlcGVuZGVuY2llczogU3RhY2tEZXBlbmRlbmN5W107XG59O1xuXG4vKipcbiAqIERldGFpbHMgb2YgYSBzdGFjay5cbiAqL1xuZXhwb3J0IHR5cGUgU3RhY2tEZXRhaWxzID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudDtcbiAgZGVwZW5kZW5jaWVzOiBTdGFja0RlcGVuZGVuY3lbXTtcbn07XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHN0YWNrcyBhbmQgcmVsYXRlZCBhcnRpZmFjdHNcbiAqXG4gKiBJbiBwcmFjdGljZSwgbm90IGFsbCBhcnRpZmFjdHMgaW4gdGhlIENsb3VkQXNzZW1ibHkgYXJlIGNyZWF0ZWQgZXF1YWw7XG4gKiBzdGFja3MgY2FuIGJlIHNlbGVjdGVkIGluZGVwZW5kZW50bHksIGJ1dCBvdGhlciBhcnRpZmFjdHMgc3VjaCBhcyBhc3NldFxuICogYnVuZGxlcyBjYW5ub3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdGFja0NvbGxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYXNzZW1ibHk6IENsb3VkQXNzZW1ibHksIHB1YmxpYyByZWFkb25seSBzdGFja0FydGlmYWN0czogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0W10pIHtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc3RhY2tDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja0FydGlmYWN0cy5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZpcnN0U3RhY2soKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tDb3VudCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ1N0YWNrQ29sbGVjdGlvbiBjb250YWlucyBubyBzdGFjayBhcnRpZmFjdHMgKHRyeWluZyB0byBhY2Nlc3MgdGhlIGZpcnN0IG9uZSknKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tBcnRpZmFjdHNbMF07XG4gIH1cblxuICBwdWJsaWMgZ2V0IHN0YWNrSWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja0FydGlmYWN0cy5tYXAocyA9PiBzLmlkKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaGllcmFyY2hpY2FsSWRzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja0FydGlmYWN0cy5tYXAocyA9PiBzLmhpZXJhcmNoaWNhbElkKTtcbiAgfVxuXG4gIHB1YmxpYyB3aXRoRGVwZW5kZW5jaWVzKCk6IFN0YWNrRGV0YWlsc1tdIHtcbiAgICBjb25zdCBhbGxEYXRhOiBTdGFja0RldGFpbHNbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzdGFjayBvZiB0aGlzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgICBjb25zdCBkYXRhOiBTdGFja0RldGFpbHMgPSB7XG4gICAgICAgIGlkOiBzdGFjay5kaXNwbGF5TmFtZSA/PyBzdGFjay5pZCxcbiAgICAgICAgbmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICBlbnZpcm9ubWVudDogc3RhY2suZW52aXJvbm1lbnQsXG4gICAgICAgIGRlcGVuZGVuY2llczogW10sXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lJZCBvZiBzdGFjay5kZXBlbmRlbmNpZXMubWFwKHggPT4geC5pZCkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3lJZC5pbmNsdWRlcygnLmFzc2V0cycpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXBTdGFjayA9IHRoaXMuYXNzZW1ibHkuc3RhY2tCeUlkKGRlcGVuZGVuY3lJZCk7XG5cbiAgICAgICAgaWYgKGRlcFN0YWNrLmZpcnN0U3RhY2suZGVwZW5kZW5jaWVzLmZpbHRlcigoZGVwKSA9PiAhKGRlcC5pZCkuaW5jbHVkZXMoJy5hc3NldHMnKSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZvciAoY29uc3Qgc3RhY2tEZXRhaWwgb2YgZGVwU3RhY2sud2l0aERlcGVuZGVuY2llcygpKSB7XG4gICAgICAgICAgICBkYXRhLmRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IHN0YWNrRGV0YWlsLmlkLFxuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IHN0YWNrRGV0YWlsLmRlcGVuZGVuY2llcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhLmRlcGVuZGVuY2llcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBkZXBTdGFjay5maXJzdFN0YWNrLmRpc3BsYXlOYW1lID8/IGRlcFN0YWNrLmZpcnN0U3RhY2suaWQsXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFsbERhdGEucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxsRGF0YTtcbiAgfVxuXG4gIHB1YmxpYyByZXZlcnNlZCgpIHtcbiAgICBjb25zdCBhcnRzID0gWy4uLnRoaXMuc3RhY2tBcnRpZmFjdHNdO1xuICAgIGFydHMucmV2ZXJzZSgpO1xuICAgIHJldHVybiBuZXcgU3RhY2tDb2xsZWN0aW9uKHRoaXMuYXNzZW1ibHksIGFydHMpO1xuICB9XG5cbiAgcHVibGljIGZpbHRlcihwcmVkaWNhdGU6IChhcnQ6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCkgPT4gYm9vbGVhbik6IFN0YWNrQ29sbGVjdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBTdGFja0NvbGxlY3Rpb24odGhpcy5hc3NlbWJseSwgdGhpcy5zdGFja0FydGlmYWN0cy5maWx0ZXIocHJlZGljYXRlKSk7XG4gIH1cblxuICBwdWJsaWMgY29uY2F0KC4uLm90aGVyczogU3RhY2tDb2xsZWN0aW9uW10pOiBTdGFja0NvbGxlY3Rpb24ge1xuICAgIHJldHVybiBuZXcgU3RhY2tDb2xsZWN0aW9uKHRoaXMuYXNzZW1ibHksIHRoaXMuc3RhY2tBcnRpZmFjdHMuY29uY2F0KC4uLm90aGVycy5tYXAobyA9PiBvLnN0YWNrQXJ0aWZhY3RzKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzICdhd3M6Y2RrOndhcm5pbmd8aW5mb3xlcnJvcicgbWV0YWRhdGEgZW50cmllcyBmcm9tIHRoZSBzdGFjayBzeW50aGVzaXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyB2YWxpZGF0ZU1ldGFkYXRhKFxuICAgIGZhaWxBdDogJ3dhcm4nIHwgJ2Vycm9yJyB8ICdub25lJyA9ICdlcnJvcicsXG4gICAgbG9nZ2VyOiAobGV2ZWw6ICdpbmZvJyB8ICdlcnJvcicgfCAnd2FybicsIG1zZzogY3hhcGkuU3ludGhlc2lzTWVzc2FnZSkgPT4gUHJvbWlzZTx2b2lkPiA9IGFzeW5jICgpID0+IHtcbiAgICB9LFxuICApIHtcbiAgICBsZXQgd2FybmluZ3MgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHRoaXMuc3RhY2tBcnRpZmFjdHMpIHtcbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBzdGFjay5tZXNzYWdlcykge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIFN5bnRoZXNpc01lc3NhZ2VMZXZlbC5XQVJOSU5HOlxuICAgICAgICAgICAgd2FybmluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgbG9nZ2VyKCd3YXJuJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN5bnRoZXNpc01lc3NhZ2VMZXZlbC5FUlJPUjpcbiAgICAgICAgICAgIGVycm9ycyA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBsb2dnZXIoJ2Vycm9yJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFN5bnRoZXNpc01lc3NhZ2VMZXZlbC5JTkZPOlxuICAgICAgICAgICAgYXdhaXQgbG9nZ2VyKCdpbmZvJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMgJiYgZmFpbEF0ICE9ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VtYmx5RXJyb3IoJ0ZvdW5kIGVycm9ycycpO1xuICAgIH1cblxuICAgIGlmICh3YXJuaW5ncyAmJiBmYWlsQXQgPT09ICd3YXJuJykge1xuICAgICAgdGhyb3cgbmV3IEFzc2VtYmx5RXJyb3IoJ0ZvdW5kIHdhcm5pbmdzICgtLXN0cmljdCBtb2RlKScpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFkYXRhTWVzc2FnZU9wdGlvbnMge1xuICAvKipcbiAgICogV2hldGhlciB0byBiZSB2ZXJib3NlXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB2ZXJib3NlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRG9uJ3Qgc3RvcCBvbiBlcnJvciBtZXRhZGF0YVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlRXJyb3JzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVHJlYXQgd2FybmluZ3MgaW4gbWV0YWRhdGEgYXMgZXJyb3JzXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzdHJpY3Q/OiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBpbmRleEJ5SGllcmFyY2hpY2FsSWQoc3RhY2tzOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3RbXSk6IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4ge1xuICBjb25zdCByZXN1bHQgPSBuZXcgTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PigpO1xuXG4gIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgcmVzdWx0LnNldChzdGFjay5oaWVyYXJjaGljYWxJZCwgc3RhY2spO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHRyYW5zaXRpdmUgY2xvc3VyZSBvZiBzdGFjayBkZXBlbmRlbnRzLlxuICpcbiAqIE1vZGlmaWVzIGBzZWxlY3RlZFN0YWNrc2AgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVEb3duc3RyZWFtU3RhY2tzKFxuICBzZWxlY3RlZFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0PixcbiAgYWxsU3RhY2tzOiBNYXA8c3RyaW5nLCBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q+KSB7XG4gIGNvbnN0IGFkZGVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICBsZXQgbWFkZVByb2dyZXNzO1xuICBkbyB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IFtpZCwgc3RhY2tdIG9mIGFsbFN0YWNrcykge1xuICAgICAgLy8gU2VsZWN0IHRoaXMgc3RhY2sgaWYgaXQncyBub3Qgc2VsZWN0ZWQgeWV0IEFORCBpdCBkZXBlbmRzIG9uIGEgc3RhY2sgdGhhdCdzIGluIHRoZSBzZWxlY3RlZCBzZXRcbiAgICAgIGlmICghc2VsZWN0ZWRTdGFja3MuaGFzKGlkKSAmJiAoc3RhY2suZGVwZW5kZW5jaWVzIHx8IFtdKS5zb21lKGRlcCA9PiBzZWxlY3RlZFN0YWNrcy5oYXMoZGVwLmlkKSkpIHtcbiAgICAgICAgc2VsZWN0ZWRTdGFja3Muc2V0KGlkLCBzdGFjayk7XG4gICAgICAgIGFkZGVkLnB1c2goaWQpO1xuICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobWFkZVByb2dyZXNzKTtcblxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIGluZm8oJ0luY2x1ZGluZyBkZXBlbmRpbmcgc3RhY2tzOiAlcycsIGNoYWxrLmJvbGQoYWRkZWQuam9pbignLCAnKSkpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB0cmFuc2l0aXZlIGNsb3N1cmUgb2Ygc3RhY2sgZGVwZW5kZW5jaWVzLlxuICpcbiAqIE1vZGlmaWVzIGBzZWxlY3RlZFN0YWNrc2AgaW4tcGxhY2UuXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVVcHN0cmVhbVN0YWNrcyhcbiAgc2VsZWN0ZWRTdGFja3M6IE1hcDxzdHJpbmcsIGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdD4sXG4gIGFsbFN0YWNrczogTWFwPHN0cmluZywgY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0Pikge1xuICBjb25zdCBhZGRlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGxldCBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICB3aGlsZSAobWFkZVByb2dyZXNzKSB7XG4gICAgbWFkZVByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHNlbGVjdGVkU3RhY2tzLnZhbHVlcygpKSB7XG4gICAgICAvLyBTZWxlY3QgYW4gYWRkaXRpb25hbCBzdGFjayBpZiBpdCdzIG5vdCBzZWxlY3RlZCB5ZXQgYW5kIGEgZGVwZW5kZW5jeSBvZiBhIHNlbGVjdGVkIHN0YWNrIChhbmQgZXhpc3RzLCBvYnZpb3VzbHkpXG4gICAgICBmb3IgKGNvbnN0IGRlcGVuZGVuY3lJZCBvZiBzdGFjay5kZXBlbmRlbmNpZXMubWFwKHggPT4geC5tYW5pZmVzdC5kaXNwbGF5TmFtZSA/PyB4LmlkKSkge1xuICAgICAgICBpZiAoIXNlbGVjdGVkU3RhY2tzLmhhcyhkZXBlbmRlbmN5SWQpICYmIGFsbFN0YWNrcy5oYXMoZGVwZW5kZW5jeUlkKSkge1xuICAgICAgICAgIGFkZGVkLnB1c2goZGVwZW5kZW5jeUlkKTtcbiAgICAgICAgICBzZWxlY3RlZFN0YWNrcy5zZXQoZGVwZW5kZW5jeUlkLCBhbGxTdGFja3MuZ2V0KGRlcGVuZGVuY3lJZCkhKTtcbiAgICAgICAgICBtYWRlUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICBpbmZvKCdJbmNsdWRpbmcgZGVwZW5kZW5jeSBzdGFja3M6ICVzJywgY2hhbGsuYm9sZChhZGRlZC5qb2luKCcsICcpKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplUGF0dGVybnMocGF0dGVybnM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICBsZXQgc2FuaXRpemVkID0gcGF0dGVybnMuZmlsdGVyKHMgPT4gcyAhPSBudWxsKTsgLy8gZmlsdGVyIG51bGwvdW5kZWZpbmVkXG4gIHNhbml0aXplZCA9IFsuLi5uZXcgU2V0KHNhbml0aXplZCldOyAvLyBtYWtlIHRoZW0gdW5pcXVlXG4gIHJldHVybiBzYW5pdGl6ZWQ7XG59XG4iXX0=