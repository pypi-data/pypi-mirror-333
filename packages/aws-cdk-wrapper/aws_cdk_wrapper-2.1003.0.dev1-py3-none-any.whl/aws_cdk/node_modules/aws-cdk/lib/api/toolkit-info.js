"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const util_1 = require("util");
const chalk = require("chalk");
const bootstrap_props_1 = require("./bootstrap/bootstrap-props");
const cloudformation_1 = require("./deployments/cloudformation");
const messages_1 = require("../cli/messages");
const error_1 = require("../toolkit/error");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * Information on the Bootstrap stack of the environment we're deploying to.
 *
 * This class serves to:
 *
 * - Inspect the bootstrap stack, and return various properties of it for successful
 *   asset deployment (in case of legacy-synthesized stacks).
 * - Validate the version of the target environment, and nothing else (in case of
 *   default-synthesized stacks).
 *
 * An object of this type might represent a bootstrap stack that could not be found.
 * This is not an issue unless any members are used that require the bootstrap stack
 * to have been found, in which case an error is thrown (default-synthesized stacks
 * should never run into this as they don't need information from the bootstrap
 * stack, all information is already encoded into the Cloud Assembly Manifest).
 *
 * Nevertheless, an instance of this class exists to serve as a cache for SSM
 * parameter lookups (otherwise, the "bootstrap stack version" parameter would
 * need to be read repeatedly).
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 */
class ToolkitInfo {
    static determineName(overrideName) {
        return overrideName !== null && overrideName !== void 0 ? overrideName : exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    static async lookup(environment, sdk, { ioHost, action }, stackName) {
        const cfn = sdk.cloudFormation();
        stackName = ToolkitInfo.determineName(stackName);
        try {
            const stack = await (0, cloudformation_1.stabilizeStack)(cfn, { ioHost, action }, stackName);
            if (!stack) {
                await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)("The environment %s doesn't have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.", environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`))));
                return ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
            }
            if (stack.stackStatus.isCreationFailure) {
                // Treat a "failed to create" bootstrap stack as an absent one.
                await ioHost.notify((0, messages_1.debug)(action, (0, util_1.format)('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, chalk.blue(`cdk bootstrap "${environment.name}"`))));
                return ToolkitInfo.bootstrapStackNotFoundInfo(stackName);
            }
            return new ExistingToolkitInfo(stack);
        }
        catch (e) {
            return ToolkitInfo.bootstrapStackLookupError(stackName, e);
        }
    }
    static fromStack(stack) {
        return new ExistingToolkitInfo(stack);
    }
    static bootstrapStackNotFoundInfo(stackName) {
        return new BootstrapStackNotFoundInfo(stackName, "This deployment requires a bootstrap stack with a known name; pass '--toolkit-stack-name' or switch to using the 'DefaultStackSynthesizer' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)");
    }
    static bootstrapStackLookupError(stackName, e) {
        return new BootstrapStackNotFoundInfo(stackName, `This deployment requires a bootstrap stack with a known name, but during its lookup the following error occurred: ${e}; pass \'--toolkit-stack-name\' or switch to using the \'DefaultStackSynthesizer\' (see https://docs.aws.amazon.com/cdk/latest/guide/bootstrapping.html)`);
    }
    constructor() {
    }
}
exports.ToolkitInfo = ToolkitInfo;
/**
 * Returned when a bootstrap stack is found
 */
class ExistingToolkitInfo extends ToolkitInfo {
    constructor(bootstrapStack) {
        super();
        this.bootstrapStack = bootstrapStack;
        this.found = true;
    }
    get bucketUrl() {
        return `https://${this.requireOutput(bootstrap_props_1.BUCKET_DOMAIN_NAME_OUTPUT)}`;
    }
    get bucketName() {
        return this.requireOutput(bootstrap_props_1.BUCKET_NAME_OUTPUT);
    }
    get repositoryName() {
        return this.requireOutput(bootstrap_props_1.REPOSITORY_NAME_OUTPUT);
    }
    get version() {
        var _a;
        return parseInt((_a = this.bootstrapStack.outputs[bootstrap_props_1.BOOTSTRAP_VERSION_OUTPUT]) !== null && _a !== void 0 ? _a : '0', 10);
    }
    get variant() {
        var _a;
        return (_a = this.bootstrapStack.parameters[bootstrap_props_1.BOOTSTRAP_VARIANT_PARAMETER]) !== null && _a !== void 0 ? _a : bootstrap_props_1.DEFAULT_BOOTSTRAP_VARIANT;
    }
    get parameters() {
        var _a;
        return (_a = this.bootstrapStack.parameters) !== null && _a !== void 0 ? _a : {};
    }
    get terminationProtection() {
        var _a;
        return (_a = this.bootstrapStack.terminationProtection) !== null && _a !== void 0 ? _a : false;
    }
    get stackName() {
        return this.bootstrapStack.stackName;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     */
    requireOutput(output) {
        if (!(output in this.bootstrapStack.outputs)) {
            throw new error_1.ToolkitError(`The CDK toolkit stack (${this.bootstrapStack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
        }
        return this.bootstrapStack.outputs[output];
    }
}
/**
 * Returned when a bootstrap stack could not be found
 *
 * This is not an error in principle, UNTIL one of the members is called that requires
 * the bootstrap stack to have been found, in which case the lookup error is still thrown
 * belatedly.
 *
 * The errors below serve as a last stop-gap message--normally calling code should have
 * checked `toolkit.found` and produced an appropriate error message.
 */
class BootstrapStackNotFoundInfo extends ToolkitInfo {
    constructor(stackName, errorMessage) {
        super();
        this.stackName = stackName;
        this.errorMessage = errorMessage;
        this.found = false;
    }
    get bootstrapStack() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
    get bucketUrl() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
    get bucketName() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
    get repositoryName() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
    get version() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
    get variant() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
    prepareEcrRepository() {
        throw new error_1.ToolkitError(this.errorMessage);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUE4QjtBQUU5QiwrQkFBK0I7QUFFL0IsaUVBT3FDO0FBQ3JDLGlFQUF3RjtBQUN4Riw4Q0FBd0M7QUFFeEMsNENBQWdEO0FBRW5DLFFBQUEsMEJBQTBCLEdBQUcsWUFBWSxDQUFDO0FBRXZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JHO0FBQ0gsTUFBc0IsV0FBVztJQUN4QixNQUFNLENBQUMsYUFBYSxDQUFDLFlBQXFCO1FBQy9DLE9BQU8sWUFBWSxhQUFaLFlBQVksY0FBWixZQUFZLEdBQUksa0NBQTBCLENBQUM7SUFDcEQsQ0FBQztJQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4QixXQUE4QixFQUM5QixHQUFRLEVBQ1IsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFlLEVBQy9CLFNBQTZCO1FBRTdCLE1BQU0sR0FBRyxHQUFHLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNqQyxTQUFTLEdBQUcsV0FBVyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUM7WUFDSCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUEsK0JBQWMsRUFBQyxHQUFHLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDdkUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNYLE1BQU0sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFBLGdCQUFLLEVBQ3ZCLE1BQU0sRUFDTixJQUFBLGFBQU0sRUFDSixrSUFBa0ksRUFDbEksV0FBVyxDQUFDLElBQUksRUFDaEIsU0FBUyxFQUNULEtBQUssQ0FBQyxJQUFJLENBQUMsa0JBQWtCLFdBQVcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUNsRCxDQUNGLENBQUMsQ0FBQztnQkFDSCxPQUFP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O0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXQgfSBmcm9tICd1dGlsJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgdHlwZSB7IFNESyB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHtcbiAgQk9PVFNUUkFQX1ZBUklBTlRfUEFSQU1FVEVSLFxuICBCT09UU1RSQVBfVkVSU0lPTl9PVVRQVVQsXG4gIEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQsXG4gIEJVQ0tFVF9OQU1FX09VVFBVVCxcbiAgREVGQVVMVF9CT09UU1RSQVBfVkFSSUFOVCxcbiAgUkVQT1NJVE9SWV9OQU1FX09VVFBVVCxcbn0gZnJvbSAnLi9ib290c3RyYXAvYm9vdHN0cmFwLXByb3BzJztcbmltcG9ydCB7IHR5cGUgQ2xvdWRGb3JtYXRpb25TdGFjaywgc3RhYmlsaXplU3RhY2sgfSBmcm9tICcuL2RlcGxveW1lbnRzL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vY2xpL21lc3NhZ2VzJztcbmltcG9ydCB7IElvTWVzc2FnaW5nIH0gZnJvbSAnLi4vdG9vbGtpdC9jbGktaW8taG9zdCc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi90b29sa2l0L2Vycm9yJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FID0gJ0NES1Rvb2xraXQnO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIG9uIHRoZSBCb290c3RyYXAgc3RhY2sgb2YgdGhlIGVudmlyb25tZW50IHdlJ3JlIGRlcGxveWluZyB0by5cbiAqXG4gKiBUaGlzIGNsYXNzIHNlcnZlcyB0bzpcbiAqXG4gKiAtIEluc3BlY3QgdGhlIGJvb3RzdHJhcCBzdGFjaywgYW5kIHJldHVybiB2YXJpb3VzIHByb3BlcnRpZXMgb2YgaXQgZm9yIHN1Y2Nlc3NmdWxcbiAqICAgYXNzZXQgZGVwbG95bWVudCAoaW4gY2FzZSBvZiBsZWdhY3ktc3ludGhlc2l6ZWQgc3RhY2tzKS5cbiAqIC0gVmFsaWRhdGUgdGhlIHZlcnNpb24gb2YgdGhlIHRhcmdldCBlbnZpcm9ubWVudCwgYW5kIG5vdGhpbmcgZWxzZSAoaW4gY2FzZSBvZlxuICogICBkZWZhdWx0LXN5bnRoZXNpemVkIHN0YWNrcykuXG4gKlxuICogQW4gb2JqZWN0IG9mIHRoaXMgdHlwZSBtaWdodCByZXByZXNlbnQgYSBib290c3RyYXAgc3RhY2sgdGhhdCBjb3VsZCBub3QgYmUgZm91bmQuXG4gKiBUaGlzIGlzIG5vdCBhbiBpc3N1ZSB1bmxlc3MgYW55IG1lbWJlcnMgYXJlIHVzZWQgdGhhdCByZXF1aXJlIHRoZSBib290c3RyYXAgc3RhY2tcbiAqIHRvIGhhdmUgYmVlbiBmb3VuZCwgaW4gd2hpY2ggY2FzZSBhbiBlcnJvciBpcyB0aHJvd24gKGRlZmF1bHQtc3ludGhlc2l6ZWQgc3RhY2tzXG4gKiBzaG91bGQgbmV2ZXIgcnVuIGludG8gdGhpcyBhcyB0aGV5IGRvbid0IG5lZWQgaW5mb3JtYXRpb24gZnJvbSB0aGUgYm9vdHN0cmFwXG4gKiBzdGFjaywgYWxsIGluZm9ybWF0aW9uIGlzIGFscmVhZHkgZW5jb2RlZCBpbnRvIHRoZSBDbG91ZCBBc3NlbWJseSBNYW5pZmVzdCkuXG4gKlxuICogTmV2ZXJ0aGVsZXNzLCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGV4aXN0cyB0byBzZXJ2ZSBhcyBhIGNhY2hlIGZvciBTU01cbiAqIHBhcmFtZXRlciBsb29rdXBzIChvdGhlcndpc2UsIHRoZSBcImJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uXCIgcGFyYW1ldGVyIHdvdWxkXG4gKiBuZWVkIHRvIGJlIHJlYWQgcmVwZWF0ZWRseSkuXG4gKlxuICogQ2FsbGVkIFwiVG9vbGtpdEluZm9cIiBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHN0YXRpYyBkZXRlcm1pbmVOYW1lKG92ZXJyaWRlTmFtZT86IHN0cmluZykge1xuICAgIHJldHVybiBvdmVycmlkZU5hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUU7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvb2t1cChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrOiBTREssXG4gICAgeyBpb0hvc3QsIGFjdGlvbiB9OiBJb01lc3NhZ2luZyxcbiAgICBzdGFja05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgKTogUHJvbWlzZTxUb29sa2l0SW5mbz4ge1xuICAgIGNvbnN0IGNmbiA9IHNkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgIHN0YWNrTmFtZSA9IFRvb2xraXRJbmZvLmRldGVybWluZU5hbWUoc3RhY2tOYW1lKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHsgaW9Ib3N0LCBhY3Rpb24gfSwgc3RhY2tOYW1lKTtcbiAgICAgIGlmICghc3RhY2spIHtcbiAgICAgICAgYXdhaXQgaW9Ib3N0Lm5vdGlmeShkZWJ1ZyhcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgZm9ybWF0KFxuICAgICAgICAgICAgXCJUaGUgZW52aXJvbm1lbnQgJXMgZG9lc24ndCBoYXZlIHRoZSBDREsgdG9vbGtpdCBzdGFjayAoJXMpIGluc3RhbGxlZC4gVXNlICVzIHRvIHNldHVwIHlvdXIgZW52aXJvbm1lbnQgZm9yIHVzZSB3aXRoIHRoZSB0b29sa2l0LlwiLFxuICAgICAgICAgICAgZW52aXJvbm1lbnQubmFtZSxcbiAgICAgICAgICAgIHN0YWNrTmFtZSxcbiAgICAgICAgICAgIGNoYWxrLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSxcbiAgICAgICAgICApLFxuICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuIFRvb2xraXRJbmZvLmJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKHN0YWNrTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhY2suc3RhY2tTdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICAgICAgLy8gVHJlYXQgYSBcImZhaWxlZCB0byBjcmVhdGVcIiBib290c3RyYXAgc3RhY2sgYXMgYW4gYWJzZW50IG9uZS5cbiAgICAgICAgYXdhaXQgaW9Ib3N0Lm5vdGlmeShkZWJ1ZyhcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgZm9ybWF0KFxuICAgICAgICAgICAgJ1RoZSBlbnZpcm9ubWVudCAlcyBoYXMgYSBDREsgdG9vbGtpdCBzdGFjayAoJXMpIHRoYXQgZmFpbGVkIHRvIGNyZWF0ZS4gVXNlICVzIHRvIHRyeSBwcm92aXNpb25pbmcgaXQgYWdhaW4uJyxcbiAgICAgICAgICAgIGVudmlyb25tZW50Lm5hbWUsXG4gICAgICAgICAgICBzdGFja05hbWUsXG4gICAgICAgICAgICBjaGFsay5ibHVlKGBjZGsgYm9vdHN0cmFwIFwiJHtlbnZpcm9ubWVudC5uYW1lfVwiYCksXG4gICAgICAgICAgKSxcbiAgICAgICAgKSk7XG4gICAgICAgIHJldHVybiBUb29sa2l0SW5mby5ib290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzdGFja05hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEV4aXN0aW5nVG9vbGtpdEluZm8oc3RhY2spO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgcmV0dXJuIFRvb2xraXRJbmZvLmJvb3RzdHJhcFN0YWNrTG9va3VwRXJyb3Ioc3RhY2tOYW1lLCBlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21TdGFjayhzdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjayk6IFRvb2xraXRJbmZvIHtcbiAgICByZXR1cm4gbmV3IEV4aXN0aW5nVG9vbGtpdEluZm8oc3RhY2spO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBib290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhzdGFja05hbWU6IHN0cmluZyk6IFRvb2xraXRJbmZvIHtcbiAgICByZXR1cm4gbmV3IEJvb3RzdHJhcFN0YWNrTm90Rm91bmRJbmZvKFxuICAgICAgc3RhY2tOYW1lLFxuICAgICAgXCJUaGlzIGRlcGxveW1lbnQgcmVxdWlyZXMgYSBib290c3RyYXAgc3RhY2sgd2l0aCBhIGtub3duIG5hbWU7IHBhc3MgJy0tdG9vbGtpdC1zdGFjay1uYW1lJyBvciBzd2l0Y2ggdG8gdXNpbmcgdGhlICdEZWZhdWx0U3RhY2tTeW50aGVzaXplcicgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpXCIsXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYm9vdHN0cmFwU3RhY2tMb29rdXBFcnJvcihzdGFja05hbWU6IHN0cmluZywgZTogRXJyb3IpOiBUb29sa2l0SW5mbyB7XG4gICAgcmV0dXJuIG5ldyBCb290c3RyYXBTdGFja05vdEZvdW5kSW5mbyhcbiAgICAgIHN0YWNrTmFtZSxcbiAgICAgIGBUaGlzIGRlcGxveW1lbnQgcmVxdWlyZXMgYSBib290c3RyYXAgc3RhY2sgd2l0aCBhIGtub3duIG5hbWUsIGJ1dCBkdXJpbmcgaXRzIGxvb2t1cCB0aGUgZm9sbG93aW5nIGVycm9yIG9jY3VycmVkOiAke2V9OyBwYXNzIFxcJy0tdG9vbGtpdC1zdGFjay1uYW1lXFwnIG9yIHN3aXRjaCB0byB1c2luZyB0aGUgXFwnRGVmYXVsdFN0YWNrU3ludGhlc2l6ZXJcXCcgKHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWwpYCxcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFic3RyYWN0IHJlYWRvbmx5IGZvdW5kOiBib29sZWFuO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgYnVja2V0VXJsOiBzdHJpbmc7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBidWNrZXROYW1lOiBzdHJpbmc7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSByZXBvc2l0b3J5TmFtZTogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgdmVyc2lvbjogbnVtYmVyO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgdmFyaWFudDogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2s7XG4gIHB1YmxpYyBhYnN0cmFjdCByZWFkb25seSBzdGFja05hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBib290c3RyYXAgc3RhY2sgaXMgZm91bmRcbiAqL1xuY2xhc3MgRXhpc3RpbmdUb29sa2l0SW5mbyBleHRlbmRzIFRvb2xraXRJbmZvIHtcbiAgcHVibGljIHJlYWRvbmx5IGZvdW5kID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYm9vdHN0cmFwU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2spIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVibGljIGdldCBidWNrZXRVcmwoKSB7XG4gICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5yZXF1aXJlT3V0cHV0KEJVQ0tFVF9ET01BSU5fTkFNRV9PVVRQVVQpfWA7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWlyZU91dHB1dChCVUNLRVRfTkFNRV9PVVRQVVQpO1xuICB9XG5cbiAgcHVibGljIGdldCByZXBvc2l0b3J5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlT3V0cHV0KFJFUE9TSVRPUllfTkFNRV9PVVRQVVQpO1xuICB9XG5cbiAgcHVibGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmJvb3RzdHJhcFN0YWNrLm91dHB1dHNbQk9PVFNUUkFQX1ZFUlNJT05fT1VUUFVUXSA/PyAnMCcsIDEwKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmFyaWFudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay5wYXJhbWV0ZXJzW0JPT1RTVFJBUF9WQVJJQU5UX1BBUkFNRVRFUl0gPz8gREVGQVVMVF9CT09UU1RSQVBfVkFSSUFOVDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcGFyYW1ldGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay5wYXJhbWV0ZXJzID8/IHt9O1xuICB9XG5cbiAgcHVibGljIGdldCB0ZXJtaW5hdGlvblByb3RlY3Rpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYm9vdHN0cmFwU3RhY2sudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldCBzdGFja05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ib290c3RyYXBTdGFjay5zdGFja05hbWU7XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbiBFQ1IgcmVwb3NpdG9yeSBmb3IgdXBsb2FkaW5nIHRvIHVzaW5nIERvY2tlclxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSByZXF1aXJlT3V0cHV0KG91dHB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIShvdXRwdXQgaW4gdGhpcy5ib290c3RyYXBTdGFjay5vdXRwdXRzKSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgICAgYFRoZSBDREsgdG9vbGtpdCBzdGFjayAoJHt0aGlzLmJvb3RzdHJhcFN0YWNrLnN0YWNrTmFtZX0pIGRvZXMgbm90IGhhdmUgYW4gb3V0cHV0IG5hbWVkICR7b3V0cHV0fS4gVXNlICdjZGsgYm9vdHN0cmFwJyB0byBjb3JyZWN0IHRoaXMuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJvb3RzdHJhcFN0YWNrLm91dHB1dHNbb3V0cHV0XTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybmVkIHdoZW4gYSBib290c3RyYXAgc3RhY2sgY291bGQgbm90IGJlIGZvdW5kXG4gKlxuICogVGhpcyBpcyBub3QgYW4gZXJyb3IgaW4gcHJpbmNpcGxlLCBVTlRJTCBvbmUgb2YgdGhlIG1lbWJlcnMgaXMgY2FsbGVkIHRoYXQgcmVxdWlyZXNcbiAqIHRoZSBib290c3RyYXAgc3RhY2sgdG8gaGF2ZSBiZWVuIGZvdW5kLCBpbiB3aGljaCBjYXNlIHRoZSBsb29rdXAgZXJyb3IgaXMgc3RpbGwgdGhyb3duXG4gKiBiZWxhdGVkbHkuXG4gKlxuICogVGhlIGVycm9ycyBiZWxvdyBzZXJ2ZSBhcyBhIGxhc3Qgc3RvcC1nYXAgbWVzc2FnZS0tbm9ybWFsbHkgY2FsbGluZyBjb2RlIHNob3VsZCBoYXZlXG4gKiBjaGVja2VkIGB0b29sa2l0LmZvdW5kYCBhbmQgcHJvZHVjZWQgYW4gYXBwcm9wcmlhdGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuY2xhc3MgQm9vdHN0cmFwU3RhY2tOb3RGb3VuZEluZm8gZXh0ZW5kcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyByZWFkb25seSBmb3VuZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBzdGFja05hbWU6IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGVycm9yTWVzc2FnZTogc3RyaW5nLFxuICApIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHVibGljIGdldCBib290c3RyYXBTdGFjaygpOiBDbG91ZEZvcm1hdGlvblN0YWNrIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0VXJsKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGJ1Y2tldE5hbWUoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgcmVwb3NpdG9yeU5hbWUoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKHRoaXMuZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmVyc2lvbigpOiBudW1iZXIge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCB2YXJpYW50KCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcih0aGlzLmVycm9yTWVzc2FnZSk7XG4gIH1cblxuICBwdWJsaWMgcHJlcGFyZUVjclJlcG9zaXRvcnkoKTogUHJvbWlzZTxFY3JSZXBvc2l0b3J5SW5mbz4ge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNyUmVwb3NpdG9yeUluZm8ge1xuICByZXBvc2l0b3J5VXJpOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWNyQ3JlZGVudGlhbHMge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufVxuIl19