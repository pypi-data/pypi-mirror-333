"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromScan = exports.CfnTemplateGeneratorProvider = exports.FilterType = exports.ScanStatus = exports.TemplateSourceOptions = void 0;
exports.generateCdkApp = generateCdkApp;
exports.generateStack = generateStack;
exports.readFromPath = readFromPath;
exports.readFromStack = readFromStack;
exports.generateTemplate = generateTemplate;
exports.chunks = chunks;
exports.setEnvironment = setEnvironment;
exports.parseSourceOptions = parseSourceOptions;
exports.scanProgressBar = scanProgressBar;
exports.printBar = printBar;
exports.printDots = printDots;
exports.rewriteLine = rewriteLine;
exports.displayTimeDiff = displayTimeDiff;
exports.writeMigrateJsonFile = writeMigrateJsonFile;
exports.getMigrateScanType = getMigrateScanType;
exports.isThereAWarning = isThereAWarning;
exports.buildGenertedTemplateOutput = buildGenertedTemplateOutput;
exports.buildCfnClient = buildCfnClient;
exports.appendWarningsToReadme = appendWarningsToReadme;
/* eslint-disable @typescript-eslint/no-require-imports */
/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require("fs");
const path = require("path");
const cx_api_1 = require("@aws-cdk/cx-api");
const cdk_from_cfn = require("cdk-from-cfn");
const chalk = require("chalk");
const init_1 = require("../../lib/init");
const logging_1 = require("../../lib/logging");
const deployments_1 = require("../api/deployments");
const error_1 = require("../toolkit/error");
const util_1 = require("../util");
const camelCase = require('camelcase');
const decamelize = require('decamelize');
/** The list of languages supported by the built-in noctilucent binary. */
const MIGRATE_SUPPORTED_LANGUAGES = cdk_from_cfn.supported_languages();
/**
 * Generates a CDK app from a yaml or json template.
 *
 * @param stackName The name to assign to the stack in the generated app
 * @param stack The yaml or json template for the stack
 * @param language The language to generate the CDK app in
 * @param outputPath The path at which to generate the CDK app
 */
async function generateCdkApp(stackName, stack, language, outputPath, compress) {
    const resolvedOutputPath = path.join(outputPath !== null && outputPath !== void 0 ? outputPath : process.cwd(), stackName);
    const formattedStackName = decamelize(stackName);
    try {
        fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        fs.mkdirSync(resolvedOutputPath, { recursive: true });
        const generateOnly = compress;
        await (0, init_1.cliInit)({
            type: 'app',
            language,
            canUseNetwork: true,
            generateOnly,
            workDir: resolvedOutputPath,
            stackName,
            migrate: true,
        });
        let stackFileName;
        switch (language) {
            case 'typescript':
                stackFileName = `${resolvedOutputPath}/lib/${formattedStackName}-stack.ts`;
                break;
            case 'java':
                stackFileName = `${resolvedOutputPath}/src/main/java/com/myorg/${camelCase(formattedStackName, { pascalCase: true })}Stack.java`;
                break;
            case 'python':
                stackFileName = `${resolvedOutputPath}/${formattedStackName.replace(/-/g, '_')}/${formattedStackName.replace(/-/g, '_')}_stack.py`;
                break;
            case 'csharp':
                stackFileName = `${resolvedOutputPath}/src/${camelCase(formattedStackName, { pascalCase: true })}/${camelCase(formattedStackName, { pascalCase: true })}Stack.cs`;
                break;
            case 'go':
                stackFileName = `${resolvedOutputPath}/${formattedStackName}.go`;
                break;
            default:
                throw new error_1.ToolkitError(`${language} is not supported by CDK Migrate. Please choose from: ${MIGRATE_SUPPORTED_LANGUAGES.join(', ')}`);
        }
        fs.writeFileSync(stackFileName, stack);
        if (compress) {
            await (0, util_1.zipDirectory)(resolvedOutputPath, `${resolvedOutputPath}.zip`);
            fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        }
    }
    catch (error) {
        fs.rmSync(resolvedOutputPath, { recursive: true, force: true });
        throw error;
    }
}
/**
 * Generates a CDK stack file.
 * @param template The template to translate into a CDK stack
 * @param stackName The name to assign to the stack
 * @param language The language to generate the stack in
 * @returns A string representation of a CDK stack file
 */
function generateStack(template, stackName, language) {
    const formattedStackName = `${camelCase(decamelize(stackName), { pascalCase: true })}Stack`;
    try {
        return cdk_from_cfn.transmute(template, language, formattedStackName);
    }
    catch (e) {
        throw new error_1.ToolkitError(`${formattedStackName} could not be generated because ${e.message}`);
    }
}
/**
 * Reads and returns a stack template from a local path.
 *
 * @param inputPath The location of the template
 * @returns A string representation of the template if present, otherwise undefined
 */
function readFromPath(inputPath) {
    let readFile;
    try {
        readFile = fs.readFileSync(inputPath, 'utf8');
    }
    catch (e) {
        throw new error_1.ToolkitError(`'${inputPath}' is not a valid path.`);
    }
    if (readFile == '') {
        throw new error_1.ToolkitError(`Cloudformation template filepath: '${inputPath}' is an empty file.`);
    }
    return readFile;
}
/**
 * Reads and returns a stack template from a deployed CloudFormation stack.
 *
 * @param stackName The name of the stack
 * @param sdkProvider The sdk provider for making CloudFormation calls
 * @param environment The account and region where the stack is deployed
 * @returns A string representation of the template if present, otherwise undefined
 */
async function readFromStack(stackName, sdkProvider, environment) {
    const cloudFormation = (await sdkProvider.forEnvironment(environment, 0)).sdk.cloudFormation();
    const stack = await deployments_1.CloudFormationStack.lookup(cloudFormation, stackName, true);
    if (stack.stackStatus.isDeploySuccess || stack.stackStatus.isRollbackSuccess) {
        return JSON.stringify(await stack.template());
    }
    else {
        throw new error_1.ToolkitError(`Stack '${stackName}' in account ${environment.account} and region ${environment.region} has a status of '${stack.stackStatus.name}' due to '${stack.stackStatus.reason}'. The stack cannot be migrated until it is in a healthy state.`);
    }
}
/**
 * Takes in a stack name and account and region and returns a generated cloudformation template using the cloudformation
 * template generator.
 *
 * @param GenerateTemplateOptions An object containing the stack name, filters, sdkProvider, environment, and newScan flag
 * @returns a generated cloudformation template
 */
async function generateTemplate(options) {
    const cfn = new CfnTemplateGeneratorProvider(await buildCfnClient(options.sdkProvider, options.environment));
    const scanId = await findLastSuccessfulScan(cfn, options);
    // if a customer accidentally ctrl-c's out of the command and runs it again, this will continue the progress bar where it left off
    const curScan = await cfn.describeResourceScan(scanId);
    if (curScan.Status == ScanStatus.IN_PROGRESS) {
        (0, logging_1.info)('Resource scan in progress. Please wait, this can take 10 minutes or longer.');
        await scanProgressBar(scanId, cfn);
    }
    displayTimeDiff(new Date(), new Date(curScan.StartTime));
    let resources = await cfn.listResourceScanResources(scanId, options.filters);
    (0, logging_1.info)('finding related resources.');
    let relatedResources = await cfn.getResourceScanRelatedResources(scanId, resources);
    (0, logging_1.info)(`Found ${relatedResources.length} resources.`);
    (0, logging_1.info)('Generating CFN template from scanned resources.');
    const templateArn = (await cfn.createGeneratedTemplate(options.stackName, relatedResources)).GeneratedTemplateId;
    let generatedTemplate = await cfn.describeGeneratedTemplate(templateArn);
    (0, logging_1.info)('Please wait, template creation in progress. This may take a couple minutes.');
    while (generatedTemplate.Status !== ScanStatus.COMPLETE && generatedTemplate.Status !== ScanStatus.FAILED) {
        await printDots(`[${generatedTemplate.Status}] Template Creation in Progress`, 400);
        generatedTemplate = await cfn.describeGeneratedTemplate(templateArn);
    }
    (0, logging_1.info)('');
    (0, logging_1.info)('Template successfully generated!');
    return buildGenertedTemplateOutput(generatedTemplate, (await cfn.getGeneratedTemplate(templateArn)).TemplateBody, templateArn);
}
async function findLastSuccessfulScan(cfn, options) {
    let resourceScanSummaries = [];
    const clientRequestToken = `cdk-migrate-${options.environment.account}-${options.environment.region}`;
    if (options.fromScan === FromScan.NEW) {
        (0, logging_1.info)(`Starting new scan for account ${options.environment.account} in region ${options.environment.region}`);
        try {
            await cfn.startResourceScan(clientRequestToken);
            resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
        }
        catch (e) {
            // continuing here because if the scan fails on a new-scan it is very likely because there is either already a scan in progress
            // or the customer hit a rate limit. In either case we want to continue with the most recent scan.
            // If this happens to fail for a credential error then that will be caught immediately after anyway.
            (0, logging_1.info)(`Scan failed to start due to error '${e.message}', defaulting to latest scan.`);
        }
    }
    else {
        resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
        await cfn.checkForResourceScan(resourceScanSummaries, options, clientRequestToken);
    }
    // get the latest scan, which we know will exist
    resourceScanSummaries = (await cfn.listResourceScans()).ResourceScanSummaries;
    let scanId = resourceScanSummaries[0].ResourceScanId;
    // find the most recent scan that isn't in a failed state in case we didn't start a new one
    for (const summary of resourceScanSummaries) {
        if (summary.Status !== ScanStatus.FAILED) {
            scanId = summary.ResourceScanId;
            break;
        }
    }
    return scanId;
}
/**
 * Takes a string of filters in the format of key1=value1,key2=value2 and returns a map of the filters.
 *
 * @param filters a string of filters in the format of key1=value1,key2=value2
 * @returns a map of the filters
 */
function parseFilters(filters) {
    if (!filters) {
        return {
            'resource-identifier': undefined,
            'resource-type-prefix': undefined,
            'tag-key': undefined,
            'tag-value': undefined,
        };
    }
    const filterShorthands = {
        'identifier': FilterType.RESOURCE_IDENTIFIER,
        'id': FilterType.RESOURCE_IDENTIFIER,
        'type': FilterType.RESOURCE_TYPE_PREFIX,
        'type-prefix': FilterType.RESOURCE_TYPE_PREFIX,
    };
    const filterList = filters.split(',');
    let filterMap = {
        [FilterType.RESOURCE_IDENTIFIER]: undefined,
        [FilterType.RESOURCE_TYPE_PREFIX]: undefined,
        [FilterType.TAG_KEY]: undefined,
        [FilterType.TAG_VALUE]: undefined,
    };
    for (const fil of filterList) {
        const filter = fil.split('=');
        let filterKey = filter[0];
        const filterValue = filter[1];
        // if the key is a shorthand, replace it with the full name
        if (filterKey in filterShorthands) {
            filterKey = filterShorthands[filterKey];
        }
        if (Object.values(FilterType).includes(filterKey)) {
            filterMap[filterKey] = filterValue;
        }
        else {
            throw new error_1.ToolkitError(`Invalid filter: ${filterKey}`);
        }
    }
    return filterMap;
}
/**
 * Takes a list of any type and breaks it up into chunks of a specified size.
 *
 * @param list The list to break up
 * @param chunkSize The size of each chunk
 * @returns A list of lists of the specified size
 */
function chunks(list, chunkSize) {
    const chunkedList = [];
    for (let i = 0; i < list.length; i += chunkSize) {
        chunkedList.push(list.slice(i, i + chunkSize));
    }
    return chunkedList;
}
/**
 * Sets the account and region for making CloudFormation calls.
 * @param account The account to use
 * @param region The region to use
 * @returns The environment object
 */
function setEnvironment(account, region) {
    return {
        account: account !== null && account !== void 0 ? account : cx_api_1.UNKNOWN_ACCOUNT,
        region: region !== null && region !== void 0 ? region : cx_api_1.UNKNOWN_REGION,
        name: 'cdk-migrate-env',
    };
}
/**
 * Enum for the source options for the template
 */
var TemplateSourceOptions;
(function (TemplateSourceOptions) {
    TemplateSourceOptions["PATH"] = "path";
    TemplateSourceOptions["STACK"] = "stack";
    TemplateSourceOptions["SCAN"] = "scan";
})(TemplateSourceOptions || (exports.TemplateSourceOptions = TemplateSourceOptions = {}));
/**
 * Enum for the status of a resource scan
 */
var ScanStatus;
(function (ScanStatus) {
    ScanStatus["IN_PROGRESS"] = "IN_PROGRESS";
    ScanStatus["COMPLETE"] = "COMPLETE";
    ScanStatus["FAILED"] = "FAILED";
})(ScanStatus || (exports.ScanStatus = ScanStatus = {}));
var FilterType;
(function (FilterType) {
    FilterType["RESOURCE_IDENTIFIER"] = "resource-identifier";
    FilterType["RESOURCE_TYPE_PREFIX"] = "resource-type-prefix";
    FilterType["TAG_KEY"] = "tag-key";
    FilterType["TAG_VALUE"] = "tag-value";
})(FilterType || (exports.FilterType = FilterType = {}));
/**
 * Validates that exactly one source option has been provided.
 * @param fromPath The content of the flag `--from-path`
 * @param fromStack the content of the flag `--from-stack`
 */
function parseSourceOptions(fromPath, fromStack, stackName) {
    if (fromPath && fromStack) {
        throw new error_1.ToolkitError('Only one of `--from-path` or `--from-stack` may be provided.');
    }
    if (!stackName) {
        throw new error_1.ToolkitError('`--stack-name` is a required field.');
    }
    if (!fromPath && !fromStack) {
        return { source: TemplateSourceOptions.SCAN };
    }
    if (fromPath) {
        return { source: TemplateSourceOptions.PATH, templatePath: fromPath };
    }
    return { source: TemplateSourceOptions.STACK, stackName: stackName };
}
/**
 * Takes a set of resources and removes any with the managedbystack flag set to true.
 *
 * @param resourceList the list of resources provided by the list scanned resources calls
 * @returns a list of resources not managed by cfn stacks
 */
function excludeManaged(resourceList) {
    return resourceList
        .filter((r) => !r.ManagedByStack)
        .map((r) => ({
        ResourceType: r.ResourceType,
        ResourceIdentifier: r.ResourceIdentifier,
    }));
}
/**
 * Transforms a list of resources into a list of resource identifiers by removing the ManagedByStack flag.
 * Setting the value of the field to undefined effectively removes it from the object.
 *
 * @param resourceList the list of resources provided by the list scanned resources calls
 * @returns a list of ScannedResourceIdentifier[]
 */
function resourceIdentifiers(resourceList) {
    const identifiers = [];
    resourceList.forEach((r) => {
        const identifier = {
            ResourceType: r.ResourceType,
            ResourceIdentifier: r.ResourceIdentifier,
        };
        identifiers.push(identifier);
    });
    return identifiers;
}
/**
 * Takes a scan id and maintains a progress bar to display the progress of a scan to the user.
 *
 * @param scanId A string representing the scan id
 * @param cloudFormation The CloudFormation sdk client to use
 */
async function scanProgressBar(scanId, cfn) {
    var _a;
    let curProgress = 0.5;
    // we know it's in progress initially since we wouldn't have gotten here if it wasn't
    let curScan = {
        Status: ScanStatus.IN_PROGRESS,
        $metadata: {},
    };
    while (curScan.Status == ScanStatus.IN_PROGRESS) {
        curScan = await cfn.describeResourceScan(scanId);
        curProgress = (_a = curScan.PercentageCompleted) !== null && _a !== void 0 ? _a : curProgress;
        printBar(30, curProgress);
        await new Promise((resolve) => setTimeout(resolve, 2000));
    }
    (0, logging_1.info)('');
    (0, logging_1.info)('✅ Scan Complete!');
}
/**
 * Prints a progress bar to the console. To be used in a while loop to show progress of a long running task.
 * The progress bar deletes the current line on the console and rewrites it with the progress amount.
 *
 * @param width The width of the progress bar
 * @param progress The current progress to display as a percentage of 100
 */
function printBar(width, progress) {
    if (!process.env.MIGRATE_INTEG_TEST) {
        const FULL_BLOCK = '█';
        const PARTIAL_BLOCK = ['', '▏', '▎', '▍', '▌', '▋', '▊', '▉'];
        const fraction = Math.min(progress / 100, 1);
        const innerWidth = Math.max(1, width - 2);
        const chars = innerWidth * fraction;
        const remainder = chars - Math.floor(chars);
        const fullChars = FULL_BLOCK.repeat(Math.floor(chars));
        const partialChar = PARTIAL_BLOCK[Math.floor(remainder * PARTIAL_BLOCK.length)];
        const filler = '·'.repeat(innerWidth - Math.floor(chars) - (partialChar ? 1 : 0));
        const color = chalk.green;
        rewriteLine('[' + color(fullChars + partialChar) + filler + `] (${progress}%)`);
    }
}
/**
 * Prints a message to the console with a series periods appended to it. To be used in a while loop to show progress of a long running task.
 * The message deletes the current line and rewrites it several times to display 1-3 periods to show the user that the task is still running.
 *
 * @param message The message to display
 * @param timeoutx4 The amount of time to wait before printing the next period
 */
async function printDots(message, timeoutx4) {
    if (!process.env.MIGRATE_INTEG_TEST) {
        rewriteLine(message + ' .');
        await new Promise((resolve) => setTimeout(resolve, timeoutx4));
        rewriteLine(message + ' ..');
        await new Promise((resolve) => setTimeout(resolve, timeoutx4));
        rewriteLine(message + ' ...');
        await new Promise((resolve) => setTimeout(resolve, timeoutx4));
        rewriteLine(message);
        await new Promise((resolve) => setTimeout(resolve, timeoutx4));
    }
}
/**
 * Rewrites the current line on the console and writes a new message to it.
 * This is a helper funciton for printDots and printBar.
 *
 * @param message The message to display
 */
function rewriteLine(message) {
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
    process.stdout.write(message);
}
/**
 * Prints the time difference between two dates in days, hours, and minutes.
 *
 * @param time1 The first date to compare
 * @param time2 The second date to compare
 */
function displayTimeDiff(time1, time2) {
    const diff = Math.abs(time1.getTime() - time2.getTime());
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    (0, logging_1.info)(`Using the latest successful scan which is ${days} days, ${hours} hours, and ${minutes} minutes old.`);
}
/**
 * Writes a migrate.json file to the output directory.
 *
 * @param outputPath The path to write the migrate.json file to
 * @param stackName The name of the stack
 * @param generatedOutput The output of the template generator
 */
function writeMigrateJsonFile(outputPath, stackName, migrateJson) {
    const outputToJson = {
        '//': 'This file is generated by cdk migrate. It will be automatically deleted after the first successful deployment of this app to the environment of the original resources.',
        'Source': migrateJson.source,
        'Resources': migrateJson.resources,
    };
    fs.writeFileSync(`${path.join(outputPath !== null && outputPath !== void 0 ? outputPath : process.cwd(), stackName)}/migrate.json`, JSON.stringify(outputToJson, null, 2));
}
/**
 * Takes a string representing the from-scan flag and returns a FromScan enum value.
 *
 * @param scanType A string representing the from-scan flag
 * @returns A FromScan enum value
 */
function getMigrateScanType(scanType) {
    switch (scanType) {
        case 'new':
            return FromScan.NEW;
        case 'most-recent':
            return FromScan.MOST_RECENT;
        case '':
            return FromScan.DEFAULT;
        case undefined:
            return FromScan.DEFAULT;
        default:
            throw new error_1.ToolkitError(`Unknown scan type: ${scanType}`);
    }
}
/**
 * Takes a generatedTemplateOutput objct and returns a boolean representing whether there are any warnings on any rescources.
 *
 * @param generatedTemplateOutput A GenerateTemplateOutput object
 * @returns A boolean representing whether there are any warnings on any rescources
 */
function isThereAWarning(generatedTemplateOutput) {
    if (generatedTemplateOutput.resources) {
        for (const resource of generatedTemplateOutput.resources) {
            if (resource.Warnings && resource.Warnings.length > 0) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Builds the GenerateTemplateOutput object from the DescribeGeneratedTemplateOutput and the template body.
 *
 * @param generatedTemplateSummary The output of the describe generated template call
 * @param templateBody The body of the generated template
 * @returns A GenerateTemplateOutput object
 */
function buildGenertedTemplateOutput(generatedTemplateSummary, templateBody, source) {
    const resources = generatedTemplateSummary.Resources;
    const migrateJson = {
        templateBody: templateBody,
        source: source,
        resources: generatedTemplateSummary.Resources.map((r) => ({
            ResourceType: r.ResourceType,
            LogicalResourceId: r.LogicalResourceId,
            ResourceIdentifier: r.ResourceIdentifier,
        })),
    };
    const templateId = generatedTemplateSummary.GeneratedTemplateId;
    return {
        migrateJson: migrateJson,
        resources: resources,
        templateId: templateId,
    };
}
/**
 * Builds a CloudFormation sdk client for making requests with the CFN template generator.
 *
 * @param sdkProvider The sdk provider for making CloudFormation calls
 * @param environment The account and region where the stack is deployed
 * @returns A CloudFormation sdk client
 */
async function buildCfnClient(sdkProvider, environment) {
    const sdk = (await sdkProvider.forEnvironment(environment, 0)).sdk;
    sdk.appendCustomUserAgent('cdk-migrate');
    return sdk.cloudFormation();
}
/**
 * Appends a list of warnings to a readme file.
 *
 * @param filepath The path to the readme file
 * @param resources A list of resources to append warnings for
 */
function appendWarningsToReadme(filepath, resources) {
    const readme = fs.readFileSync(filepath, 'utf8');
    const lines = readme.split('\n');
    const index = lines.findIndex((line) => line.trim() === 'Enjoy!');
    let linesToAdd = ['\n## Warnings'];
    linesToAdd.push('### Write-only properties');
    linesToAdd.push("Write-only properties are resource property values that can be written to but can't be read by AWS CloudFormation or CDK Migrate. For more information, see [IaC generator and write-only properties](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/generate-IaC-write-only-properties.html).");
    linesToAdd.push('\n');
    linesToAdd.push('Write-only properties discovered during migration are organized here by resource ID and categorized by write-only property type. Resolve write-only properties by providing property values in your CDK app. For guidance, see [Resolve write-only properties](https://docs.aws.amazon.com/cdk/v2/guide/migrate.html#migrate-resources-writeonly).');
    for (const resource of resources) {
        if (resource.Warnings && resource.Warnings.length > 0) {
            linesToAdd.push(`### ${resource.LogicalResourceId}`);
            for (const warning of resource.Warnings) {
                linesToAdd.push(`- **${warning.Type}**: `);
                for (const property of warning.Properties) {
                    linesToAdd.push(`  - ${property.PropertyPath}: ${property.Description}`);
                }
            }
        }
    }
    lines.splice(index, 0, ...linesToAdd);
    fs.writeFileSync(filepath, lines.join('\n'));
}
/**
 * takes a list of resources and returns a list of unique resources based on the resource type and logical resource id.
 *
 * @param resources A list of resources to deduplicate
 * @returns A list of unique resources
 */
function deduplicateResources(resources) {
    let uniqueResources = {};
    for (const resource of resources) {
        const key = Object.keys(resource.ResourceIdentifier)[0];
        // Creating our unique identifier using the resource type, the key, and the value of the resource identifier
        // The resource identifier is a combination of a key value pair defined by a resource's schema, and the resource type of the resource.
        const uniqueIdentifer = `${resource.ResourceType}:${key}:${resource.ResourceIdentifier[key]}`;
        uniqueResources[uniqueIdentifer] = resource;
    }
    return Object.values(uniqueResources);
}
/**
 * Class for making CloudFormation template generator calls
 */
class CfnTemplateGeneratorProvider {
    constructor(cfn) {
        this.cfn = cfn;
    }
    async checkForResourceScan(resourceScanSummaries, options, clientRequestToken) {
        if (!resourceScanSummaries || resourceScanSummaries.length === 0) {
            if (options.fromScan === FromScan.MOST_RECENT) {
                throw new error_1.ToolkitError('No scans found. Please either start a new scan with the `--from-scan` new or do not specify a `--from-scan` option.');
            }
            else {
                (0, logging_1.info)('No scans found. Initiating a new resource scan.');
                await this.startResourceScan(clientRequestToken);
            }
        }
    }
    /**
     * Retrieves a tokenized list of resources and their associated scan. If a token is present the function
     * will loop through all pages and combine them into a single list of ScannedRelatedResources
     *
     * @param scanId scan id for the to list resources for
     * @param resources A list of resources to find related resources for
     */
    async getResourceScanRelatedResources(scanId, resources) {
        var _a, _b;
        let relatedResourceList = resources;
        // break the list of resources into chunks of 100 to avoid hitting the 100 resource limit
        for (const chunk of chunks(resources, 100)) {
            // get the first page of related resources
            const res = await this.cfn.listResourceScanRelatedResources({
                ResourceScanId: scanId,
                Resources: chunk,
            });
            // add the first page to the list
            relatedResourceList.push(...((_a = res.RelatedResources) !== null && _a !== void 0 ? _a : []));
            let nextToken = res.NextToken;
            // if there are more pages, cycle through them and add them to the list before moving on to the next chunk
            while (nextToken) {
                const nextRelatedResources = await this.cfn.listResourceScanRelatedResources({
                    ResourceScanId: scanId,
                    Resources: resourceIdentifiers(resources),
                    NextToken: nextToken,
                });
                nextToken = nextRelatedResources.NextToken;
                relatedResourceList.push(...((_b = nextRelatedResources.RelatedResources) !== null && _b !== void 0 ? _b : []));
            }
        }
        relatedResourceList = deduplicateResources(relatedResourceList);
        // prune the managedbystack flag off of them again.
        return process.env.MIGRATE_INTEG_TEST
            ? resourceIdentifiers(relatedResourceList)
            : resourceIdentifiers(excludeManaged(relatedResourceList));
    }
    /**
     * Kicks off a scan of a customers account, returning the scan id. A scan can take
     * 10 minutes or longer to complete. However this will return a scan id as soon as
     * the scan has begun.
     *
     * @returns A string representing the scan id
     */
    async startResourceScan(requestToken) {
        return (await this.cfn.startResourceScan({
            ClientRequestToken: requestToken,
        })).ResourceScanId;
    }
    /**
     * Gets the most recent scans a customer has completed
     *
     * @returns a list of resource scan summaries
     */
    async listResourceScans() {
        return this.cfn.listResourceScans();
    }
    /**
     * Retrieves a tokenized list of resources from a resource scan. If a token is present, this function
     * will loop through all pages and combine them into a single list of ScannedResource[].
     * Additionally will apply any filters provided by the customer.
     *
     * @param scanId scan id for the to list resources for
     * @param filters a string of filters in the format of key1=value1,key2=value2
     * @returns a combined list of all resources from the scan
     */
    async listResourceScanResources(scanId, filters = []) {
        var _a, _b, _c, _d;
        let resourceList = [];
        let resourceScanInputs;
        if (filters.length > 0) {
            (0, logging_1.info)('Applying filters to resource scan.');
            for (const filter of filters) {
                const filterList = parseFilters(filter);
                resourceScanInputs = {
                    ResourceScanId: scanId,
                    ResourceIdentifier: filterList[FilterType.RESOURCE_IDENTIFIER],
                    ResourceTypePrefix: filterList[FilterType.RESOURCE_TYPE_PREFIX],
                    TagKey: filterList[FilterType.TAG_KEY],
                    TagValue: filterList[FilterType.TAG_VALUE],
                };
                const resources = await this.cfn.listResourceScanResources(resourceScanInputs);
                resourceList = resourceList.concat((_a = resources.Resources) !== null && _a !== void 0 ? _a : []);
                let nextToken = resources.NextToken;
                // cycle through the pages adding all resources to the list until we run out of pages
                while (nextToken) {
                    resourceScanInputs.NextToken = nextToken;
                    const nextResources = await this.cfn.listResourceScanResources(resourceScanInputs);
                    nextToken = nextResources.NextToken;
                    resourceList = resourceList.concat((_b = nextResources.Resources) !== null && _b !== void 0 ? _b : []);
                }
            }
        }
        else {
            (0, logging_1.info)('No filters provided. Retrieving all resources from scan.');
            resourceScanInputs = {
                ResourceScanId: scanId,
            };
            const resources = await this.cfn.listResourceScanResources(resourceScanInputs);
            resourceList = resourceList.concat((_c = resources.Resources) !== null && _c !== void 0 ? _c : []);
            let nextToken = resources.NextToken;
            // cycle through the pages adding all resources to the list until we run out of pages
            while (nextToken) {
                resourceScanInputs.NextToken = nextToken;
                const nextResources = await this.cfn.listResourceScanResources(resourceScanInputs);
                nextToken = nextResources.NextToken;
                resourceList = resourceList.concat((_d = nextResources.Resources) !== null && _d !== void 0 ? _d : []);
            }
        }
        if (resourceList.length === 0) {
            throw new error_1.ToolkitError(`No resources found with filters ${filters.join(' ')}. Please try again with different filters.`);
        }
        resourceList = deduplicateResources(resourceList);
        return process.env.MIGRATE_INTEG_TEST
            ? resourceIdentifiers(resourceList)
            : resourceIdentifiers(excludeManaged(resourceList));
    }
    /**
     * Retrieves information about a resource scan.
     *
     * @param scanId scan id for the to list resources for
     * @returns information about the scan
     */
    async describeResourceScan(scanId) {
        return this.cfn.describeResourceScan({
            ResourceScanId: scanId,
        });
    }
    /**
     * Describes the current status of the template being generated.
     *
     * @param templateId A string representing the template id
     * @returns DescribeGeneratedTemplateOutput an object containing the template status and results
     */
    async describeGeneratedTemplate(templateId) {
        const generatedTemplate = await this.cfn.describeGeneratedTemplate({
            GeneratedTemplateName: templateId,
        });
        if (generatedTemplate.Status == ScanStatus.FAILED) {
            throw new error_1.ToolkitError(generatedTemplate.StatusReason);
        }
        return generatedTemplate;
    }
    /**
     * Retrieves a completed generated cloudformation template from the template generator.
     *
     * @param templateId A string representing the template id
     * @param cloudFormation The CloudFormation sdk client to use
     * @returns DescribeGeneratedTemplateOutput an object containing the template status and body
     */
    async getGeneratedTemplate(templateId) {
        return this.cfn.getGeneratedTemplate({
            GeneratedTemplateName: templateId,
        });
    }
    /**
     * Kicks off a template generation for a set of resources.
     *
     * @param stackName The name of the stack
     * @param resources A list of resources to generate the template from
     * @returns CreateGeneratedTemplateOutput an object containing the template arn to query on later
     */
    async createGeneratedTemplate(stackName, resources) {
        const createTemplateOutput = await this.cfn.createGeneratedTemplate({
            Resources: resources,
            GeneratedTemplateName: stackName,
        });
        if (createTemplateOutput.GeneratedTemplateId === undefined) {
            throw new error_1.ToolkitError('CreateGeneratedTemplate failed to return an Arn.');
        }
        return createTemplateOutput;
    }
    /**
     * Deletes a generated template from the template generator.
     *
     * @param templateArn The arn of the template to delete
     * @returns A promise that resolves when the template has been deleted
     */
    async deleteGeneratedTemplate(templateArn) {
        await this.cfn.deleteGeneratedTemplate({
            GeneratedTemplateName: templateArn,
        });
    }
}
exports.CfnTemplateGeneratorProvider = CfnTemplateGeneratorProvider;
/**
 * The possible ways to choose a scan to generate a CDK application from
 */
var FromScan;
(function (FromScan) {
    /**
     * Initiate a new resource scan to build the CDK application from.
     */
    FromScan[FromScan["NEW"] = 0] = "NEW";
    /**
     * Use the last successful scan to build the CDK application from. Will fail if no scan is found.
     */
    FromScan[FromScan["MOST_RECENT"] = 1] = "MOST_RECENT";
    /**
     * Starts a scan if none exists, otherwise uses the most recent successful scan to build the CDK application from.
     */
    FromScan[FromScan["DEFAULT"] = 2] = "DEFAULT";
})(FromScan || (exports.FromScan = FromScan = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWlncmF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1pZ3JhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBdUNBLHdDQXVEQztBQVNELHNDQU9DO0FBUUQsb0NBV0M7QUFVRCxzQ0FlQztBQVNELDRDQXNDQztBQWdHRCx3QkFNQztBQVFELHdDQU1DO0FBd0NELGdEQWNDO0FBMENELDBDQWVDO0FBU0QsNEJBaUJDO0FBU0QsOEJBY0M7QUFRRCxrQ0FJQztBQVFELDBDQVFDO0FBU0Qsb0RBY0M7QUFRRCxnREFhQztBQVFELDBDQVNDO0FBU0Qsa0VBcUJDO0FBU0Qsd0NBSUM7QUFRRCx3REEwQkM7QUFub0JELDBEQUEwRDtBQUMxRCx1REFBdUQ7QUFDdkQseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUU3Qiw0Q0FBK0U7QUFhL0UsNkNBQTZDO0FBQzdDLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsK0NBQXlDO0FBRXpDLG9EQUF5RDtBQUN6RCw0Q0FBZ0Q7QUFDaEQsa0NBQXVDO0FBQ3ZDLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN2QyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDekMsMEVBQTBFO0FBQzFFLE1BQU0sMkJBQTJCLEdBQXNCLFlBQVksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0FBRTFGOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUsY0FBYyxDQUNsQyxTQUFpQixFQUNqQixLQUFhLEVBQ2IsUUFBZ0IsRUFDaEIsVUFBbUIsRUFDbkIsUUFBa0I7SUFFbEIsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsYUFBVixVQUFVLGNBQVYsVUFBVSxHQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUM3RSxNQUFNLGtCQUFrQixHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUVqRCxJQUFJLENB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QUcsQ0FBQTtJQUVIOztPQUVHO0lBQ0gscURBQVcsQ0FBQTtJQUVYOztPQUVHO0lBQ0gsNkNBQU8sQ0FBQTtBQUNULENBQUMsRUFmVyxRQUFRLHdCQUFSLFFBQVEsUUFlbkIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzICovXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHR5cGUgeyBGb3JSZWFkaW5nIH0gZnJvbSAnQGF3cy1jZGsvY2xpLXBsdWdpbi1jb250cmFjdCc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudCwgVU5LTk9XTl9BQ0NPVU5ULCBVTktOT1dOX1JFR0lPTiB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgdHlwZSB7XG4gIERlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGVDb21tYW5kT3V0cHV0LFxuICBEZXNjcmliZVJlc291cmNlU2NhbkNvbW1hbmRPdXRwdXQsXG4gIEdldEdlbmVyYXRlZFRlbXBsYXRlQ29tbWFuZE91dHB1dCxcbiAgTGlzdFJlc291cmNlU2NhblJlc291cmNlc0NvbW1hbmRJbnB1dCxcbiAgUmVzb3VyY2VEZWZpbml0aW9uLFxuICBSZXNvdXJjZURldGFpbCxcbiAgUmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyeSxcbiAgUmVzb3VyY2VTY2FuU3VtbWFyeSxcbiAgU2Nhbm5lZFJlc291cmNlLFxuICBTY2FubmVkUmVzb3VyY2VJZGVudGlmaWVyLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0ICogYXMgY2RrX2Zyb21fY2ZuIGZyb20gJ2Nkay1mcm9tLWNmbic7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBjbGlJbml0IH0gZnJvbSAnLi4vLi4vbGliL2luaXQnO1xuaW1wb3J0IHsgaW5mbyB9IGZyb20gJy4uLy4uL2xpYi9sb2dnaW5nJztcbmltcG9ydCB0eXBlIHsgSUNsb3VkRm9ybWF0aW9uQ2xpZW50LCBTZGtQcm92aWRlciB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aCc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi4vYXBpL2RlcGxveW1lbnRzJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJy4uL3Rvb2xraXQvZXJyb3InO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vdXRpbCc7XG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdjYW1lbGNhc2UnKTtcbmNvbnN0IGRlY2FtZWxpemUgPSByZXF1aXJlKCdkZWNhbWVsaXplJyk7XG4vKiogVGhlIGxpc3Qgb2YgbGFuZ3VhZ2VzIHN1cHBvcnRlZCBieSB0aGUgYnVpbHQtaW4gbm9jdGlsdWNlbnQgYmluYXJ5LiAqL1xuY29uc3QgTUlHUkFURV9TVVBQT1JURURfTEFOR1VBR0VTOiByZWFkb25seSBzdHJpbmdbXSA9IGNka19mcm9tX2Nmbi5zdXBwb3J0ZWRfbGFuZ3VhZ2VzKCk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgQ0RLIGFwcCBmcm9tIGEgeWFtbCBvciBqc29uIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBzdGFjayBpbiB0aGUgZ2VuZXJhdGVkIGFwcFxuICogQHBhcmFtIHN0YWNrIFRoZSB5YW1sIG9yIGpzb24gdGVtcGxhdGUgZm9yIHRoZSBzdGFja1xuICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSB0byBnZW5lcmF0ZSB0aGUgQ0RLIGFwcCBpblxuICogQHBhcmFtIG91dHB1dFBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gZ2VuZXJhdGUgdGhlIENESyBhcHBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ2RrQXBwKFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgc3RhY2s6IHN0cmluZyxcbiAgbGFuZ3VhZ2U6IHN0cmluZyxcbiAgb3V0cHV0UGF0aD86IHN0cmluZyxcbiAgY29tcHJlc3M/OiBib29sZWFuLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlc29sdmVkT3V0cHV0UGF0aCA9IHBhdGguam9pbihvdXRwdXRQYXRoID8/IHByb2Nlc3MuY3dkKCksIHN0YWNrTmFtZSk7XG4gIGNvbnN0IGZvcm1hdHRlZFN0YWNrTmFtZSA9IGRlY2FtZWxpemUoc3RhY2tOYW1lKTtcblxuICB0cnkge1xuICAgIGZzLnJtU3luYyhyZXNvbHZlZE91dHB1dFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICBmcy5ta2RpclN5bmMocmVzb2x2ZWRPdXRwdXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBnZW5lcmF0ZU9ubHkgPSBjb21wcmVzcztcbiAgICBhd2FpdCBjbGlJbml0KHtcbiAgICAgIHR5cGU6ICdhcHAnLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBjYW5Vc2VOZXR3b3JrOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVPbmx5LFxuICAgICAgd29ya0RpcjogcmVzb2x2ZWRPdXRwdXRQYXRoLFxuICAgICAgc3RhY2tOYW1lLFxuICAgICAgbWlncmF0ZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGxldCBzdGFja0ZpbGVOYW1lOiBzdHJpbmc7XG4gICAgc3dpdGNoIChsYW5ndWFnZSkge1xuICAgICAgY2FzZSAndHlwZXNjcmlwdCc6XG4gICAgICAgIHN0YWNrRmlsZU5hbWUgPSBgJHtyZXNvbHZlZE91dHB1dFBhdGh9L2xpYi8ke2Zvcm1hdHRlZFN0YWNrTmFtZX0tc3RhY2sudHNgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2phdmEnOlxuICAgICAgICBzdGFja0ZpbGVOYW1lID0gYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS9zcmMvbWFpbi9qYXZhL2NvbS9teW9yZy8ke2NhbWVsQ2FzZShmb3JtYXR0ZWRTdGFja05hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KX1TdGFjay5qYXZhYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdweXRob24nOlxuICAgICAgICBzdGFja0ZpbGVOYW1lID0gYCR7cmVzb2x2ZWRPdXRwdXRQYXRofS8ke2Zvcm1hdHRlZFN0YWNrTmFtZS5yZXBsYWNlKC8tL2csICdfJyl9LyR7Zm9ybWF0dGVkU3RhY2tOYW1lLnJlcGxhY2UoLy0vZywgJ18nKX1fc3RhY2sucHlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NzaGFycCc6XG4gICAgICAgIHN0YWNrRmlsZU5hbWUgPSBgJHtyZXNvbHZlZE91dHB1dFBhdGh9L3NyYy8ke2NhbWVsQ2FzZShmb3JtYXR0ZWRTdGFja05hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KX0vJHtjYW1lbENhc2UoZm9ybWF0dGVkU3RhY2tOYW1lLCB7IHBhc2NhbENhc2U6IHRydWUgfSl9U3RhY2suY3NgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2dvJzpcbiAgICAgICAgc3RhY2tGaWxlTmFtZSA9IGAke3Jlc29sdmVkT3V0cHV0UGF0aH0vJHtmb3JtYXR0ZWRTdGFja05hbWV9LmdvYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgIGAke2xhbmd1YWdlfSBpcyBub3Qgc3VwcG9ydGVkIGJ5IENESyBNaWdyYXRlLiBQbGVhc2UgY2hvb3NlIGZyb206ICR7TUlHUkFURV9TVVBQT1JURURfTEFOR1VBR0VTLmpvaW4oJywgJyl9YCxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnMud3JpdGVGaWxlU3luYyhzdGFja0ZpbGVOYW1lLCBzdGFjayk7XG4gICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICBhd2FpdCB6aXBEaXJlY3RvcnkocmVzb2x2ZWRPdXRwdXRQYXRoLCBgJHtyZXNvbHZlZE91dHB1dFBhdGh9LnppcGApO1xuICAgICAgZnMucm1TeW5jKHJlc29sdmVkT3V0cHV0UGF0aCwgeyByZWN1cnNpdmU6IHRydWUsIGZvcmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBmcy5ybVN5bmMocmVzb2x2ZWRPdXRwdXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBDREsgc3RhY2sgZmlsZS5cbiAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgdG8gdHJhbnNsYXRlIGludG8gYSBDREsgc3RhY2tcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBzdGFja1xuICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSB0byBnZW5lcmF0ZSB0aGUgc3RhY2sgaW5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgQ0RLIHN0YWNrIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU3RhY2sodGVtcGxhdGU6IHN0cmluZywgc3RhY2tOYW1lOiBzdHJpbmcsIGxhbmd1YWdlOiBzdHJpbmcpIHtcbiAgY29uc3QgZm9ybWF0dGVkU3RhY2tOYW1lID0gYCR7Y2FtZWxDYXNlKGRlY2FtZWxpemUoc3RhY2tOYW1lKSwgeyBwYXNjYWxDYXNlOiB0cnVlIH0pfVN0YWNrYDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY2RrX2Zyb21fY2ZuLnRyYW5zbXV0ZSh0ZW1wbGF0ZSwgbGFuZ3VhZ2UsIGZvcm1hdHRlZFN0YWNrTmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke2Zvcm1hdHRlZFN0YWNrTmFtZX0gY291bGQgbm90IGJlIGdlbmVyYXRlZCBiZWNhdXNlICR7KGUgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFkcyBhbmQgcmV0dXJucyBhIHN0YWNrIHRlbXBsYXRlIGZyb20gYSBsb2NhbCBwYXRoLlxuICpcbiAqIEBwYXJhbSBpbnB1dFBhdGggVGhlIGxvY2F0aW9uIG9mIHRoZSB0ZW1wbGF0ZVxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRlbXBsYXRlIGlmIHByZXNlbnQsIG90aGVyd2lzZSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRGcm9tUGF0aChpbnB1dFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCByZWFkRmlsZTogc3RyaW5nO1xuICB0cnkge1xuICAgIHJlYWRGaWxlID0gZnMucmVhZEZpbGVTeW5jKGlucHV0UGF0aCwgJ3V0ZjgnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYCcke2lucHV0UGF0aH0nIGlzIG5vdCBhIHZhbGlkIHBhdGguYCk7XG4gIH1cbiAgaWYgKHJlYWRGaWxlID09ICcnKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQ2xvdWRmb3JtYXRpb24gdGVtcGxhdGUgZmlsZXBhdGg6ICcke2lucHV0UGF0aH0nIGlzIGFuIGVtcHR5IGZpbGUuYCk7XG4gIH1cbiAgcmV0dXJuIHJlYWRGaWxlO1xufVxuXG4vKipcbiAqIFJlYWRzIGFuZCByZXR1cm5zIGEgc3RhY2sgdGVtcGxhdGUgZnJvbSBhIGRlcGxveWVkIENsb3VkRm9ybWF0aW9uIHN0YWNrLlxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YWNrXG4gKiBAcGFyYW0gc2RrUHJvdmlkZXIgVGhlIHNkayBwcm92aWRlciBmb3IgbWFraW5nIENsb3VkRm9ybWF0aW9uIGNhbGxzXG4gKiBAcGFyYW0gZW52aXJvbm1lbnQgVGhlIGFjY291bnQgYW5kIHJlZ2lvbiB3aGVyZSB0aGUgc3RhY2sgaXMgZGVwbG95ZWRcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZW1wbGF0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2UgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkRnJvbVN0YWNrKFxuICBzdGFja05hbWU6IHN0cmluZyxcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICBlbnZpcm9ubWVudDogRW52aXJvbm1lbnQsXG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBjbG91ZEZvcm1hdGlvbiA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudChlbnZpcm9ubWVudCwgMCBzYXRpc2ZpZXMgRm9yUmVhZGluZykpLnNkay5jbG91ZEZvcm1hdGlvbigpO1xuXG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZSwgdHJ1ZSk7XG4gIGlmIChzdGFjay5zdGFja1N0YXR1cy5pc0RlcGxveVN1Y2Nlc3MgfHwgc3RhY2suc3RhY2tTdGF0dXMuaXNSb2xsYmFja1N1Y2Nlc3MpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXdhaXQgc3RhY2sudGVtcGxhdGUoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihcbiAgICAgIGBTdGFjayAnJHtzdGFja05hbWV9JyBpbiBhY2NvdW50ICR7ZW52aXJvbm1lbnQuYWNjb3VudH0gYW5kIHJlZ2lvbiAke2Vudmlyb25tZW50LnJlZ2lvbn0gaGFzIGEgc3RhdHVzIG9mICcke3N0YWNrLnN0YWNrU3RhdHVzLm5hbWV9JyBkdWUgdG8gJyR7c3RhY2suc3RhY2tTdGF0dXMucmVhc29ufScuIFRoZSBzdGFjayBjYW5ub3QgYmUgbWlncmF0ZWQgdW50aWwgaXQgaXMgaW4gYSBoZWFsdGh5IHN0YXRlLmAsXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIGluIGEgc3RhY2sgbmFtZSBhbmQgYWNjb3VudCBhbmQgcmVnaW9uIGFuZCByZXR1cm5zIGEgZ2VuZXJhdGVkIGNsb3VkZm9ybWF0aW9uIHRlbXBsYXRlIHVzaW5nIHRoZSBjbG91ZGZvcm1hdGlvblxuICogdGVtcGxhdGUgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhY2sgbmFtZSwgZmlsdGVycywgc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCBhbmQgbmV3U2NhbiBmbGFnXG4gKiBAcmV0dXJucyBhIGdlbmVyYXRlZCBjbG91ZGZvcm1hdGlvbiB0ZW1wbGF0ZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZW1wbGF0ZShvcHRpb25zOiBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucyk6IFByb21pc2U8R2VuZXJhdGVUZW1wbGF0ZU91dHB1dD4ge1xuICBjb25zdCBjZm4gPSBuZXcgQ2ZuVGVtcGxhdGVHZW5lcmF0b3JQcm92aWRlcihhd2FpdCBidWlsZENmbkNsaWVudChvcHRpb25zLnNka1Byb3ZpZGVyLCBvcHRpb25zLmVudmlyb25tZW50KSk7XG5cbiAgY29uc3Qgc2NhbklkID0gYXdhaXQgZmluZExhc3RTdWNjZXNzZnVsU2NhbihjZm4sIG9wdGlvbnMpO1xuXG4gIC8vIGlmIGEgY3VzdG9tZXIgYWNjaWRlbnRhbGx5IGN0cmwtYydzIG91dCBvZiB0aGUgY29tbWFuZCBhbmQgcnVucyBpdCBhZ2FpbiwgdGhpcyB3aWxsIGNvbnRpbnVlIHRoZSBwcm9ncmVzcyBiYXIgd2hlcmUgaXQgbGVmdCBvZmZcbiAgY29uc3QgY3VyU2NhbiA9IGF3YWl0IGNmbi5kZXNjcmliZVJlc291cmNlU2NhbihzY2FuSWQpO1xuICBpZiAoY3VyU2Nhbi5TdGF0dXMgPT0gU2NhblN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgIGluZm8oJ1Jlc291cmNlIHNjYW4gaW4gcHJvZ3Jlc3MuIFBsZWFzZSB3YWl0LCB0aGlzIGNhbiB0YWtlIDEwIG1pbnV0ZXMgb3IgbG9uZ2VyLicpO1xuICAgIGF3YWl0IHNjYW5Qcm9ncmVzc0JhcihzY2FuSWQsIGNmbik7XG4gIH1cblxuICBkaXNwbGF5VGltZURpZmYobmV3IERhdGUoKSwgbmV3IERhdGUoY3VyU2Nhbi5TdGFydFRpbWUhKSk7XG5cbiAgbGV0IHJlc291cmNlczogU2Nhbm5lZFJlc291cmNlW10gPSBhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhblJlc291cmNlcyhzY2FuSWQhLCBvcHRpb25zLmZpbHRlcnMpO1xuXG4gIGluZm8oJ2ZpbmRpbmcgcmVsYXRlZCByZXNvdXJjZXMuJyk7XG4gIGxldCByZWxhdGVkUmVzb3VyY2VzID0gYXdhaXQgY2ZuLmdldFJlc291cmNlU2NhblJlbGF0ZWRSZXNvdXJjZXMoc2NhbklkISwgcmVzb3VyY2VzKTtcblxuICBpbmZvKGBGb3VuZCAke3JlbGF0ZWRSZXNvdXJjZXMubGVuZ3RofSByZXNvdXJjZXMuYCk7XG5cbiAgaW5mbygnR2VuZXJhdGluZyBDRk4gdGVtcGxhdGUgZnJvbSBzY2FubmVkIHJlc291cmNlcy4nKTtcbiAgY29uc3QgdGVtcGxhdGVBcm4gPSAoYXdhaXQgY2ZuLmNyZWF0ZUdlbmVyYXRlZFRlbXBsYXRlKG9wdGlvbnMuc3RhY2tOYW1lLCByZWxhdGVkUmVzb3VyY2VzKSkuR2VuZXJhdGVkVGVtcGxhdGVJZCE7XG5cbiAgbGV0IGdlbmVyYXRlZFRlbXBsYXRlID0gYXdhaXQgY2ZuLmRlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGUodGVtcGxhdGVBcm4pO1xuXG4gIGluZm8oJ1BsZWFzZSB3YWl0LCB0ZW1wbGF0ZSBjcmVhdGlvbiBpbiBwcm9ncmVzcy4gVGhpcyBtYXkgdGFrZSBhIGNvdXBsZSBtaW51dGVzLicpO1xuICB3aGlsZSAoZ2VuZXJhdGVkVGVtcGxhdGUuU3RhdHVzICE9PSBTY2FuU3RhdHVzLkNPTVBMRVRFICYmIGdlbmVyYXRlZFRlbXBsYXRlLlN0YXR1cyAhPT0gU2NhblN0YXR1cy5GQUlMRUQpIHtcbiAgICBhd2FpdCBwcmludERvdHMoYFske2dlbmVyYXRlZFRlbXBsYXRlLlN0YXR1c31dIFRlbXBsYXRlIENyZWF0aW9uIGluIFByb2dyZXNzYCwgNDAwKTtcbiAgICBnZW5lcmF0ZWRUZW1wbGF0ZSA9IGF3YWl0IGNmbi5kZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlQXJuKTtcbiAgfVxuICBpbmZvKCcnKTtcbiAgaW5mbygnVGVtcGxhdGUgc3VjY2Vzc2Z1bGx5IGdlbmVyYXRlZCEnKTtcbiAgcmV0dXJuIGJ1aWxkR2VuZXJ0ZWRUZW1wbGF0ZU91dHB1dChcbiAgICBnZW5lcmF0ZWRUZW1wbGF0ZSxcbiAgICAoYXdhaXQgY2ZuLmdldEdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlQXJuKSkuVGVtcGxhdGVCb2R5ISxcbiAgICB0ZW1wbGF0ZUFybixcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZExhc3RTdWNjZXNzZnVsU2NhbihcbiAgY2ZuOiBDZm5UZW1wbGF0ZUdlbmVyYXRvclByb3ZpZGVyLFxuICBvcHRpb25zOiBHZW5lcmF0ZVRlbXBsYXRlT3B0aW9ucyxcbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGxldCByZXNvdXJjZVNjYW5TdW1tYXJpZXM6IFJlc291cmNlU2NhblN1bW1hcnlbXSB8IHVuZGVmaW5lZCA9IFtdO1xuICBjb25zdCBjbGllbnRSZXF1ZXN0VG9rZW4gPSBgY2RrLW1pZ3JhdGUtJHtvcHRpb25zLmVudmlyb25tZW50LmFjY291bnR9LSR7b3B0aW9ucy5lbnZpcm9ubWVudC5yZWdpb259YDtcbiAgaWYgKG9wdGlvbnMuZnJvbVNjYW4gPT09IEZyb21TY2FuLk5FVykge1xuICAgIGluZm8oYFN0YXJ0aW5nIG5ldyBzY2FuIGZvciBhY2NvdW50ICR7b3B0aW9ucy5lbnZpcm9ubWVudC5hY2NvdW50fSBpbiByZWdpb24gJHtvcHRpb25zLmVudmlyb25tZW50LnJlZ2lvbn1gKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2ZuLnN0YXJ0UmVzb3VyY2VTY2FuKGNsaWVudFJlcXVlc3RUb2tlbik7XG4gICAgICByZXNvdXJjZVNjYW5TdW1tYXJpZXMgPSAoYXdhaXQgY2ZuLmxpc3RSZXNvdXJjZVNjYW5zKCkpLlJlc291cmNlU2NhblN1bW1hcmllcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBjb250aW51aW5nIGhlcmUgYmVjYXVzZSBpZiB0aGUgc2NhbiBmYWlscyBvbiBhIG5ldy1zY2FuIGl0IGlzIHZlcnkgbGlrZWx5IGJlY2F1c2UgdGhlcmUgaXMgZWl0aGVyIGFscmVhZHkgYSBzY2FuIGluIHByb2dyZXNzXG4gICAgICAvLyBvciB0aGUgY3VzdG9tZXIgaGl0IGEgcmF0ZSBsaW1pdC4gSW4gZWl0aGVyIGNhc2Ugd2Ugd2FudCB0byBjb250aW51ZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBzY2FuLlxuICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIHRvIGZhaWwgZm9yIGEgY3JlZGVudGlhbCBlcnJvciB0aGVuIHRoYXQgd2lsbCBiZSBjYXVnaHQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55d2F5LlxuICAgICAgaW5mbyhgU2NhbiBmYWlsZWQgdG8gc3RhcnQgZHVlIHRvIGVycm9yICckeyhlIGFzIEVycm9yKS5tZXNzYWdlfScsIGRlZmF1bHRpbmcgdG8gbGF0ZXN0IHNjYW4uYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc291cmNlU2NhblN1bW1hcmllcyA9IChhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhbnMoKSkuUmVzb3VyY2VTY2FuU3VtbWFyaWVzO1xuICAgIGF3YWl0IGNmbi5jaGVja0ZvclJlc291cmNlU2NhbihyZXNvdXJjZVNjYW5TdW1tYXJpZXMsIG9wdGlvbnMsIGNsaWVudFJlcXVlc3RUb2tlbik7XG4gIH1cbiAgLy8gZ2V0IHRoZSBsYXRlc3Qgc2Nhbiwgd2hpY2ggd2Uga25vdyB3aWxsIGV4aXN0XG4gIHJlc291cmNlU2NhblN1bW1hcmllcyA9IChhd2FpdCBjZm4ubGlzdFJlc291cmNlU2NhbnMoKSkuUmVzb3VyY2VTY2FuU3VtbWFyaWVzO1xuICBsZXQgc2NhbklkOiBzdHJpbmcgfCB1bmRlZmluZWQgPSByZXNvdXJjZVNjYW5TdW1tYXJpZXMhWzBdLlJlc291cmNlU2NhbklkO1xuXG4gIC8vIGZpbmQgdGhlIG1vc3QgcmVjZW50IHNjYW4gdGhhdCBpc24ndCBpbiBhIGZhaWxlZCBzdGF0ZSBpbiBjYXNlIHdlIGRpZG4ndCBzdGFydCBhIG5ldyBvbmVcbiAgZm9yIChjb25zdCBzdW1tYXJ5IG9mIHJlc291cmNlU2NhblN1bW1hcmllcyEpIHtcbiAgICBpZiAoc3VtbWFyeS5TdGF0dXMgIT09IFNjYW5TdGF0dXMuRkFJTEVEKSB7XG4gICAgICBzY2FuSWQgPSBzdW1tYXJ5LlJlc291cmNlU2NhbklkITtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzY2FuSWQhO1xufVxuXG4vKipcbiAqIFRha2VzIGEgc3RyaW5nIG9mIGZpbHRlcnMgaW4gdGhlIGZvcm1hdCBvZiBrZXkxPXZhbHVlMSxrZXkyPXZhbHVlMiBhbmQgcmV0dXJucyBhIG1hcCBvZiB0aGUgZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0gZmlsdGVycyBhIHN0cmluZyBvZiBmaWx0ZXJzIGluIHRoZSBmb3JtYXQgb2Yga2V5MT12YWx1ZTEsa2V5Mj12YWx1ZTJcbiAqIEByZXR1cm5zIGEgbWFwIG9mIHRoZSBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyhmaWx0ZXJzOiBzdHJpbmcpOiB7XG4gIFtrZXkgaW4gRmlsdGVyVHlwZV06IHN0cmluZyB8IHVuZGVmaW5lZDtcbn0ge1xuICBpZiAoIWZpbHRlcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ3Jlc291cmNlLWlkZW50aWZpZXInOiB1bmRlZmluZWQsXG4gICAgICAncmVzb3VyY2UtdHlwZS1wcmVmaXgnOiB1bmRlZmluZWQsXG4gICAgICAndGFnLWtleSc6IHVuZGVmaW5lZCxcbiAgICAgICd0YWctdmFsdWUnOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlclNob3J0aGFuZHM6IHsgW2tleTogc3RyaW5nXTogRmlsdGVyVHlwZSB9ID0ge1xuICAgICdpZGVudGlmaWVyJzogRmlsdGVyVHlwZS5SRVNPVVJDRV9JREVOVElGSUVSLFxuICAgICdpZCc6IEZpbHRlclR5cGUuUkVTT1VSQ0VfSURFTlRJRklFUixcbiAgICAndHlwZSc6IEZpbHRlclR5cGUuUkVTT1VSQ0VfVFlQRV9QUkVGSVgsXG4gICAgJ3R5cGUtcHJlZml4JzogRmlsdGVyVHlwZS5SRVNPVVJDRV9UWVBFX1BSRUZJWCxcbiAgfTtcblxuICBjb25zdCBmaWx0ZXJMaXN0ID0gZmlsdGVycy5zcGxpdCgnLCcpO1xuXG4gIGxldCBmaWx0ZXJNYXA6IHsgW2tleSBpbiBGaWx0ZXJUeXBlXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gPSB7XG4gICAgW0ZpbHRlclR5cGUuUkVTT1VSQ0VfSURFTlRJRklFUl06IHVuZGVmaW5lZCxcbiAgICBbRmlsdGVyVHlwZS5SRVNPVVJDRV9UWVBFX1BSRUZJWF06IHVuZGVmaW5lZCxcbiAgICBbRmlsdGVyVHlwZS5UQUdfS0VZXTogdW5kZWZpbmVkLFxuICAgIFtGaWx0ZXJUeXBlLlRBR19WQUxVRV06IHVuZGVmaW5lZCxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGZpbCBvZiBmaWx0ZXJMaXN0KSB7XG4gICAgY29uc3QgZmlsdGVyID0gZmlsLnNwbGl0KCc9Jyk7XG4gICAgbGV0IGZpbHRlcktleSA9IGZpbHRlclswXTtcbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IGZpbHRlclsxXTtcbiAgICAvLyBpZiB0aGUga2V5IGlzIGEgc2hvcnRoYW5kLCByZXBsYWNlIGl0IHdpdGggdGhlIGZ1bGwgbmFtZVxuICAgIGlmIChmaWx0ZXJLZXkgaW4gZmlsdGVyU2hvcnRoYW5kcykge1xuICAgICAgZmlsdGVyS2V5ID0gZmlsdGVyU2hvcnRoYW5kc1tmaWx0ZXJLZXldO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhGaWx0ZXJUeXBlKS5pbmNsdWRlcyhmaWx0ZXJLZXkgYXMgYW55KSkge1xuICAgICAgZmlsdGVyTWFwW2ZpbHRlcktleSBhcyBrZXlvZiB0eXBlb2YgZmlsdGVyTWFwXSA9IGZpbHRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBJbnZhbGlkIGZpbHRlcjogJHtmaWx0ZXJLZXl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJNYXA7XG59XG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIGFueSB0eXBlIGFuZCBicmVha3MgaXQgdXAgaW50byBjaHVua3Mgb2YgYSBzcGVjaWZpZWQgc2l6ZS5cbiAqXG4gKiBAcGFyYW0gbGlzdCBUaGUgbGlzdCB0byBicmVhayB1cFxuICogQHBhcmFtIGNodW5rU2l6ZSBUaGUgc2l6ZSBvZiBlYWNoIGNodW5rXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgbGlzdHMgb2YgdGhlIHNwZWNpZmllZCBzaXplXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaHVua3MobGlzdDogYW55W10sIGNodW5rU2l6ZTogbnVtYmVyKTogYW55W11bXSB7XG4gIGNvbnN0IGNodW5rZWRMaXN0OiBhbnlbXVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgY2h1bmtlZExpc3QucHVzaChsaXN0LnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgfVxuICByZXR1cm4gY2h1bmtlZExpc3Q7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYWNjb3VudCBhbmQgcmVnaW9uIGZvciBtYWtpbmcgQ2xvdWRGb3JtYXRpb24gY2FsbHMuXG4gKiBAcGFyYW0gYWNjb3VudCBUaGUgYWNjb3VudCB0byB1c2VcbiAqIEBwYXJhbSByZWdpb24gVGhlIHJlZ2lvbiB0byB1c2VcbiAqIEByZXR1cm5zIFRoZSBlbnZpcm9ubWVudCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50KGFjY291bnQ/OiBzdHJpbmcsIHJlZ2lvbj86IHN0cmluZyk6IEVudmlyb25tZW50IHtcbiAgcmV0dXJuIHtcbiAgICBhY2NvdW50OiBhY2NvdW50ID8/IFVOS05PV05fQUNDT1VOVCxcbiAgICByZWdpb246IHJlZ2lvbiA/PyBVTktOT1dOX1JFR0lPTixcbiAgICBuYW1lOiAnY2RrLW1pZ3JhdGUtZW52JyxcbiAgfTtcbn1cblxuLyoqXG4gKiBFbnVtIGZvciB0aGUgc291cmNlIG9wdGlvbnMgZm9yIHRoZSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZW51bSBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMge1xuICBQQVRIID0gJ3BhdGgnLFxuICBTVEFDSyA9ICdzdGFjaycsXG4gIFNDQU4gPSAnc2NhbicsXG59XG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc291cmNlIG9mIGEgdGVtcGxhdGUuXG4gKi9cbnR5cGUgVGVtcGxhdGVTb3VyY2UgPVxuICB8IHsgc291cmNlOiBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuU0NBTiB9XG4gIHwgeyBzb3VyY2U6IFRlbXBsYXRlU291cmNlT3B0aW9ucy5QQVRIOyB0ZW1wbGF0ZVBhdGg6IHN0cmluZyB9XG4gIHwgeyBzb3VyY2U6IFRlbXBsYXRlU291cmNlT3B0aW9ucy5TVEFDSzsgc3RhY2tOYW1lOiBzdHJpbmcgfTtcblxuLyoqXG4gKiBFbnVtIGZvciB0aGUgc3RhdHVzIG9mIGEgcmVzb3VyY2Ugc2NhblxuICovXG5leHBvcnQgZW51bSBTY2FuU3RhdHVzIHtcbiAgSU5fUFJPR1JFU1MgPSAnSU5fUFJPR1JFU1MnLFxuICBDT01QTEVURSA9ICdDT01QTEVURScsXG4gIEZBSUxFRCA9ICdGQUlMRUQnLFxufVxuXG5leHBvcnQgZW51bSBGaWx0ZXJUeXBlIHtcbiAgUkVTT1VSQ0VfSURFTlRJRklFUiA9ICdyZXNvdXJjZS1pZGVudGlmaWVyJyxcbiAgUkVTT1VSQ0VfVFlQRV9QUkVGSVggPSAncmVzb3VyY2UtdHlwZS1wcmVmaXgnLFxuICBUQUdfS0VZID0gJ3RhZy1rZXknLFxuICBUQUdfVkFMVUUgPSAndGFnLXZhbHVlJyxcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBleGFjdGx5IG9uZSBzb3VyY2Ugb3B0aW9uIGhhcyBiZWVuIHByb3ZpZGVkLlxuICogQHBhcmFtIGZyb21QYXRoIFRoZSBjb250ZW50IG9mIHRoZSBmbGFnIGAtLWZyb20tcGF0aGBcbiAqIEBwYXJhbSBmcm9tU3RhY2sgdGhlIGNvbnRlbnQgb2YgdGhlIGZsYWcgYC0tZnJvbS1zdGFja2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU291cmNlT3B0aW9ucyhmcm9tUGF0aD86IHN0cmluZywgZnJvbVN0YWNrPzogYm9vbGVhbiwgc3RhY2tOYW1lPzogc3RyaW5nKTogVGVtcGxhdGVTb3VyY2Uge1xuICBpZiAoZnJvbVBhdGggJiYgZnJvbVN0YWNrKSB7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignT25seSBvbmUgb2YgYC0tZnJvbS1wYXRoYCBvciBgLS1mcm9tLXN0YWNrYCBtYXkgYmUgcHJvdmlkZWQuJyk7XG4gIH1cbiAgaWYgKCFzdGFja05hbWUpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdgLS1zdGFjay1uYW1lYCBpcyBhIHJlcXVpcmVkIGZpZWxkLicpO1xuICB9XG4gIGlmICghZnJvbVBhdGggJiYgIWZyb21TdGFjaykge1xuICAgIHJldHVybiB7IHNvdXJjZTogVGVtcGxhdGVTb3VyY2VPcHRpb25zLlNDQU4gfTtcbiAgfVxuICBpZiAoZnJvbVBhdGgpIHtcbiAgICByZXR1cm4geyBzb3VyY2U6IFRlbXBsYXRlU291cmNlT3B0aW9ucy5QQVRILCB0ZW1wbGF0ZVBhdGg6IGZyb21QYXRoIH07XG4gIH1cbiAgcmV0dXJuIHsgc291cmNlOiBUZW1wbGF0ZVNvdXJjZU9wdGlvbnMuU1RBQ0ssIHN0YWNrTmFtZTogc3RhY2tOYW1lISB9O1xufVxuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHJlc291cmNlcyBhbmQgcmVtb3ZlcyBhbnkgd2l0aCB0aGUgbWFuYWdlZGJ5c3RhY2sgZmxhZyBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiBAcGFyYW0gcmVzb3VyY2VMaXN0IHRoZSBsaXN0IG9mIHJlc291cmNlcyBwcm92aWRlZCBieSB0aGUgbGlzdCBzY2FubmVkIHJlc291cmNlcyBjYWxsc1xuICogQHJldHVybnMgYSBsaXN0IG9mIHJlc291cmNlcyBub3QgbWFuYWdlZCBieSBjZm4gc3RhY2tzXG4gKi9cbmZ1bmN0aW9uIGV4Y2x1ZGVNYW5hZ2VkKHJlc291cmNlTGlzdDogU2Nhbm5lZFJlc291cmNlW10pOiBTY2FubmVkUmVzb3VyY2VJZGVudGlmaWVyW10ge1xuICByZXR1cm4gcmVzb3VyY2VMaXN0XG4gICAgLmZpbHRlcigocikgPT4gIXIuTWFuYWdlZEJ5U3RhY2spXG4gICAgLm1hcCgocikgPT4gKHtcbiAgICAgIFJlc291cmNlVHlwZTogci5SZXNvdXJjZVR5cGUhLFxuICAgICAgUmVzb3VyY2VJZGVudGlmaWVyOiByLlJlc291cmNlSWRlbnRpZmllciEsXG4gICAgfSkpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBsaXN0IG9mIHJlc291cmNlcyBpbnRvIGEgbGlzdCBvZiByZXNvdXJjZSBpZGVudGlmaWVycyBieSByZW1vdmluZyB0aGUgTWFuYWdlZEJ5U3RhY2sgZmxhZy5cbiAqIFNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCB0byB1bmRlZmluZWQgZWZmZWN0aXZlbHkgcmVtb3ZlcyBpdCBmcm9tIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHJlc291cmNlTGlzdCB0aGUgbGlzdCBvZiByZXNvdXJjZXMgcHJvdmlkZWQgYnkgdGhlIGxpc3Qgc2Nhbm5lZCByZXNvdXJjZXMgY2FsbHNcbiAqIEByZXR1cm5zIGEgbGlzdCBvZiBTY2FubmVkUmVzb3VyY2VJZGVudGlmaWVyW11cbiAqL1xuZnVuY3Rpb24gcmVzb3VyY2VJZGVudGlmaWVycyhyZXNvdXJjZUxpc3Q6IFNjYW5uZWRSZXNvdXJjZVtdKTogU2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcltdIHtcbiAgY29uc3QgaWRlbnRpZmllcnM6IFNjYW5uZWRSZXNvdXJjZUlkZW50aWZpZXJbXSA9IFtdO1xuICByZXNvdXJjZUxpc3QuZm9yRWFjaCgocikgPT4ge1xuICAgIGNvbnN0IGlkZW50aWZpZXI6IFNjYW5uZWRSZXNvdXJjZUlkZW50aWZpZXIgPSB7XG4gICAgICBSZXNvdXJjZVR5cGU6IHIuUmVzb3VyY2VUeXBlISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogci5SZXNvdXJjZUlkZW50aWZpZXIhLFxuICAgIH07XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfSk7XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHNjYW4gaWQgYW5kIG1haW50YWlucyBhIHByb2dyZXNzIGJhciB0byBkaXNwbGF5IHRoZSBwcm9ncmVzcyBvZiBhIHNjYW4gdG8gdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHNjYW5JZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNjYW4gaWRcbiAqIEBwYXJhbSBjbG91ZEZvcm1hdGlvbiBUaGUgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudCB0byB1c2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNjYW5Qcm9ncmVzc0JhcihzY2FuSWQ6IHN0cmluZywgY2ZuOiBDZm5UZW1wbGF0ZUdlbmVyYXRvclByb3ZpZGVyKSB7XG4gIGxldCBjdXJQcm9ncmVzcyA9IDAuNTtcbiAgLy8gd2Uga25vdyBpdCdzIGluIHByb2dyZXNzIGluaXRpYWxseSBzaW5jZSB3ZSB3b3VsZG4ndCBoYXZlIGdvdHRlbiBoZXJlIGlmIGl0IHdhc24ndFxuICBsZXQgY3VyU2NhbjogRGVzY3JpYmVSZXNvdXJjZVNjYW5Db21tYW5kT3V0cHV0ID0ge1xuICAgIFN0YXR1czogU2NhblN0YXR1cy5JTl9QUk9HUkVTUyxcbiAgICAkbWV0YWRhdGE6IHt9LFxuICB9O1xuICB3aGlsZSAoY3VyU2Nhbi5TdGF0dXMgPT0gU2NhblN0YXR1cy5JTl9QUk9HUkVTUykge1xuICAgIGN1clNjYW4gPSBhd2FpdCBjZm4uZGVzY3JpYmVSZXNvdXJjZVNjYW4oc2NhbklkKTtcbiAgICBjdXJQcm9ncmVzcyA9IGN1clNjYW4uUGVyY2VudGFnZUNvbXBsZXRlZCA/PyBjdXJQcm9ncmVzcztcbiAgICBwcmludEJhcigzMCwgY3VyUHJvZ3Jlc3MpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcbiAgfVxuICBpbmZvKCcnKTtcbiAgaW5mbygn4pyFIFNjYW4gQ29tcGxldGUhJyk7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgcHJvZ3Jlc3MgYmFyIHRvIHRoZSBjb25zb2xlLiBUbyBiZSB1c2VkIGluIGEgd2hpbGUgbG9vcCB0byBzaG93IHByb2dyZXNzIG9mIGEgbG9uZyBydW5uaW5nIHRhc2suXG4gKiBUaGUgcHJvZ3Jlc3MgYmFyIGRlbGV0ZXMgdGhlIGN1cnJlbnQgbGluZSBvbiB0aGUgY29uc29sZSBhbmQgcmV3cml0ZXMgaXQgd2l0aCB0aGUgcHJvZ3Jlc3MgYW1vdW50LlxuICpcbiAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHByb2dyZXNzIGJhclxuICogQHBhcmFtIHByb2dyZXNzIFRoZSBjdXJyZW50IHByb2dyZXNzIHRvIGRpc3BsYXkgYXMgYSBwZXJjZW50YWdlIG9mIDEwMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRCYXIod2lkdGg6IG51bWJlciwgcHJvZ3Jlc3M6IG51bWJlcikge1xuICBpZiAoIXByb2Nlc3MuZW52Lk1JR1JBVEVfSU5URUdfVEVTVCkge1xuICAgIGNvbnN0IEZVTExfQkxPQ0sgPSAn4paIJztcbiAgICBjb25zdCBQQVJUSUFMX0JMT0NLID0gWycnLCAn4paPJywgJ+KWjicsICfilo0nLCAn4paMJywgJ+KWiycsICfiloonLCAn4paJJ107XG4gICAgY29uc3QgZnJhY3Rpb24gPSBNYXRoLm1pbihwcm9ncmVzcyAvIDEwMCwgMSk7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IE1hdGgubWF4KDEsIHdpZHRoIC0gMik7XG4gICAgY29uc3QgY2hhcnMgPSBpbm5lcldpZHRoICogZnJhY3Rpb247XG4gICAgY29uc3QgcmVtYWluZGVyID0gY2hhcnMgLSBNYXRoLmZsb29yKGNoYXJzKTtcblxuICAgIGNvbnN0IGZ1bGxDaGFycyA9IEZVTExfQkxPQ0sucmVwZWF0KE1hdGguZmxvb3IoY2hhcnMpKTtcbiAgICBjb25zdCBwYXJ0aWFsQ2hhciA9IFBBUlRJQUxfQkxPQ0tbTWF0aC5mbG9vcihyZW1haW5kZXIgKiBQQVJUSUFMX0JMT0NLLmxlbmd0aCldO1xuICAgIGNvbnN0IGZpbGxlciA9ICfCtycucmVwZWF0KGlubmVyV2lkdGggLSBNYXRoLmZsb29yKGNoYXJzKSAtIChwYXJ0aWFsQ2hhciA/IDEgOiAwKSk7XG5cbiAgICBjb25zdCBjb2xvciA9IGNoYWxrLmdyZWVuO1xuXG4gICAgcmV3cml0ZUxpbmUoJ1snICsgY29sb3IoZnVsbENoYXJzICsgcGFydGlhbENoYXIpICsgZmlsbGVyICsgYF0gKCR7cHJvZ3Jlc3N9JSlgKTtcbiAgfVxufVxuXG4vKipcbiAqIFByaW50cyBhIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUgd2l0aCBhIHNlcmllcyBwZXJpb2RzIGFwcGVuZGVkIHRvIGl0LiBUbyBiZSB1c2VkIGluIGEgd2hpbGUgbG9vcCB0byBzaG93IHByb2dyZXNzIG9mIGEgbG9uZyBydW5uaW5nIHRhc2suXG4gKiBUaGUgbWVzc2FnZSBkZWxldGVzIHRoZSBjdXJyZW50IGxpbmUgYW5kIHJld3JpdGVzIGl0IHNldmVyYWwgdGltZXMgdG8gZGlzcGxheSAxLTMgcGVyaW9kcyB0byBzaG93IHRoZSB1c2VyIHRoYXQgdGhlIHRhc2sgaXMgc3RpbGwgcnVubmluZy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5XG4gKiBAcGFyYW0gdGltZW91dHg0IFRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGJlZm9yZSBwcmludGluZyB0aGUgbmV4dCBwZXJpb2RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByaW50RG90cyhtZXNzYWdlOiBzdHJpbmcsIHRpbWVvdXR4NDogbnVtYmVyKSB7XG4gIGlmICghcHJvY2Vzcy5lbnYuTUlHUkFURV9JTlRFR19URVNUKSB7XG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSArICcgLicpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXR4NCkpO1xuXG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSArICcgLi4nKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0eDQpKTtcblxuICAgIHJld3JpdGVMaW5lKG1lc3NhZ2UgKyAnIC4uLicpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXR4NCkpO1xuXG4gICAgcmV3cml0ZUxpbmUobWVzc2FnZSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dHg0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXdyaXRlcyB0aGUgY3VycmVudCBsaW5lIG9uIHRoZSBjb25zb2xlIGFuZCB3cml0ZXMgYSBuZXcgbWVzc2FnZSB0byBpdC5cbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY2l0b24gZm9yIHByaW50RG90cyBhbmQgcHJpbnRCYXIuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV3cml0ZUxpbmUobWVzc2FnZTogc3RyaW5nKSB7XG4gIHByb2Nlc3Muc3Rkb3V0LmNsZWFyTGluZSgwKTtcbiAgcHJvY2Vzcy5zdGRvdXQuY3Vyc29yVG8oMCk7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIFByaW50cyB0aGUgdGltZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIGRhdGVzIGluIGRheXMsIGhvdXJzLCBhbmQgbWludXRlcy5cbiAqXG4gKiBAcGFyYW0gdGltZTEgVGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIHRpbWUyIFRoZSBzZWNvbmQgZGF0ZSB0byBjb21wYXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5VGltZURpZmYodGltZTE6IERhdGUsIHRpbWUyOiBEYXRlKTogdm9pZCB7XG4gIGNvbnN0IGRpZmYgPSBNYXRoLmFicyh0aW1lMS5nZXRUaW1lKCkgLSB0aW1lMi5nZXRUaW1lKCkpO1xuXG4gIGNvbnN0IGRheXMgPSBNYXRoLmZsb29yKGRpZmYgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICBjb25zdCBob3VycyA9IE1hdGguZmxvb3IoKGRpZmYgJSAoMTAwMCAqIDYwICogNjAgKiAyNCkpIC8gKDEwMDAgKiA2MCAqIDYwKSk7XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChkaWZmICUgKDEwMDAgKiA2MCAqIDYwKSkgLyAoMTAwMCAqIDYwKSk7XG5cbiAgaW5mbyhgVXNpbmcgdGhlIGxhdGVzdCBzdWNjZXNzZnVsIHNjYW4gd2hpY2ggaXMgJHtkYXlzfSBkYXlzLCAke2hvdXJzfSBob3VycywgYW5kICR7bWludXRlc30gbWludXRlcyBvbGQuYCk7XG59XG5cbi8qKlxuICogV3JpdGVzIGEgbWlncmF0ZS5qc29uIGZpbGUgdG8gdGhlIG91dHB1dCBkaXJlY3RvcnkuXG4gKlxuICogQHBhcmFtIG91dHB1dFBhdGggVGhlIHBhdGggdG8gd3JpdGUgdGhlIG1pZ3JhdGUuanNvbiBmaWxlIHRvXG4gKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGFja1xuICogQHBhcmFtIGdlbmVyYXRlZE91dHB1dCBUaGUgb3V0cHV0IG9mIHRoZSB0ZW1wbGF0ZSBnZW5lcmF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlTWlncmF0ZUpzb25GaWxlKFxuICBvdXRwdXRQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuICBtaWdyYXRlSnNvbjogTWlncmF0ZUpzb25Gb3JtYXQsXG4pIHtcbiAgY29uc3Qgb3V0cHV0VG9Kc29uID0ge1xuICAgICcvLyc6ICdUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNkayBtaWdyYXRlLiBJdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGVsZXRlZCBhZnRlciB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBkZXBsb3ltZW50IG9mIHRoaXMgYXBwIHRvIHRoZSBlbnZpcm9ubWVudCBvZiB0aGUgb3JpZ2luYWwgcmVzb3VyY2VzLicsXG4gICAgJ1NvdXJjZSc6IG1pZ3JhdGVKc29uLnNvdXJjZSxcbiAgICAnUmVzb3VyY2VzJzogbWlncmF0ZUpzb24ucmVzb3VyY2VzLFxuICB9O1xuICBmcy53cml0ZUZpbGVTeW5jKFxuICAgIGAke3BhdGguam9pbihvdXRwdXRQYXRoID8/IHByb2Nlc3MuY3dkKCksIHN0YWNrTmFtZSl9L21pZ3JhdGUuanNvbmAsXG4gICAgSlNPTi5zdHJpbmdpZnkob3V0cHV0VG9Kc29uLCBudWxsLCAyKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyb20tc2NhbiBmbGFnIGFuZCByZXR1cm5zIGEgRnJvbVNjYW4gZW51bSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc2NhblR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmcm9tLXNjYW4gZmxhZ1xuICogQHJldHVybnMgQSBGcm9tU2NhbiBlbnVtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaWdyYXRlU2NhblR5cGUoc2NhblR5cGU6IHN0cmluZykge1xuICBzd2l0Y2ggKHNjYW5UeXBlKSB7XG4gICAgY2FzZSAnbmV3JzpcbiAgICAgIHJldHVybiBGcm9tU2Nhbi5ORVc7XG4gICAgY2FzZSAnbW9zdC1yZWNlbnQnOlxuICAgICAgcmV0dXJuIEZyb21TY2FuLk1PU1RfUkVDRU5UO1xuICAgIGNhc2UgJyc6XG4gICAgICByZXR1cm4gRnJvbVNjYW4uREVGQVVMVDtcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIHJldHVybiBGcm9tU2Nhbi5ERUZBVUxUO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBVbmtub3duIHNjYW4gdHlwZTogJHtzY2FuVHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIGEgZ2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQgb2JqY3QgYW5kIHJldHVybnMgYSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgd2FybmluZ3Mgb24gYW55IHJlc2NvdXJjZXMuXG4gKlxuICogQHBhcmFtIGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0IEEgR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCBvYmplY3RcbiAqIEByZXR1cm5zIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciB0aGVyZSBhcmUgYW55IHdhcm5pbmdzIG9uIGFueSByZXNjb3VyY2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RoZXJlQVdhcm5pbmcoZ2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQ6IEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQpIHtcbiAgaWYgKGdlbmVyYXRlZFRlbXBsYXRlT3V0cHV0LnJlc291cmNlcykge1xuICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgZ2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQucmVzb3VyY2VzKSB7XG4gICAgICBpZiAocmVzb3VyY2UuV2FybmluZ3MgJiYgcmVzb3VyY2UuV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCBvYmplY3QgZnJvbSB0aGUgRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCBhbmQgdGhlIHRlbXBsYXRlIGJvZHkuXG4gKlxuICogQHBhcmFtIGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeSBUaGUgb3V0cHV0IG9mIHRoZSBkZXNjcmliZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2FsbFxuICogQHBhcmFtIHRlbXBsYXRlQm9keSBUaGUgYm9keSBvZiB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlXG4gKiBAcmV0dXJucyBBIEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdlbmVydGVkVGVtcGxhdGVPdXRwdXQoXG4gIGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeTogRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZUNvbW1hbmRPdXRwdXQsXG4gIHRlbXBsYXRlQm9keTogc3RyaW5nLFxuICBzb3VyY2U6IHN0cmluZyxcbik6IEdlbmVyYXRlVGVtcGxhdGVPdXRwdXQge1xuICBjb25zdCByZXNvdXJjZXM6IFJlc291cmNlRGV0YWlsW10gfCB1bmRlZmluZWQgPSBnZW5lcmF0ZWRUZW1wbGF0ZVN1bW1hcnkuUmVzb3VyY2VzO1xuICBjb25zdCBtaWdyYXRlSnNvbjogTWlncmF0ZUpzb25Gb3JtYXQgPSB7XG4gICAgdGVtcGxhdGVCb2R5OiB0ZW1wbGF0ZUJvZHksXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgcmVzb3VyY2VzOiBnZW5lcmF0ZWRUZW1wbGF0ZVN1bW1hcnkuUmVzb3VyY2VzIS5tYXAoKHIpID0+ICh7XG4gICAgICBSZXNvdXJjZVR5cGU6IHIuUmVzb3VyY2VUeXBlISxcbiAgICAgIExvZ2ljYWxSZXNvdXJjZUlkOiByLkxvZ2ljYWxSZXNvdXJjZUlkISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogci5SZXNvdXJjZUlkZW50aWZpZXIhLFxuICAgIH0pKSxcbiAgfTtcbiAgY29uc3QgdGVtcGxhdGVJZCA9IGdlbmVyYXRlZFRlbXBsYXRlU3VtbWFyeS5HZW5lcmF0ZWRUZW1wbGF0ZUlkITtcbiAgcmV0dXJuIHtcbiAgICBtaWdyYXRlSnNvbjogbWlncmF0ZUpzb24sXG4gICAgcmVzb3VyY2VzOiByZXNvdXJjZXMsXG4gICAgdGVtcGxhdGVJZDogdGVtcGxhdGVJZCxcbiAgfTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBDbG91ZEZvcm1hdGlvbiBzZGsgY2xpZW50IGZvciBtYWtpbmcgcmVxdWVzdHMgd2l0aCB0aGUgQ0ZOIHRlbXBsYXRlIGdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gc2RrUHJvdmlkZXIgVGhlIHNkayBwcm92aWRlciBmb3IgbWFraW5nIENsb3VkRm9ybWF0aW9uIGNhbGxzXG4gKiBAcGFyYW0gZW52aXJvbm1lbnQgVGhlIGFjY291bnQgYW5kIHJlZ2lvbiB3aGVyZSB0aGUgc3RhY2sgaXMgZGVwbG95ZWRcbiAqIEByZXR1cm5zIEEgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYnVpbGRDZm5DbGllbnQoc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudDogRW52aXJvbm1lbnQpIHtcbiAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KGVudmlyb25tZW50LCAwIHNhdGlzZmllcyBGb3JSZWFkaW5nKSkuc2RrO1xuICBzZGsuYXBwZW5kQ3VzdG9tVXNlckFnZW50KCdjZGstbWlncmF0ZScpO1xuICByZXR1cm4gc2RrLmNsb3VkRm9ybWF0aW9uKCk7XG59XG5cbi8qKlxuICogQXBwZW5kcyBhIGxpc3Qgb2Ygd2FybmluZ3MgdG8gYSByZWFkbWUgZmlsZS5cbiAqXG4gKiBAcGFyYW0gZmlsZXBhdGggVGhlIHBhdGggdG8gdGhlIHJlYWRtZSBmaWxlXG4gKiBAcGFyYW0gcmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8gYXBwZW5kIHdhcm5pbmdzIGZvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kV2FybmluZ3NUb1JlYWRtZShmaWxlcGF0aDogc3RyaW5nLCByZXNvdXJjZXM6IFJlc291cmNlRGV0YWlsW10pIHtcbiAgY29uc3QgcmVhZG1lID0gZnMucmVhZEZpbGVTeW5jKGZpbGVwYXRoLCAndXRmOCcpO1xuICBjb25zdCBsaW5lcyA9IHJlYWRtZS5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGluZGV4ID0gbGluZXMuZmluZEluZGV4KChsaW5lKSA9PiBsaW5lLnRyaW0oKSA9PT0gJ0Vuam95IScpO1xuICBsZXQgbGluZXNUb0FkZCA9IFsnXFxuIyMgV2FybmluZ3MnXTtcbiAgbGluZXNUb0FkZC5wdXNoKCcjIyMgV3JpdGUtb25seSBwcm9wZXJ0aWVzJyk7XG4gIGxpbmVzVG9BZGQucHVzaChcbiAgICBcIldyaXRlLW9ubHkgcHJvcGVydGllcyBhcmUgcmVzb3VyY2UgcHJvcGVydHkgdmFsdWVzIHRoYXQgY2FuIGJlIHdyaXR0ZW4gdG8gYnV0IGNhbid0IGJlIHJlYWQgYnkgQVdTIENsb3VkRm9ybWF0aW9uIG9yIENESyBNaWdyYXRlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIFtJYUMgZ2VuZXJhdG9yIGFuZCB3cml0ZS1vbmx5IHByb3BlcnRpZXNdKGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BV1NDbG91ZEZvcm1hdGlvbi9sYXRlc3QvVXNlckd1aWRlL2dlbmVyYXRlLUlhQy13cml0ZS1vbmx5LXByb3BlcnRpZXMuaHRtbCkuXCIsXG4gICk7XG4gIGxpbmVzVG9BZGQucHVzaCgnXFxuJyk7XG4gIGxpbmVzVG9BZGQucHVzaChcbiAgICAnV3JpdGUtb25seSBwcm9wZXJ0aWVzIGRpc2NvdmVyZWQgZHVyaW5nIG1pZ3JhdGlvbiBhcmUgb3JnYW5pemVkIGhlcmUgYnkgcmVzb3VyY2UgSUQgYW5kIGNhdGVnb3JpemVkIGJ5IHdyaXRlLW9ubHkgcHJvcGVydHkgdHlwZS4gUmVzb2x2ZSB3cml0ZS1vbmx5IHByb3BlcnRpZXMgYnkgcHJvdmlkaW5nIHByb3BlcnR5IHZhbHVlcyBpbiB5b3VyIENESyBhcHAuIEZvciBndWlkYW5jZSwgc2VlIFtSZXNvbHZlIHdyaXRlLW9ubHkgcHJvcGVydGllc10oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9taWdyYXRlLmh0bWwjbWlncmF0ZS1yZXNvdXJjZXMtd3JpdGVvbmx5KS4nLFxuICApO1xuICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIHJlc291cmNlcykge1xuICAgIGlmIChyZXNvdXJjZS5XYXJuaW5ncyAmJiByZXNvdXJjZS5XYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lc1RvQWRkLnB1c2goYCMjIyAke3Jlc291cmNlLkxvZ2ljYWxSZXNvdXJjZUlkfWApO1xuICAgICAgZm9yIChjb25zdCB3YXJuaW5nIG9mIHJlc291cmNlLldhcm5pbmdzKSB7XG4gICAgICAgIGxpbmVzVG9BZGQucHVzaChgLSAqKiR7d2FybmluZy5UeXBlfSoqOiBgKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB3YXJuaW5nLlByb3BlcnRpZXMhKSB7XG4gICAgICAgICAgbGluZXNUb0FkZC5wdXNoKGAgIC0gJHtwcm9wZXJ0eS5Qcm9wZXJ0eVBhdGh9OiAke3Byb3BlcnR5LkRlc2NyaXB0aW9ufWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbmVzLnNwbGljZShpbmRleCwgMCwgLi4ubGluZXNUb0FkZCk7XG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZXBhdGgsIGxpbmVzLmpvaW4oJ1xcbicpKTtcbn1cblxuLyoqXG4gKiB0YWtlcyBhIGxpc3Qgb2YgcmVzb3VyY2VzIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB1bmlxdWUgcmVzb3VyY2VzIGJhc2VkIG9uIHRoZSByZXNvdXJjZSB0eXBlIGFuZCBsb2dpY2FsIHJlc291cmNlIGlkLlxuICpcbiAqIEBwYXJhbSByZXNvdXJjZXMgQSBsaXN0IG9mIHJlc291cmNlcyB0byBkZWR1cGxpY2F0ZVxuICogQHJldHVybnMgQSBsaXN0IG9mIHVuaXF1ZSByZXNvdXJjZXNcbiAqL1xuZnVuY3Rpb24gZGVkdXBsaWNhdGVSZXNvdXJjZXMocmVzb3VyY2VzOiBSZXNvdXJjZURldGFpbFtdKSB7XG4gIGxldCB1bmlxdWVSZXNvdXJjZXM6IHsgW2tleTogc3RyaW5nXTogUmVzb3VyY2VEZXRhaWwgfSA9IHt9O1xuXG4gIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMocmVzb3VyY2UuUmVzb3VyY2VJZGVudGlmaWVyISlbMF07XG5cbiAgICAvLyBDcmVhdGluZyBvdXIgdW5pcXVlIGlkZW50aWZpZXIgdXNpbmcgdGhlIHJlc291cmNlIHR5cGUsIHRoZSBrZXksIGFuZCB0aGUgdmFsdWUgb2YgdGhlIHJlc291cmNlIGlkZW50aWZpZXJcbiAgICAvLyBUaGUgcmVzb3VyY2UgaWRlbnRpZmllciBpcyBhIGNvbWJpbmF0aW9uIG9mIGEga2V5IHZhbHVlIHBhaXIgZGVmaW5lZCBieSBhIHJlc291cmNlJ3Mgc2NoZW1hLCBhbmQgdGhlIHJlc291cmNlIHR5cGUgb2YgdGhlIHJlc291cmNlLlxuICAgIGNvbnN0IHVuaXF1ZUlkZW50aWZlciA9IGAke3Jlc291cmNlLlJlc291cmNlVHlwZX06JHtrZXl9OiR7cmVzb3VyY2UuUmVzb3VyY2VJZGVudGlmaWVyIVtrZXldfWA7XG4gICAgdW5pcXVlUmVzb3VyY2VzW3VuaXF1ZUlkZW50aWZlcl0gPSByZXNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QudmFsdWVzKHVuaXF1ZVJlc291cmNlcyk7XG59XG5cbi8qKlxuICogQ2xhc3MgZm9yIG1ha2luZyBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZSBnZW5lcmF0b3IgY2FsbHNcbiAqL1xuZXhwb3J0IGNsYXNzIENmblRlbXBsYXRlR2VuZXJhdG9yUHJvdmlkZXIge1xuICBwcml2YXRlIGNmbjogSUNsb3VkRm9ybWF0aW9uQ2xpZW50O1xuICBjb25zdHJ1Y3RvcihjZm46IElDbG91ZEZvcm1hdGlvbkNsaWVudCkge1xuICAgIHRoaXMuY2ZuID0gY2ZuO1xuICB9XG5cbiAgYXN5bmMgY2hlY2tGb3JSZXNvdXJjZVNjYW4oXG4gICAgcmVzb3VyY2VTY2FuU3VtbWFyaWVzOiBSZXNvdXJjZVNjYW5TdW1tYXJ5W10gfCB1bmRlZmluZWQsXG4gICAgb3B0aW9uczogR2VuZXJhdGVUZW1wbGF0ZU9wdGlvbnMsXG4gICAgY2xpZW50UmVxdWVzdFRva2VuOiBzdHJpbmcsXG4gICkge1xuICAgIGlmICghcmVzb3VyY2VTY2FuU3VtbWFyaWVzIHx8IHJlc291cmNlU2NhblN1bW1hcmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChvcHRpb25zLmZyb21TY2FuID09PSBGcm9tU2Nhbi5NT1NUX1JFQ0VOVCkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFxuICAgICAgICAgICdObyBzY2FucyBmb3VuZC4gUGxlYXNlIGVpdGhlciBzdGFydCBhIG5ldyBzY2FuIHdpdGggdGhlIGAtLWZyb20tc2NhbmAgbmV3IG9yIGRvIG5vdCBzcGVjaWZ5IGEgYC0tZnJvbS1zY2FuYCBvcHRpb24uJyxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8oJ05vIHNjYW5zIGZvdW5kLiBJbml0aWF0aW5nIGEgbmV3IHJlc291cmNlIHNjYW4uJyk7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RhcnRSZXNvdXJjZVNjYW4oY2xpZW50UmVxdWVzdFRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdG9rZW5pemVkIGxpc3Qgb2YgcmVzb3VyY2VzIGFuZCB0aGVpciBhc3NvY2lhdGVkIHNjYW4uIElmIGEgdG9rZW4gaXMgcHJlc2VudCB0aGUgZnVuY3Rpb25cbiAgICogd2lsbCBsb29wIHRocm91Z2ggYWxsIHBhZ2VzIGFuZCBjb21iaW5lIHRoZW0gaW50byBhIHNpbmdsZSBsaXN0IG9mIFNjYW5uZWRSZWxhdGVkUmVzb3VyY2VzXG4gICAqXG4gICAqIEBwYXJhbSBzY2FuSWQgc2NhbiBpZCBmb3IgdGhlIHRvIGxpc3QgcmVzb3VyY2VzIGZvclxuICAgKiBAcGFyYW0gcmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8gZmluZCByZWxhdGVkIHJlc291cmNlcyBmb3JcbiAgICovXG4gIGFzeW5jIGdldFJlc291cmNlU2NhblJlbGF0ZWRSZXNvdXJjZXMoXG4gICAgc2NhbklkOiBzdHJpbmcsXG4gICAgcmVzb3VyY2VzOiBTY2FubmVkUmVzb3VyY2VbXSxcbiAgKTogUHJvbWlzZTxTY2FubmVkUmVzb3VyY2VJZGVudGlmaWVyW10+IHtcbiAgICBsZXQgcmVsYXRlZFJlc291cmNlTGlzdCA9IHJlc291cmNlcztcblxuICAgIC8vIGJyZWFrIHRoZSBsaXN0IG9mIHJlc291cmNlcyBpbnRvIGNodW5rcyBvZiAxMDAgdG8gYXZvaWQgaGl0dGluZyB0aGUgMTAwIHJlc291cmNlIGxpbWl0XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MocmVzb3VyY2VzLCAxMDApKSB7XG4gICAgICAvLyBnZXQgdGhlIGZpcnN0IHBhZ2Ugb2YgcmVsYXRlZCByZXNvdXJjZXNcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZWxhdGVkUmVzb3VyY2VzKHtcbiAgICAgICAgUmVzb3VyY2VTY2FuSWQ6IHNjYW5JZCxcbiAgICAgICAgUmVzb3VyY2VzOiBjaHVuayxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgdGhlIGZpcnN0IHBhZ2UgdG8gdGhlIGxpc3RcbiAgICAgIHJlbGF0ZWRSZXNvdXJjZUxpc3QucHVzaCguLi4ocmVzLlJlbGF0ZWRSZXNvdXJjZXMgPz8gW10pKTtcbiAgICAgIGxldCBuZXh0VG9rZW4gPSByZXMuTmV4dFRva2VuO1xuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwYWdlcywgY3ljbGUgdGhyb3VnaCB0aGVtIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCBiZWZvcmUgbW92aW5nIG9uIHRvIHRoZSBuZXh0IGNodW5rXG4gICAgICB3aGlsZSAobmV4dFRva2VuKSB7XG4gICAgICAgIGNvbnN0IG5leHRSZWxhdGVkUmVzb3VyY2VzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlbGF0ZWRSZXNvdXJjZXMoe1xuICAgICAgICAgIFJlc291cmNlU2NhbklkOiBzY2FuSWQsXG4gICAgICAgICAgUmVzb3VyY2VzOiByZXNvdXJjZUlkZW50aWZpZXJzKHJlc291cmNlcyksXG4gICAgICAgICAgTmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0VG9rZW4gPSBuZXh0UmVsYXRlZFJlc291cmNlcy5OZXh0VG9rZW47XG4gICAgICAgIHJlbGF0ZWRSZXNvdXJjZUxpc3QucHVzaCguLi4obmV4dFJlbGF0ZWRSZXNvdXJjZXMuUmVsYXRlZFJlc291cmNlcyA/PyBbXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlbGF0ZWRSZXNvdXJjZUxpc3QgPSBkZWR1cGxpY2F0ZVJlc291cmNlcyhyZWxhdGVkUmVzb3VyY2VMaXN0KTtcblxuICAgIC8vIHBydW5lIHRoZSBtYW5hZ2VkYnlzdGFjayBmbGFnIG9mZiBvZiB0aGVtIGFnYWluLlxuICAgIHJldHVybiBwcm9jZXNzLmVudi5NSUdSQVRFX0lOVEVHX1RFU1RcbiAgICAgID8gcmVzb3VyY2VJZGVudGlmaWVycyhyZWxhdGVkUmVzb3VyY2VMaXN0KVxuICAgICAgOiByZXNvdXJjZUlkZW50aWZpZXJzKGV4Y2x1ZGVNYW5hZ2VkKHJlbGF0ZWRSZXNvdXJjZUxpc3QpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLaWNrcyBvZmYgYSBzY2FuIG9mIGEgY3VzdG9tZXJzIGFjY291bnQsIHJldHVybmluZyB0aGUgc2NhbiBpZC4gQSBzY2FuIGNhbiB0YWtlXG4gICAqIDEwIG1pbnV0ZXMgb3IgbG9uZ2VyIHRvIGNvbXBsZXRlLiBIb3dldmVyIHRoaXMgd2lsbCByZXR1cm4gYSBzY2FuIGlkIGFzIHNvb24gYXNcbiAgICogdGhlIHNjYW4gaGFzIGJlZ3VuLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNjYW4gaWRcbiAgICovXG4gIGFzeW5jIHN0YXJ0UmVzb3VyY2VTY2FuKHJlcXVlc3RUb2tlbjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGF3YWl0IHRoaXMuY2ZuLnN0YXJ0UmVzb3VyY2VTY2FuKHtcbiAgICAgICAgQ2xpZW50UmVxdWVzdFRva2VuOiByZXF1ZXN0VG9rZW4sXG4gICAgICB9KVxuICAgICkuUmVzb3VyY2VTY2FuSWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9zdCByZWNlbnQgc2NhbnMgYSBjdXN0b21lciBoYXMgY29tcGxldGVkXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbGlzdCBvZiByZXNvdXJjZSBzY2FuIHN1bW1hcmllc1xuICAgKi9cbiAgYXN5bmMgbGlzdFJlc291cmNlU2NhbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdG9rZW5pemVkIGxpc3Qgb2YgcmVzb3VyY2VzIGZyb20gYSByZXNvdXJjZSBzY2FuLiBJZiBhIHRva2VuIGlzIHByZXNlbnQsIHRoaXMgZnVuY3Rpb25cbiAgICogd2lsbCBsb29wIHRocm91Z2ggYWxsIHBhZ2VzIGFuZCBjb21iaW5lIHRoZW0gaW50byBhIHNpbmdsZSBsaXN0IG9mIFNjYW5uZWRSZXNvdXJjZVtdLlxuICAgKiBBZGRpdGlvbmFsbHkgd2lsbCBhcHBseSBhbnkgZmlsdGVycyBwcm92aWRlZCBieSB0aGUgY3VzdG9tZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzY2FuSWQgc2NhbiBpZCBmb3IgdGhlIHRvIGxpc3QgcmVzb3VyY2VzIGZvclxuICAgKiBAcGFyYW0gZmlsdGVycyBhIHN0cmluZyBvZiBmaWx0ZXJzIGluIHRoZSBmb3JtYXQgb2Yga2V5MT12YWx1ZTEsa2V5Mj12YWx1ZTJcbiAgICogQHJldHVybnMgYSBjb21iaW5lZCBsaXN0IG9mIGFsbCByZXNvdXJjZXMgZnJvbSB0aGUgc2NhblxuICAgKi9cbiAgYXN5bmMgbGlzdFJlc291cmNlU2NhblJlc291cmNlcyhzY2FuSWQ6IHN0cmluZywgZmlsdGVyczogc3RyaW5nW10gPSBbXSk6IFByb21pc2U8U2Nhbm5lZFJlc291cmNlSWRlbnRpZmllcltdPiB7XG4gICAgbGV0IHJlc291cmNlTGlzdDogU2Nhbm5lZFJlc291cmNlW10gPSBbXTtcbiAgICBsZXQgcmVzb3VyY2VTY2FuSW5wdXRzOiBMaXN0UmVzb3VyY2VTY2FuUmVzb3VyY2VzQ29tbWFuZElucHV0O1xuXG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgaW5mbygnQXBwbHlpbmcgZmlsdGVycyB0byByZXNvdXJjZSBzY2FuLicpO1xuICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgICBjb25zdCBmaWx0ZXJMaXN0ID0gcGFyc2VGaWx0ZXJzKGZpbHRlcik7XG4gICAgICAgIHJlc291cmNlU2NhbklucHV0cyA9IHtcbiAgICAgICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgICAgICAgIFJlc291cmNlSWRlbnRpZmllcjogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlJFU09VUkNFX0lERU5USUZJRVJdLFxuICAgICAgICAgIFJlc291cmNlVHlwZVByZWZpeDogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlJFU09VUkNFX1RZUEVfUFJFRklYXSxcbiAgICAgICAgICBUYWdLZXk6IGZpbHRlckxpc3RbRmlsdGVyVHlwZS5UQUdfS0VZXSxcbiAgICAgICAgICBUYWdWYWx1ZTogZmlsdGVyTGlzdFtGaWx0ZXJUeXBlLlRBR19WQUxVRV0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKTtcbiAgICAgICAgcmVzb3VyY2VMaXN0ID0gcmVzb3VyY2VMaXN0LmNvbmNhdChyZXNvdXJjZXMuUmVzb3VyY2VzID8/IFtdKTtcbiAgICAgICAgbGV0IG5leHRUb2tlbiA9IHJlc291cmNlcy5OZXh0VG9rZW47XG5cbiAgICAgICAgLy8gY3ljbGUgdGhyb3VnaCB0aGUgcGFnZXMgYWRkaW5nIGFsbCByZXNvdXJjZXMgdG8gdGhlIGxpc3QgdW50aWwgd2UgcnVuIG91dCBvZiBwYWdlc1xuICAgICAgICB3aGlsZSAobmV4dFRva2VuKSB7XG4gICAgICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzLk5leHRUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgICAgICBjb25zdCBuZXh0UmVzb3VyY2VzID0gYXdhaXQgdGhpcy5jZm4ubGlzdFJlc291cmNlU2NhblJlc291cmNlcyhyZXNvdXJjZVNjYW5JbnB1dHMpO1xuICAgICAgICAgIG5leHRUb2tlbiA9IG5leHRSZXNvdXJjZXMuTmV4dFRva2VuO1xuICAgICAgICAgIHJlc291cmNlTGlzdCA9IHJlc291cmNlTGlzdCEuY29uY2F0KG5leHRSZXNvdXJjZXMuUmVzb3VyY2VzID8/IFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvKCdObyBmaWx0ZXJzIHByb3ZpZGVkLiBSZXRyaWV2aW5nIGFsbCByZXNvdXJjZXMgZnJvbSBzY2FuLicpO1xuICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzID0ge1xuICAgICAgICBSZXNvdXJjZVNjYW5JZDogc2NhbklkLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKTtcbiAgICAgIHJlc291cmNlTGlzdCA9IHJlc291cmNlTGlzdCEuY29uY2F0KHJlc291cmNlcy5SZXNvdXJjZXMgPz8gW10pO1xuICAgICAgbGV0IG5leHRUb2tlbiA9IHJlc291cmNlcy5OZXh0VG9rZW47XG5cbiAgICAgIC8vIGN5Y2xlIHRocm91Z2ggdGhlIHBhZ2VzIGFkZGluZyBhbGwgcmVzb3VyY2VzIHRvIHRoZSBsaXN0IHVudGlsIHdlIHJ1biBvdXQgb2YgcGFnZXNcbiAgICAgIHdoaWxlIChuZXh0VG9rZW4pIHtcbiAgICAgICAgcmVzb3VyY2VTY2FuSW5wdXRzLk5leHRUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgICAgY29uc3QgbmV4dFJlc291cmNlcyA9IGF3YWl0IHRoaXMuY2ZuLmxpc3RSZXNvdXJjZVNjYW5SZXNvdXJjZXMocmVzb3VyY2VTY2FuSW5wdXRzKTtcbiAgICAgICAgbmV4dFRva2VuID0gbmV4dFJlc291cmNlcy5OZXh0VG9rZW47XG4gICAgICAgIHJlc291cmNlTGlzdCA9IHJlc291cmNlTGlzdCEuY29uY2F0KG5leHRSZXNvdXJjZXMuUmVzb3VyY2VzID8/IFtdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc291cmNlTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYE5vIHJlc291cmNlcyBmb3VuZCB3aXRoIGZpbHRlcnMgJHtmaWx0ZXJzLmpvaW4oJyAnKX0uIFBsZWFzZSB0cnkgYWdhaW4gd2l0aCBkaWZmZXJlbnQgZmlsdGVycy5gKTtcbiAgICB9XG4gICAgcmVzb3VyY2VMaXN0ID0gZGVkdXBsaWNhdGVSZXNvdXJjZXMocmVzb3VyY2VMaXN0KTtcblxuICAgIHJldHVybiBwcm9jZXNzLmVudi5NSUdSQVRFX0lOVEVHX1RFU1RcbiAgICAgID8gcmVzb3VyY2VJZGVudGlmaWVycyhyZXNvdXJjZUxpc3QpXG4gICAgICA6IHJlc291cmNlSWRlbnRpZmllcnMoZXhjbHVkZU1hbmFnZWQocmVzb3VyY2VMaXN0KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGEgcmVzb3VyY2Ugc2Nhbi5cbiAgICpcbiAgICogQHBhcmFtIHNjYW5JZCBzY2FuIGlkIGZvciB0aGUgdG8gbGlzdCByZXNvdXJjZXMgZm9yXG4gICAqIEByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzY2FuXG4gICAqL1xuICBhc3luYyBkZXNjcmliZVJlc291cmNlU2NhbihzY2FuSWQ6IHN0cmluZyk6IFByb21pc2U8RGVzY3JpYmVSZXNvdXJjZVNjYW5Db21tYW5kT3V0cHV0PiB7XG4gICAgcmV0dXJuIHRoaXMuY2ZuLmRlc2NyaWJlUmVzb3VyY2VTY2FuKHtcbiAgICAgIFJlc291cmNlU2NhbklkOiBzY2FuSWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgdGVtcGxhdGUgYmVpbmcgZ2VuZXJhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gdGVtcGxhdGVJZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRlbXBsYXRlIGlkXG4gICAqIEByZXR1cm5zIERlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlIHN0YXR1cyBhbmQgcmVzdWx0c1xuICAgKi9cbiAgYXN5bmMgZGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUlkOiBzdHJpbmcpOiBQcm9taXNlPERlc2NyaWJlR2VuZXJhdGVkVGVtcGxhdGVDb21tYW5kT3V0cHV0PiB7XG4gICAgY29uc3QgZ2VuZXJhdGVkVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNmbi5kZXNjcmliZUdlbmVyYXRlZFRlbXBsYXRlKHtcbiAgICAgIEdlbmVyYXRlZFRlbXBsYXRlTmFtZTogdGVtcGxhdGVJZCxcbiAgICB9KTtcblxuICAgIGlmIChnZW5lcmF0ZWRUZW1wbGF0ZS5TdGF0dXMgPT0gU2NhblN0YXR1cy5GQUlMRUQpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoZ2VuZXJhdGVkVGVtcGxhdGUuU3RhdHVzUmVhc29uISk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlbmVyYXRlZFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGNvbXBsZXRlZCBnZW5lcmF0ZWQgY2xvdWRmb3JtYXRpb24gdGVtcGxhdGUgZnJvbSB0aGUgdGVtcGxhdGUgZ2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gdGVtcGxhdGVJZCBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRlbXBsYXRlIGlkXG4gICAqIEBwYXJhbSBjbG91ZEZvcm1hdGlvbiBUaGUgQ2xvdWRGb3JtYXRpb24gc2RrIGNsaWVudCB0byB1c2VcbiAgICogQHJldHVybnMgRGVzY3JpYmVHZW5lcmF0ZWRUZW1wbGF0ZU91dHB1dCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdGVtcGxhdGUgc3RhdHVzIGFuZCBib2R5XG4gICAqL1xuICBhc3luYyBnZXRHZW5lcmF0ZWRUZW1wbGF0ZSh0ZW1wbGF0ZUlkOiBzdHJpbmcpOiBQcm9taXNlPEdldEdlbmVyYXRlZFRlbXBsYXRlQ29tbWFuZE91dHB1dD4ge1xuICAgIHJldHVybiB0aGlzLmNmbi5nZXRHZW5lcmF0ZWRUZW1wbGF0ZSh7XG4gICAgICBHZW5lcmF0ZWRUZW1wbGF0ZU5hbWU6IHRlbXBsYXRlSWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogS2lja3Mgb2ZmIGEgdGVtcGxhdGUgZ2VuZXJhdGlvbiBmb3IgYSBzZXQgb2YgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhY2tOYW1lIFRoZSBuYW1lIG9mIHRoZSBzdGFja1xuICAgKiBAcGFyYW0gcmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdG8gZ2VuZXJhdGUgdGhlIHRlbXBsYXRlIGZyb21cbiAgICogQHJldHVybnMgQ3JlYXRlR2VuZXJhdGVkVGVtcGxhdGVPdXRwdXQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlIGFybiB0byBxdWVyeSBvbiBsYXRlclxuICAgKi9cbiAgYXN5bmMgY3JlYXRlR2VuZXJhdGVkVGVtcGxhdGUoc3RhY2tOYW1lOiBzdHJpbmcsIHJlc291cmNlczogUmVzb3VyY2VEZWZpbml0aW9uW10pIHtcbiAgICBjb25zdCBjcmVhdGVUZW1wbGF0ZU91dHB1dCA9IGF3YWl0IHRoaXMuY2ZuLmNyZWF0ZUdlbmVyYXRlZFRlbXBsYXRlKHtcbiAgICAgIFJlc291cmNlczogcmVzb3VyY2VzLFxuICAgICAgR2VuZXJhdGVkVGVtcGxhdGVOYW1lOiBzdGFja05hbWUsXG4gICAgfSk7XG5cbiAgICBpZiAoY3JlYXRlVGVtcGxhdGVPdXRwdXQuR2VuZXJhdGVkVGVtcGxhdGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKCdDcmVhdGVHZW5lcmF0ZWRUZW1wbGF0ZSBmYWlsZWQgdG8gcmV0dXJuIGFuIEFybi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRlbXBsYXRlT3V0cHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBnZW5lcmF0ZWQgdGVtcGxhdGUgZnJvbSB0aGUgdGVtcGxhdGUgZ2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gdGVtcGxhdGVBcm4gVGhlIGFybiBvZiB0aGUgdGVtcGxhdGUgdG8gZGVsZXRlXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHRlbXBsYXRlIGhhcyBiZWVuIGRlbGV0ZWRcbiAgICovXG4gIGFzeW5jIGRlbGV0ZUdlbmVyYXRlZFRlbXBsYXRlKHRlbXBsYXRlQXJuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmNmbi5kZWxldGVHZW5lcmF0ZWRUZW1wbGF0ZSh7XG4gICAgICBHZW5lcmF0ZWRUZW1wbGF0ZU5hbWU6IHRlbXBsYXRlQXJuLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHBvc3NpYmxlIHdheXMgdG8gY2hvb3NlIGEgc2NhbiB0byBnZW5lcmF0ZSBhIENESyBhcHBsaWNhdGlvbiBmcm9tXG4gKi9cbmV4cG9ydCBlbnVtIEZyb21TY2FuIHtcbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgbmV3IHJlc291cmNlIHNjYW4gdG8gYnVpbGQgdGhlIENESyBhcHBsaWNhdGlvbiBmcm9tLlxuICAgKi9cbiAgTkVXLFxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIGxhc3Qgc3VjY2Vzc2Z1bCBzY2FuIHRvIGJ1aWxkIHRoZSBDREsgYXBwbGljYXRpb24gZnJvbS4gV2lsbCBmYWlsIGlmIG5vIHNjYW4gaXMgZm91bmQuXG4gICAqL1xuICBNT1NUX1JFQ0VOVCxcblxuICAvKipcbiAgICogU3RhcnRzIGEgc2NhbiBpZiBub25lIGV4aXN0cywgb3RoZXJ3aXNlIHVzZXMgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgc2NhbiB0byBidWlsZCB0aGUgQ0RLIGFwcGxpY2F0aW9uIGZyb20uXG4gICAqL1xuICBERUZBVUxULFxufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byB0aGUgZ2VuZXJhdGVUZW1wbGF0ZSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSBzdGFja05hbWUgVGhlIG5hbWUgb2YgdGhlIHN0YWNrXG4gKiBAcGFyYW0gZmlsdGVycyBBIGxpc3Qgb2YgZmlsdGVycyB0byBhcHBseSB0byB0aGUgc2NhblxuICogQHBhcmFtIGZyb21TY2FuIEFuIGVudW0gdmFsdWUgc3BlY2lmeWluZyB3aGV0aGVyIGEgbmV3IHNjYW4gc2hvdWxkIGJlIHN0YXJ0ZWQgb3IgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgc2NhbiBzaG91bGQgYmUgdXNlZFxuICogQHBhcmFtIHNka1Byb3ZpZGVyIFRoZSBzZGsgcHJvdmlkZXIgZm9yIG1ha2luZyBDbG91ZEZvcm1hdGlvbiBjYWxsc1xuICogQHBhcmFtIGVudmlyb25tZW50IFRoZSBhY2NvdW50IGFuZCByZWdpb24gd2hlcmUgdGhlIHN0YWNrIGlzIGRlcGxveWVkXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVUZW1wbGF0ZU9wdGlvbnMge1xuICBzdGFja05hbWU6IHN0cmluZztcbiAgZmlsdGVycz86IHN0cmluZ1tdO1xuICBmcm9tU2Nhbj86IEZyb21TY2FuO1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG4gIGVudmlyb25tZW50OiBFbnZpcm9ubWVudDtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHRoZSBvdXRwdXQgb2YgdGhlIGdlbmVyYXRlVGVtcGxhdGUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gbWlncmF0ZUpzb24gVGhlIGdlbmVyYXRlZCBNaWdyYXRlLmpzb24gZmlsZVxuICogQHBhcmFtIHJlc291cmNlcyBUaGUgZ2VuZXJhdGVkIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVUZW1wbGF0ZU91dHB1dCB7XG4gIG1pZ3JhdGVKc29uOiBNaWdyYXRlSnNvbkZvcm1hdDtcbiAgcmVzb3VyY2VzPzogUmVzb3VyY2VEZXRhaWxbXTtcbiAgdGVtcGxhdGVJZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZGVmaW5pbmcgdGhlIGZvcm1hdCBvZiB0aGUgZ2VuZXJhdGVkIE1pZ3JhdGUuanNvbiBmaWxlXG4gKlxuICogQHBhcmFtIFRlbXBsYXRlQm9keSBUaGUgZ2VuZXJhdGVkIHRlbXBsYXRlXG4gKiBAcGFyYW0gU291cmNlIFRoZSBzb3VyY2Ugb2YgdGhlIHRlbXBsYXRlXG4gKiBAcGFyYW0gUmVzb3VyY2VzIEEgbGlzdCBvZiByZXNvdXJjZXMgdGhhdCB3ZXJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWlncmF0ZUpzb25Gb3JtYXQge1xuICB0ZW1wbGF0ZUJvZHk6IHN0cmluZztcbiAgc291cmNlOiBzdHJpbmc7XG4gIHJlc291cmNlcz86IEdlbmVyYXRlZFJlc291cmNlSW1wb3J0SWRlbnRpZmllcltdO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSByZXByZXNlbnRpbmcgdGhlIGZvcm1hdCBvZiBhIHJlc291cmNlIGlkZW50aWZpZXIgcmVxdWlyZWQgZm9yIHJlc291cmNlIGltcG9ydFxuICpcbiAqIEBwYXJhbSBSZXNvdXJjZVR5cGUgVGhlIHR5cGUgb2YgcmVzb3VyY2VcbiAqIEBwYXJhbSBMb2dpY2FsUmVzb3VyY2VJZCBUaGUgbG9naWNhbCBpZCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSBSZXNvdXJjZUlkZW50aWZpZXIgVGhlIHJlc291cmNlIGlkZW50aWZpZXIgb2YgdGhlIHJlc291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVkUmVzb3VyY2VJbXBvcnRJZGVudGlmaWVyIHtcbiAgLy8gY2RrIGRlcGxveSBleHBlY3RzIHRoZSBtaWdyYXRlLmpzb24gcmVzb3VyY2UgaWRlbnRpZmllcnMgdG8gYmUgUGFzY2FsQ2FzZSwgbm90IGNhbWVsQ2FzZS5cbiAgUmVzb3VyY2VUeXBlOiBzdHJpbmc7XG4gIExvZ2ljYWxSZXNvdXJjZUlkOiBzdHJpbmc7XG4gIFJlc291cmNlSWRlbnRpZmllcjogUmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyeTtcbn1cbiJdfQ==