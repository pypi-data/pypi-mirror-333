"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedDataSource = exports.WebsiteNoticeDataSource = exports.FilteredNotice = exports.Notices = exports.NoticesFilter = void 0;
const https = require("node:https");
const path = require("path");
const fs = require("fs-extra");
const semver = require("semver");
const awscli_compatible_1 = require("./api/aws-auth/awscli-compatible");
const version_1 = require("./cli/version");
const logging_1 = require("./logging");
const error_1 = require("./toolkit/error");
const tree_1 = require("./tree");
const util_1 = require("./util");
const CACHE_FILE_PATH = path.join((0, util_1.cdkCacheDir)(), 'notices.json');
class NoticesFilter {
    static filter(options) {
        const components = [
            ...NoticesFilter.constructTreeComponents(options.outDir),
            ...NoticesFilter.otherComponents(options),
        ];
        return NoticesFilter.findForNamedComponents(options.data, components);
    }
    /**
     * From a set of input options, return the notices components we are searching for
     */
    static otherComponents(options) {
        return [
            // CLI
            {
                name: 'cli',
                version: options.cliVersion,
            },
            // Node version
            {
                name: 'node',
                version: process.version.replace(/^v/, ''), // remove the 'v' prefix.
                dynamicName: 'node',
            },
            // Bootstrap environments
            ...options.bootstrappedEnvironments.flatMap(env => {
                const semverBootstrapVersion = semver.coerce(env.bootstrapStackVersion);
                if (!semverBootstrapVersion) {
                    // we don't throw because notices should never crash the cli.
                    (0, logging_1.warning)(`While filtering notices, could not coerce bootstrap version '${env.bootstrapStackVersion}' into semver`);
                    return [];
                }
                return [{
                        name: 'bootstrap',
                        version: `${semverBootstrapVersion}`,
                        dynamicName: 'ENVIRONMENTS',
                        dynamicValue: env.environment.name,
                    }];
            }),
        ];
    }
    /**
     * Based on a set of component names, find all notices that match one of the given components
     */
    static findForNamedComponents(data, actualComponents) {
        return data.flatMap(notice => {
            const ors = this.resolveAliases(normalizeComponents(notice.components));
            // Find the first set of the disjunctions of which all components match against the actual components.
            // Return the actual components we found so that we can inject their dynamic values. A single filter
            // component can match more than one actual component
            for (const ands of ors) {
                const matched = ands.map(affected => actualComponents.filter(actual => NoticesFilter.componentNameMatches(affected, actual) && semver.satisfies(actual.version, affected.version, { includePrerelease: true })));
                // For every clause in the filter we matched one or more components
                if (matched.every(xs => xs.length > 0)) {
                    const ret = new FilteredNotice(notice);
                    NoticesFilter.addDynamicValues(matched.flatMap(x => x), ret);
                    return [ret];
                }
            }
            return [];
        });
    }
    /**
     * Whether the given "affected component" name applies to the given actual component name.
     *
     * The name matches if the name is exactly the same, or the name in the notice
     * is a prefix of the node name when the query ends in '.'.
     */
    static componentNameMatches(pattern, actual) {
        return pattern.name.endsWith('.') ? actual.name.startsWith(pattern.name) : pattern.name === actual.name;
    }
    /**
     * Adds dynamic values from the given ActualComponents
     *
     * If there are multiple components with the same dynamic name, they are joined
     * by a comma.
     */
    static addDynamicValues(comps, notice) {
        var _a, _b;
        const dynamicValues = {};
        for (const comp of comps) {
            if (comp.dynamicName) {
                dynamicValues[comp.dynamicName] = (_a = dynamicValues[comp.dynamicName]) !== null && _a !== void 0 ? _a : [];
                dynamicValues[comp.dynamicName].push((_b = comp.dynamicValue) !== null && _b !== void 0 ? _b : comp.version);
            }
        }
        for (const [key, values] of Object.entries(dynamicValues)) {
            notice.addDynamicValue(key, values.join(','));
        }
    }
    /**
     * Treat 'framework' as an alias for either `aws-cdk-lib.` or `@aws-cdk/core.`.
     *
     * Because it's EITHER `aws-cdk-lib` or `@aws-cdk/core`, we need to add multiple
     * arrays at the top level.
     */
    static resolveAliases(ors) {
        return ors.flatMap(ands => {
            const hasFramework = ands.find(c => c.name === 'framework');
            if (!hasFramework) {
                return [ands];
            }
            return [
                ands.map(c => c.name === 'framework' ? { ...c, name: '@aws-cdk/core.' } : c),
                ands.map(c => c.name === 'framework' ? { ...c, name: 'aws-cdk-lib.' } : c),
            ];
        });
    }
    /**
     * Load the construct tree from the given directory and return its components
     */
    static constructTreeComponents(manifestDir) {
        const tree = (0, tree_1.loadTreeFromDir)(manifestDir);
        if (!tree) {
            return [];
        }
        const ret = [];
        recurse(tree);
        return ret;
        function recurse(x) {
            var _a, _b, _c, _d, _e;
            if (((_a = x.constructInfo) === null || _a === void 0 ? void 0 : _a.fqn) && ((_b = x.constructInfo) === null || _b === void 0 ? void 0 : _b.version)) {
                ret.push({
                    name: (_c = x.constructInfo) === null || _c === void 0 ? void 0 : _c.fqn,
                    version: (_d = x.constructInfo) === null || _d === void 0 ? void 0 : _d.version,
                });
            }
            for (const child of Object.values((_e = x.children) !== null && _e !== void 0 ? _e : {})) {
                recurse(child);
            }
        }
    }
}
exports.NoticesFilter = NoticesFilter;
/**
 * Provides access to notices the CLI can display.
 */
class Notices {
    /**
     * Create an instance. Note that this replaces the singleton.
     */
    static create(props) {
        this._instance = new Notices(props);
        return this._instance;
    }
    /**
     * Get the singleton instance. May return `undefined` if `create` has not been called.
     */
    static get() {
        return this._instance;
    }
    constructor(props) {
        var _a, _b, _c, _d, _e;
        this.data = new Set();
        // sets don't deduplicate interfaces, so we use a map.
        this.bootstrappedEnvironments = new Map();
        this.context = props.context;
        this.acknowledgedIssueNumbers = new Set((_a = this.context.get('acknowledged-issue-numbers')) !== null && _a !== void 0 ? _a : []);
        this.includeAcknowlegded = (_b = props.includeAcknowledged) !== null && _b !== void 0 ? _b : false;
        this.output = (_c = props.output) !== null && _c !== void 0 ? _c : 'cdk.out';
        this.shouldDisplay = (_d = props.shouldDisplay) !== null && _d !== void 0 ? _d : true;
        this.httpOptions = (_e = props.httpOptions) !== null && _e !== void 0 ? _e : {};
    }
    /**
     * Add a bootstrap information to filter on. Can have multiple values
     * in case of multi-environment deployments.
     */
    addBootstrappedEnvironment(bootstrapped) {
        const key = [
            bootstrapped.bootstrapStackVersion,
            bootstrapped.environment.account,
            bootstrapped.environment.region,
            bootstrapped.environment.name,
        ].join(':');
        this.bootstrappedEnvironments.set(key, bootstrapped);
    }
    /**
     * Refresh the list of notices this instance is aware of.
     * To make sure this never crashes the CLI process, all failures are caught and
     * silently logged.
     *
     * If context is configured to not display notices, this will no-op.
     */
    async refresh(options = {}) {
        var _a, _b;
        if (!this.shouldDisplay) {
            return;
        }
        try {
            const underlyingDataSource = (_a = options.dataSource) !== null && _a !== void 0 ? _a : new WebsiteNoticeDataSource(this.httpOptions);
            const dataSource = new CachedDataSource(CACHE_FILE_PATH, underlyingDataSource, (_b = options.force) !== null && _b !== void 0 ? _b : false);
            const notices = await dataSource.fetch();
            this.data = new Set(this.includeAcknowlegded ? notices : notices.filter(n => !this.acknowledgedIssueNumbers.has(n.issueNumber)));
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
        }
    }
    /**
     * Display the relevant notices (unless context dictates we shouldn't).
     */
    display(options = {}) {
        var _a;
        if (!this.shouldDisplay) {
            return;
        }
        const filteredNotices = NoticesFilter.filter({
            data: Array.from(this.data),
            cliVersion: (0, version_1.versionNumber)(),
            outDir: this.output,
            bootstrappedEnvironments: Array.from(this.bootstrappedEnvironments.values()),
        });
        if (filteredNotices.length > 0) {
            (0, logging_1.info)('');
            (0, logging_1.info)('NOTICES         (What\'s this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)');
            (0, logging_1.info)('');
            for (const filtered of filteredNotices) {
                const formatted = filtered.format();
                switch (filtered.notice.severity) {
                    case 'warning':
                        (0, logging_1.warning)(formatted);
                        break;
                    case 'error':
                        (0, logging_1.error)(formatted);
                        break;
                    default:
                        (0, logging_1.info)(formatted);
                }
                (0, logging_1.info)('');
            }
            (0, logging_1.info)(`If you don’t want to see a notice anymore, use "cdk acknowledge <id>". For example, "cdk acknowledge ${filteredNotices[0].notice.issueNumber}".`);
        }
        if ((_a = options.showTotal) !== null && _a !== void 0 ? _a : false) {
            (0, logging_1.info)('');
            (0, logging_1.info)(`There are ${filteredNotices.length} unacknowledged notice(s).`);
        }
    }
}
exports.Notices = Notices;
/**
 * Normalizes the given components structure into DNF form
 */
function normalizeComponents(xs) {
    return xs.map(x => Array.isArray(x) ? x : [x]);
}
function renderConjunction(xs) {
    return xs.map(c => `${c.name}: ${c.version}`).join(' AND ');
}
/**
 * Notice after passing the filter. A filter can augment a notice with
 * dynamic values as it has access to the dynamic matching data.
 */
class FilteredNotice {
    constructor(notice) {
        this.notice = notice;
        this.dynamicValues = {};
    }
    addDynamicValue(key, value) {
        this.dynamicValues[`{resolve:${key}}`] = value;
    }
    format() {
        const componentsValue = normalizeComponents(this.notice.components).map(renderConjunction).join(', ');
        return this.resolveDynamicValues([
            `${this.notice.issueNumber}\t${this.notice.title}`,
            this.formatOverview(),
            `\tAffected versions: ${componentsValue}`,
            `\tMore information at: https://github.com/aws/aws-cdk/issues/${this.notice.issueNumber}`,
        ].join('\n\n') + '\n');
    }
    formatOverview() {
        const wrap = (s) => s.replace(/(?![^\n]{1,60}$)([^\n]{1,60})\s/g, '$1\n');
        const heading = 'Overview: ';
        const separator = `\n\t${' '.repeat(heading.length)}`;
        const content = wrap(this.notice.overview)
            .split('\n')
            .join(separator);
        return '\t' + heading + content;
    }
    resolveDynamicValues(input) {
        const pattern = new RegExp(Object.keys(this.dynamicValues).join('|'), 'g');
        return input.replace(pattern, (matched) => { var _a; return (_a = this.dynamicValues[matched]) !== null && _a !== void 0 ? _a : matched; });
    }
}
exports.FilteredNotice = FilteredNotice;
class WebsiteNoticeDataSource {
    constructor(options = {}) {
        this.options = options;
    }
    fetch() {
        const timeout = 3000;
        return new Promise((resolve, reject) => {
            let req;
            let timer = setTimeout(() => {
                if (req) {
                    req.destroy(new error_1.ToolkitError('Request timed out'));
                }
            }, timeout);
            timer.unref();
            const options = {
                agent: awscli_compatible_1.AwsCliCompatible.proxyAgent(this.options),
            };
            try {
                req = https.get('https://cli.cdk.dev-tools.aws.dev/notices.json', options, res => {
                    if (res.statusCode === 200) {
                        res.setEncoding('utf8');
                        let rawData = '';
                        res.on('data', (chunk) => {
                            rawData += chunk;
                        });
                        res.on('end', () => {
                            try {
                                const data = JSON.parse(rawData).notices;
                                if (!data) {
                                    throw new error_1.ToolkitError("'notices' key is missing");
                                }
                                (0, logging_1.debug)('Notices refreshed');
                                resolve(data !== null && data !== void 0 ? data : []);
                            }
                            catch (e) {
                                reject(new error_1.ToolkitError(`Failed to parse notices: ${(0, util_1.formatErrorMessage)(e)}`));
                            }
                        });
                        res.on('error', e => {
                            reject(new error_1.ToolkitError(`Failed to fetch notices: ${(0, util_1.formatErrorMessage)(e)}`));
                        });
                    }
                    else {
                        reject(new error_1.ToolkitError(`Failed to fetch notices. Status code: ${res.statusCode}`));
                    }
                });
                req.on('error', reject);
            }
            catch (e) {
                reject(new error_1.ToolkitError(`HTTPS 'get' call threw an error: ${(0, util_1.formatErrorMessage)(e)}`));
            }
        });
    }
}
exports.WebsiteNoticeDataSource = WebsiteNoticeDataSource;
const TIME_TO_LIVE_SUCCESS = 60 * 60 * 1000; // 1 hour
const TIME_TO_LIVE_ERROR = 1 * 60 * 1000; // 1 minute
class CachedDataSource {
    constructor(fileName, dataSource, skipCache) {
        this.fileName = fileName;
        this.dataSource = dataSource;
        this.skipCache = skipCache;
    }
    async fetch() {
        var _a;
        const cachedData = await this.load();
        const data = cachedData.notices;
        const expiration = (_a = cachedData.expiration) !== null && _a !== void 0 ? _a : 0;
        if (Date.now() > expiration || this.skipCache) {
            const freshData = await this.fetchInner();
            await this.save(freshData);
            return freshData.notices;
        }
        else {
            (0, logging_1.debug)(`Reading cached notices from ${this.fileName}`);
            return data;
        }
    }
    async fetchInner() {
        try {
            return {
                expiration: Date.now() + TIME_TO_LIVE_SUCCESS,
                notices: await this.dataSource.fetch(),
            };
        }
        catch (e) {
            (0, logging_1.debug)(`Could not refresh notices: ${e}`);
            return {
                expiration: Date.now() + TIME_TO_LIVE_ERROR,
                notices: [],
            };
        }
    }
    async load() {
        const defaultValue = {
            expiration: 0,
            notices: [],
        };
        try {
            return fs.existsSync(this.fileName)
                ? await fs.readJSON(this.fileName)
                : defaultValue;
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to load notices from cache: ${e}`);
            return defaultValue;
        }
    }
    async save(cached) {
        try {
            await fs.writeJSON(this.fileName, cached);
        }
        catch (e) {
            (0, logging_1.debug)(`Failed to store notices in the cache: ${e}`);
        }
    }
}
exports.CachedDataSource = CachedDataSource;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBRWpDLHdFQUFvRTtBQUVwRSwyQ0FBOEM7QUFDOUMsdUNBQXdEO0FBQ3hELDJDQUErQztBQUMvQyxpQ0FBNEQ7QUFDNUQsaUNBQXlEO0FBRXpELE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBQSxrQkFBVyxHQUFFLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFvRWpFLE1BQXNCLGFBQWE7SUFDMUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFtQztRQUN0RCxNQUFNLFVBQVUsR0FBRztZQUNqQixHQUFHLGFBQWEsQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3hELEdBQUcsYUFBYSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUM7U0FDMUMsQ0FBQztRQUVGLE9BQU8sYUFBYSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVEOztPQUVHO0lBQ0ssTUFBTSxDQUFDLGVBQWUsQ0FBQyxPQUFtQztRQUNoRSxPQUFPO1lBQ0wsTUFBTTtZQUNOO2dCQUNFLElBQUksRUFBRSxLQUFLO2dCQUNYLE9BQU8sRUFBRSxPQUFPLENBQUMsVUFBVTthQUM1QjtZQUVELGVBQWU7WUFDZjtnQkFDRSxJQUFJLEVBQUUsTUFBTTtnQkFDWixPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFLHlCQUF5QjtnQkFDckUsV0FBVyxFQUFFLE1BQU07YUFDcEI7WUFFRCx5QkFBeUI7WUFDekIsR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dC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QUFFO2FBQ1osQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLElBQUk7UUFDaEIsTUFBTSxZQUFZLEdBQUc7WUFDbkIsVUFBVSxFQUFFLENBQUM7WUFDYixPQUFPLEVBQUUsRUFBRTtTQUNaLENBQUM7UUFFRixJQUFJLENBQUM7WUFDSCxPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztnQkFDakMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFrQjtnQkFDbkQsQ0FBQyxDQUFDLFlBQVksQ0FBQztRQUNuQixDQUFDO1FBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNYLElBQUEsZUFBSyxFQUFDLHNDQUFzQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2pELE9BQU8sWUFBWSxDQUFDO1FBQ3RCLENBQUM7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFxQjtRQUN0QyxJQUFJLENBQUM7WUFDSCxNQUFNLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUM1QyxDQUFDO1FBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNYLElBQUEsZUFBSyxFQUFDLHlDQUF5QyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3RELENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUE1REQsNENBNERDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xpZW50UmVxdWVzdCB9IGZyb20gJ2h0dHAnO1xuaW1wb3J0IHsgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICdodHRwcyc7XG5pbXBvcnQgKiBhcyBodHRwcyBmcm9tICdub2RlOmh0dHBzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgdHlwZSB7IEVudmlyb25tZW50IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHsgU2RrSHR0cE9wdGlvbnMgfSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBBd3NDbGlDb21wYXRpYmxlIH0gZnJvbSAnLi9hcGkvYXdzLWF1dGgvYXdzY2xpLWNvbXBhdGlibGUnO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0IH0gZnJvbSAnLi9hcGkvY29udGV4dCc7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi9jbGkvdmVyc2lvbic7XG5pbXBvcnQgeyBkZWJ1ZywgaW5mbywgd2FybmluZywgZXJyb3IgfSBmcm9tICcuL2xvZ2dpbmcnO1xuaW1wb3J0IHsgVG9vbGtpdEVycm9yIH0gZnJvbSAnLi90b29sa2l0L2Vycm9yJztcbmltcG9ydCB7IENvbnN0cnVjdFRyZWVOb2RlLCBsb2FkVHJlZUZyb21EaXIgfSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IHsgY2RrQ2FjaGVEaXIsIGZvcm1hdEVycm9yTWVzc2FnZSB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IENBQ0hFX0ZJTEVfUEFUSCA9IHBhdGguam9pbihjZGtDYWNoZURpcigpLCAnbm90aWNlcy5qc29uJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc1Byb3BzIHtcbiAgLyoqXG4gICAqIENESyBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBjb250ZXh0OiBDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBJbmNsdWRlIG5vdGljZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhY2tub3dsZWRnZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBpbmNsdWRlQWNrbm93bGVkZ2VkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogR2xvYmFsIENMSSBvcHRpb24gZm9yIG91dHB1dCBkaXJlY3RvcnkgZm9yIHN5bnRoZXNpemVkIGNsb3VkIGFzc2VtYmx5XG4gICAqXG4gICAqIEBkZWZhdWx0ICdjZGsub3V0J1xuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHbG9iYWwgQ0xJIG9wdGlvbiBmb3Igd2hldGhlciB3ZSBzaG93IG5vdGljZXNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgc2hvdWxkRGlzcGxheT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHRoZSBIVFRQIHJlcXVlc3RcbiAgICovXG4gIHJlYWRvbmx5IGh0dHBPcHRpb25zPzogU2RrSHR0cE9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc1ByaW50T3B0aW9ucyB7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYXBwZW5kIHRoZSB0b3RhbCBudW1iZXIgb2YgdW5hY2tub3dsZWRnZWQgbm90aWNlcyB0byB0aGUgZGlzcGxheS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHNob3dUb3RhbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlc1JlZnJlc2hPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZm9yY2UgYSBjYWNoZSByZWZyZXNoIHJlZ2FyZGxlc3Mgb2YgZXhwaXJhdGlvbiB0aW1lLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgZm9yY2U/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEYXRhIHNvdXJjZSBmb3IgZmV0Y2ggbm90aWNlcyBmcm9tLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFdlYnNpdGVOb3RpY2VEYXRhU291cmNlXG4gICAqL1xuICByZWFkb25seSBkYXRhU291cmNlPzogTm90aWNlRGF0YVNvdXJjZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VzRmlsdGVyRmlsdGVyT3B0aW9ucyB7XG4gIHJlYWRvbmx5IGRhdGE6IE5vdGljZVtdO1xuICByZWFkb25seSBjbGlWZXJzaW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dERpcjogc3RyaW5nO1xuICByZWFkb25seSBib290c3RyYXBwZWRFbnZpcm9ubWVudHM6IEJvb3RzdHJhcHBlZEVudmlyb25tZW50W107XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBOb3RpY2VzRmlsdGVyIHtcbiAgcHVibGljIHN0YXRpYyBmaWx0ZXIob3B0aW9uczogTm90aWNlc0ZpbHRlckZpbHRlck9wdGlvbnMpOiBGaWx0ZXJlZE5vdGljZVtdIHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gW1xuICAgICAgLi4uTm90aWNlc0ZpbHRlci5jb25zdHJ1Y3RUcmVlQ29tcG9uZW50cyhvcHRpb25zLm91dERpciksXG4gICAgICAuLi5Ob3RpY2VzRmlsdGVyLm90aGVyQ29tcG9uZW50cyhvcHRpb25zKSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIE5vdGljZXNGaWx0ZXIuZmluZEZvck5hbWVkQ29tcG9uZW50cyhvcHRpb25zLmRhdGEsIGNvbXBvbmVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gYSBzZXQgb2YgaW5wdXQgb3B0aW9ucywgcmV0dXJuIHRoZSBub3RpY2VzIGNvbXBvbmVudHMgd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIG90aGVyQ29tcG9uZW50cyhvcHRpb25zOiBOb3RpY2VzRmlsdGVyRmlsdGVyT3B0aW9ucyk6IEFjdHVhbENvbXBvbmVudFtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gQ0xJXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdjbGknLFxuICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLmNsaVZlcnNpb24sXG4gICAgICB9LFxuXG4gICAgICAvLyBOb2RlIHZlcnNpb25cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ25vZGUnLFxuICAgICAgICB2ZXJzaW9uOiBwcm9jZXNzLnZlcnNpb24ucmVwbGFjZSgvXnYvLCAnJyksIC8vIHJlbW92ZSB0aGUgJ3YnIHByZWZpeC5cbiAgICAgICAgZHluYW1pY05hbWU6ICdub2RlJyxcbiAgICAgIH0sXG5cbiAgICAgIC8vIEJvb3RzdHJhcCBlbnZpcm9ubWVudHNcbiAgICAgIC4uLm9wdGlvbnMuYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzLmZsYXRNYXAoZW52ID0+IHtcbiAgICAgICAgY29uc3Qgc2VtdmVyQm9vdHN0cmFwVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoZW52LmJvb3RzdHJhcFN0YWNrVmVyc2lvbik7XG4gICAgICAgIGlmICghc2VtdmVyQm9vdHN0cmFwVmVyc2lvbikge1xuICAgICAgICAgIC8vIHdlIGRvbid0IHRocm93IGJlY2F1c2Ugbm90aWNlcyBzaG91bGQgbmV2ZXIgY3Jhc2ggdGhlIGNsaS5cbiAgICAgICAgICB3YXJuaW5nKGBXaGlsZSBmaWx0ZXJpbmcgbm90aWNlcywgY291bGQgbm90IGNvZXJjZSBib290c3RyYXAgdmVyc2lvbiAnJHtlbnYuYm9vdHN0cmFwU3RhY2tWZXJzaW9ufScgaW50byBzZW12ZXJgKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICBuYW1lOiAnYm9vdHN0cmFwJyxcbiAgICAgICAgICB2ZXJzaW9uOiBgJHtzZW12ZXJCb290c3RyYXBWZXJzaW9ufWAsXG4gICAgICAgICAgZHluYW1pY05hbWU6ICdFTlZJUk9OTUVOVFMnLFxuICAgICAgICAgIGR5bmFtaWNWYWx1ZTogZW52LmVudmlyb25tZW50Lm5hbWUsXG4gICAgICAgIH1dO1xuICAgICAgfSksXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiBhIHNldCBvZiBjb21wb25lbnQgbmFtZXMsIGZpbmQgYWxsIG5vdGljZXMgdGhhdCBtYXRjaCBvbmUgb2YgdGhlIGdpdmVuIGNvbXBvbmVudHNcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGZpbmRGb3JOYW1lZENvbXBvbmVudHMoZGF0YTogTm90aWNlW10sIGFjdHVhbENvbXBvbmVudHM6IEFjdHVhbENvbXBvbmVudFtdKTogRmlsdGVyZWROb3RpY2VbXSB7XG4gICAgcmV0dXJuIGRhdGEuZmxhdE1hcChub3RpY2UgPT4ge1xuICAgICAgY29uc3Qgb3JzID0gdGhpcy5yZXNvbHZlQWxpYXNlcyhub3JtYWxpemVDb21wb25lbnRzKG5vdGljZS5jb21wb25lbnRzKSk7XG5cbiAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHNldCBvZiB0aGUgZGlzanVuY3Rpb25zIG9mIHdoaWNoIGFsbCBjb21wb25lbnRzIG1hdGNoIGFnYWluc3QgdGhlIGFjdHVhbCBjb21wb25lbnRzLlxuICAgICAgLy8gUmV0dXJuIHRoZSBhY3R1YWwgY29tcG9uZW50cyB3ZSBmb3VuZCBzbyB0aGF0IHdlIGNhbiBpbmplY3QgdGhlaXIgZHluYW1pYyB2YWx1ZXMuIEEgc2luZ2xlIGZpbHRlclxuICAgICAgLy8gY29tcG9uZW50IGNhbiBtYXRjaCBtb3JlIHRoYW4gb25lIGFjdHVhbCBjb21wb25lbnRcbiAgICAgIGZvciAoY29uc3QgYW5kcyBvZiBvcnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGFuZHMubWFwKGFmZmVjdGVkID0+IGFjdHVhbENvbXBvbmVudHMuZmlsdGVyKGFjdHVhbCA9PlxuICAgICAgICAgIE5vdGljZXNGaWx0ZXIuY29tcG9uZW50TmFtZU1hdGNoZXMoYWZmZWN0ZWQsIGFjdHVhbCkgJiYgc2VtdmVyLnNhdGlzZmllcyhhY3R1YWwudmVyc2lvbiwgYWZmZWN0ZWQudmVyc2lvbiwgeyBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSB9KSkpO1xuXG4gICAgICAgIC8vIEZvciBldmVyeSBjbGF1c2UgaW4gdGhlIGZpbHRlciB3ZSBtYXRjaGVkIG9uZSBvciBtb3JlIGNvbXBvbmVudHNcbiAgICAgICAgaWYgKG1hdGNoZWQuZXZlcnkoeHMgPT4geHMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICBjb25zdCByZXQgPSBuZXcgRmlsdGVyZWROb3RpY2Uobm90aWNlKTtcbiAgICAgICAgICBOb3RpY2VzRmlsdGVyLmFkZER5bmFtaWNWYWx1ZXMobWF0Y2hlZC5mbGF0TWFwKHggPT4geCksIHJldCk7XG4gICAgICAgICAgcmV0dXJuIFtyZXRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBcImFmZmVjdGVkIGNvbXBvbmVudFwiIG5hbWUgYXBwbGllcyB0byB0aGUgZ2l2ZW4gYWN0dWFsIGNvbXBvbmVudCBuYW1lLlxuICAgKlxuICAgKiBUaGUgbmFtZSBtYXRjaGVzIGlmIHRoZSBuYW1lIGlzIGV4YWN0bHkgdGhlIHNhbWUsIG9yIHRoZSBuYW1lIGluIHRoZSBub3RpY2VcbiAgICogaXMgYSBwcmVmaXggb2YgdGhlIG5vZGUgbmFtZSB3aGVuIHRoZSBxdWVyeSBlbmRzIGluICcuJy5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGNvbXBvbmVudE5hbWVNYXRjaGVzKHBhdHRlcm46IENvbXBvbmVudCwgYWN0dWFsOiBBY3R1YWxDb21wb25lbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gcGF0dGVybi5uYW1lLmVuZHNXaXRoKCcuJykgPyBhY3R1YWwubmFtZS5zdGFydHNXaXRoKHBhdHRlcm4ubmFtZSkgOiBwYXR0ZXJuLm5hbWUgPT09IGFjdHVhbC5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZHluYW1pYyB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gQWN0dWFsQ29tcG9uZW50c1xuICAgKlxuICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIGR5bmFtaWMgbmFtZSwgdGhleSBhcmUgam9pbmVkXG4gICAqIGJ5IGEgY29tbWEuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhZGREeW5hbWljVmFsdWVzKGNvbXBzOiBBY3R1YWxDb21wb25lbnRbXSwgbm90aWNlOiBGaWx0ZXJlZE5vdGljZSkge1xuICAgIGNvbnN0IGR5bmFtaWNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICAgIGZvciAoY29uc3QgY29tcCBvZiBjb21wcykge1xuICAgICAgaWYgKGNvbXAuZHluYW1pY05hbWUpIHtcbiAgICAgICAgZHluYW1pY1ZhbHVlc1tjb21wLmR5bmFtaWNOYW1lXSA9IGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0gPz8gW107XG4gICAgICAgIGR5bmFtaWNWYWx1ZXNbY29tcC5keW5hbWljTmFtZV0ucHVzaChjb21wLmR5bmFtaWNWYWx1ZSA/PyBjb21wLnZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgT2JqZWN0LmVudHJpZXMoZHluYW1pY1ZhbHVlcykpIHtcbiAgICAgIG5vdGljZS5hZGREeW5hbWljVmFsdWUoa2V5LCB2YWx1ZXMuam9pbignLCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJlYXQgJ2ZyYW1ld29yaycgYXMgYW4gYWxpYXMgZm9yIGVpdGhlciBgYXdzLWNkay1saWIuYCBvciBgQGF3cy1jZGsvY29yZS5gLlxuICAgKlxuICAgKiBCZWNhdXNlIGl0J3MgRUlUSEVSIGBhd3MtY2RrLWxpYmAgb3IgYEBhd3MtY2RrL2NvcmVgLCB3ZSBuZWVkIHRvIGFkZCBtdWx0aXBsZVxuICAgKiBhcnJheXMgYXQgdGhlIHRvcCBsZXZlbC5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHJlc29sdmVBbGlhc2VzKG9yczogQ29tcG9uZW50W11bXSk6IENvbXBvbmVudFtdW10ge1xuICAgIHJldHVybiBvcnMuZmxhdE1hcChhbmRzID0+IHtcbiAgICAgIGNvbnN0IGhhc0ZyYW1ld29yayA9IGFuZHMuZmluZChjID0+IGMubmFtZSA9PT0gJ2ZyYW1ld29yaycpO1xuICAgICAgaWYgKCFoYXNGcmFtZXdvcmspIHtcbiAgICAgICAgcmV0dXJuIFthbmRzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYW5kcy5tYXAoYyA9PiBjLm5hbWUgPT09ICdmcmFtZXdvcmsnID8geyAuLi5jLCBuYW1lOiAnQGF3cy1jZGsvY29yZS4nIH0gOiBjKSxcbiAgICAgICAgYW5kcy5tYXAoYyA9PiBjLm5hbWUgPT09ICdmcmFtZXdvcmsnID8geyAuLi5jLCBuYW1lOiAnYXdzLWNkay1saWIuJyB9IDogYyksXG4gICAgICBdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIGNvbnN0cnVjdCB0cmVlIGZyb20gdGhlIGdpdmVuIGRpcmVjdG9yeSBhbmQgcmV0dXJuIGl0cyBjb21wb25lbnRzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjb25zdHJ1Y3RUcmVlQ29tcG9uZW50cyhtYW5pZmVzdERpcjogc3RyaW5nKTogQWN0dWFsQ29tcG9uZW50W10ge1xuICAgIGNvbnN0IHRyZWUgPSBsb2FkVHJlZUZyb21EaXIobWFuaWZlc3REaXIpO1xuICAgIGlmICghdHJlZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHJldDogQWN0dWFsQ29tcG9uZW50W10gPSBbXTtcbiAgICByZWN1cnNlKHRyZWUpO1xuICAgIHJldHVybiByZXQ7XG5cbiAgICBmdW5jdGlvbiByZWN1cnNlKHg6IENvbnN0cnVjdFRyZWVOb2RlKSB7XG4gICAgICBpZiAoeC5jb25zdHJ1Y3RJbmZvPy5mcW4gJiYgeC5jb25zdHJ1Y3RJbmZvPy52ZXJzaW9uKSB7XG4gICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICBuYW1lOiB4LmNvbnN0cnVjdEluZm8/LmZxbixcbiAgICAgICAgICB2ZXJzaW9uOiB4LmNvbnN0cnVjdEluZm8/LnZlcnNpb24sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIE9iamVjdC52YWx1ZXMoeC5jaGlsZHJlbiA/PyB7fSkpIHtcbiAgICAgICAgcmVjdXJzZShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmludGVyZmFjZSBBY3R1YWxDb21wb25lbnQge1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29tcG9uZW50XG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJZiBtYXRjaGVkLCB1bmRlciB3aGF0IG5hbWUgc2hvdWxkIGl0IGJlIGFkZGVkIHRvIHRoZSBzZXQgb2YgZHluYW1pYyB2YWx1ZXNcbiAgICpcbiAgICogVGhlc2Ugd2lsbCBiZSB1c2VkIHRvIHN1YnN0aXR1dGUgcGxhY2Vob2xkZXJzIGluIHRoZSBtZXNzYWdlIHN0cmluZywgd2hlcmVcbiAgICogcGxhY2Vob2xkZXJzIGxvb2sgbGlrZSBge3Jlc29sdmU6WFlafWAuXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29tcG9uZW50IHdpdGggdGhlIHNhbWUgZHluYW1pYyBuYW1lLCB0aGV5IGFyZVxuICAgKiBqb2luZWQgYnkgJywnLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIERvbid0IGFkZCB0byB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzLlxuICAgKi9cbiAgcmVhZG9ubHkgZHluYW1pY05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIElmIG1hdGNoZWQsIHdoYXQgd2Ugc2hvdWxkIHB1dCBpbiB0aGUgc2V0IG9mIGR5bmFtaWMgdmFsdWVzIGluc3N0ZWFkIG9mIHRoZSB2ZXJzaW9uLlxuICAgKlxuICAgKiBPbmx5IHVzZWQgaWYgYGR5bmFtaWNOYW1lYCBpcyBzZXQ7IGJ5IGRlZmF1bHQgd2Ugd2lsbCBhZGQgdGhlIGFjdHVhbCB2ZXJzaW9uXG4gICAqIG9mIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVGhlIHZlcnNpb24uXG4gICAqL1xuICByZWFkb25seSBkeW5hbWljVmFsdWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYSBib290c3RyYXBwZWQgZW52aXJvbm1lbnQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQm9vdHN0cmFwcGVkRW52aXJvbm1lbnQge1xuICByZWFkb25seSBib290c3RyYXBTdGFja1ZlcnNpb246IG51bWJlcjtcbiAgcmVhZG9ubHkgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBub3RpY2VzIHRoZSBDTEkgY2FuIGRpc3BsYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpY2VzIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoaXMgcmVwbGFjZXMgdGhlIHNpbmdsZXRvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlKHByb3BzOiBOb3RpY2VzUHJvcHMpOiBOb3RpY2VzIHtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG5ldyBOb3RpY2VzKHByb3BzKTtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuIE1heSByZXR1cm4gYHVuZGVmaW5lZGAgaWYgYGNyZWF0ZWAgaGFzIG5vdCBiZWVuIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0KCk6IE5vdGljZXMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIF9pbnN0YW5jZTogTm90aWNlcyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRleHQ6IENvbnRleHQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3V0cHV0OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2hvdWxkRGlzcGxheTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBhY2tub3dsZWRnZWRJc3N1ZU51bWJlcnM6IFNldDxOdW1iZXI+O1xuICBwcml2YXRlIHJlYWRvbmx5IGluY2x1ZGVBY2tub3dsZWdkZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgaHR0cE9wdGlvbnM6IFNka0h0dHBPcHRpb25zO1xuXG4gIHByaXZhdGUgZGF0YTogU2V0PE5vdGljZT4gPSBuZXcgU2V0KCk7XG5cbiAgLy8gc2V0cyBkb24ndCBkZWR1cGxpY2F0ZSBpbnRlcmZhY2VzLCBzbyB3ZSB1c2UgYSBtYXAuXG4gIHByaXZhdGUgcmVhZG9ubHkgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBNYXA8c3RyaW5nLCBCb290c3RyYXBwZWRFbnZpcm9ubWVudD4gPSBuZXcgTWFwKCk7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcm9wczogTm90aWNlc1Byb3BzKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICB0aGlzLmFja25vd2xlZGdlZElzc3VlTnVtYmVycyA9IG5ldyBTZXQodGhpcy5jb250ZXh0LmdldCgnYWNrbm93bGVkZ2VkLWlzc3VlLW51bWJlcnMnKSA/PyBbXSk7XG4gICAgdGhpcy5pbmNsdWRlQWNrbm93bGVnZGVkID0gcHJvcHMuaW5jbHVkZUFja25vd2xlZGdlZCA/PyBmYWxzZTtcbiAgICB0aGlzLm91dHB1dCA9IHByb3BzLm91dHB1dCA/PyAnY2RrLm91dCc7XG4gICAgdGhpcy5zaG91bGREaXNwbGF5ID0gcHJvcHMuc2hvdWxkRGlzcGxheSA/PyB0cnVlO1xuICAgIHRoaXMuaHR0cE9wdGlvbnMgPSBwcm9wcy5odHRwT3B0aW9ucyA/PyB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBib290c3RyYXAgaW5mb3JtYXRpb24gdG8gZmlsdGVyIG9uLiBDYW4gaGF2ZSBtdWx0aXBsZSB2YWx1ZXNcbiAgICogaW4gY2FzZSBvZiBtdWx0aS1lbnZpcm9ubWVudCBkZXBsb3ltZW50cy5cbiAgICovXG4gIHB1YmxpYyBhZGRCb290c3RyYXBwZWRFbnZpcm9ubWVudChib290c3RyYXBwZWQ6IEJvb3RzdHJhcHBlZEVudmlyb25tZW50KSB7XG4gICAgY29uc3Qga2V5ID0gW1xuICAgICAgYm9vdHN0cmFwcGVkLmJvb3RzdHJhcFN0YWNrVmVyc2lvbixcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5hY2NvdW50LFxuICAgICAgYm9vdHN0cmFwcGVkLmVudmlyb25tZW50LnJlZ2lvbixcbiAgICAgIGJvb3RzdHJhcHBlZC5lbnZpcm9ubWVudC5uYW1lLFxuICAgIF0uam9pbignOicpO1xuICAgIHRoaXMuYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzLnNldChrZXksIGJvb3RzdHJhcHBlZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgbGlzdCBvZiBub3RpY2VzIHRoaXMgaW5zdGFuY2UgaXMgYXdhcmUgb2YuXG4gICAqIFRvIG1ha2Ugc3VyZSB0aGlzIG5ldmVyIGNyYXNoZXMgdGhlIENMSSBwcm9jZXNzLCBhbGwgZmFpbHVyZXMgYXJlIGNhdWdodCBhbmRcbiAgICogc2lsZW50bHkgbG9nZ2VkLlxuICAgKlxuICAgKiBJZiBjb250ZXh0IGlzIGNvbmZpZ3VyZWQgdG8gbm90IGRpc3BsYXkgbm90aWNlcywgdGhpcyB3aWxsIG5vLW9wLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlZnJlc2gob3B0aW9uczogTm90aWNlc1JlZnJlc2hPcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuc2hvdWxkRGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB1bmRlcmx5aW5nRGF0YVNvdXJjZSA9IG9wdGlvbnMuZGF0YVNvdXJjZSA/PyBuZXcgV2Vic2l0ZU5vdGljZURhdGFTb3VyY2UodGhpcy5odHRwT3B0aW9ucyk7XG4gICAgICBjb25zdCBkYXRhU291cmNlID0gbmV3IENhY2hlZERhdGFTb3VyY2UoQ0FDSEVfRklMRV9QQVRILCB1bmRlcmx5aW5nRGF0YVNvdXJjZSwgb3B0aW9ucy5mb3JjZSA/PyBmYWxzZSk7XG4gICAgICBjb25zdCBub3RpY2VzID0gYXdhaXQgZGF0YVNvdXJjZS5mZXRjaCgpO1xuICAgICAgdGhpcy5kYXRhID0gbmV3IFNldCh0aGlzLmluY2x1ZGVBY2tub3dsZWdkZWQgPyBub3RpY2VzIDogbm90aWNlcy5maWx0ZXIobiA9PiAhdGhpcy5hY2tub3dsZWRnZWRJc3N1ZU51bWJlcnMuaGFzKG4uaXNzdWVOdW1iZXIpKSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBkZWJ1ZyhgQ291bGQgbm90IHJlZnJlc2ggbm90aWNlczogJHtlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwbGF5IHRoZSByZWxldmFudCBub3RpY2VzICh1bmxlc3MgY29udGV4dCBkaWN0YXRlcyB3ZSBzaG91bGRuJ3QpLlxuICAgKi9cbiAgcHVibGljIGRpc3BsYXkob3B0aW9uczogTm90aWNlc1ByaW50T3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNob3VsZERpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZE5vdGljZXMgPSBOb3RpY2VzRmlsdGVyLmZpbHRlcih7XG4gICAgICBkYXRhOiBBcnJheS5mcm9tKHRoaXMuZGF0YSksXG4gICAgICBjbGlWZXJzaW9uOiB2ZXJzaW9uTnVtYmVyKCksXG4gICAgICBvdXREaXI6IHRoaXMub3V0cHV0LFxuICAgICAgYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzOiBBcnJheS5mcm9tKHRoaXMuYm9vdHN0cmFwcGVkRW52aXJvbm1lbnRzLnZhbHVlcygpKSxcbiAgICB9KTtcblxuICAgIGlmIChmaWx0ZXJlZE5vdGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgaW5mbygnJyk7XG4gICAgICBpbmZvKCdOT1RJQ0VTICAgICAgICAgKFdoYXRcXCdzIHRoaXM/IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay93aWtpL0NMSS1Ob3RpY2VzKScpO1xuICAgICAgaW5mbygnJyk7XG4gICAgICBmb3IgKGNvbnN0IGZpbHRlcmVkIG9mIGZpbHRlcmVkTm90aWNlcykge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmaWx0ZXJlZC5mb3JtYXQoKTtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXJlZC5ub3RpY2Uuc2V2ZXJpdHkpIHtcbiAgICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgIHdhcm5pbmcoZm9ybWF0dGVkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGVycm9yKGZvcm1hdHRlZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaW5mbyhmb3JtYXR0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGluZm8oJycpO1xuICAgICAgfVxuICAgICAgaW5mbyhgSWYgeW91IGRvbuKAmXQgd2FudCB0byBzZWUgYSBub3RpY2UgYW55bW9yZSwgdXNlIFwiY2RrIGFja25vd2xlZGdlIDxpZD5cIi4gRm9yIGV4YW1wbGUsIFwiY2RrIGFja25vd2xlZGdlICR7ZmlsdGVyZWROb3RpY2VzWzBdLm5vdGljZS5pc3N1ZU51bWJlcn1cIi5gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zaG93VG90YWwgPz8gZmFsc2UpIHtcbiAgICAgIGluZm8oJycpO1xuICAgICAgaW5mbyhgVGhlcmUgYXJlICR7ZmlsdGVyZWROb3RpY2VzLmxlbmd0aH0gdW5hY2tub3dsZWRnZWQgbm90aWNlKHMpLmApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudCB7XG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJhbmdlIG9mIGFmZmVjdGVkIHZlcnNpb25zXG4gICAqL1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWNlIHtcbiAgdGl0bGU6IHN0cmluZztcbiAgaXNzdWVOdW1iZXI6IG51bWJlcjtcbiAgb3ZlcnZpZXc6IHN0cmluZztcbiAgLyoqXG4gICAqIEEgc2V0IG9mIGFmZmVjdGVkIGNvbXBvbmVudHNcbiAgICpcbiAgICogVGhlIGNhbm9uaWNhbCBmb3JtIG9mIGEgbGlzdCBvZiBjb21wb25lbnRzIGlzIGluIERpc2p1bmN0aXZlIE5vcm1hbCBGb3JtXG4gICAqIChpLmUuLCBhbiBPUiBvZiBBTkRzKS4gVGhpcyBpcyB0aGUgZm9ybSB3aGVuIHRoZSBsaXN0IG9mIGNvbXBvbmVudHMgaXMgYVxuICAgKiBkb3VibHkgbmVzdGVkIGFycmF5OiB0aGUgbm90aWNlIG1hdGNoZXMgaWYgYWxsIGNvbXBvbmVudHMgb2YgYXQgbGVhc3Qgb25lXG4gICAqIG9mIHRoZSB0b3AtbGV2ZWwgYXJyYXkgbWF0Y2hlcy5cbiAgICpcbiAgICogSWYgdGhlIGBjb21wb25lbnRzYCBpcyBhIHNpbmdsZS1sZXZlbCBhcnJheSwgaXQgaXMgZXZhbHVhdGVkIGFzIGFuIE9SOyBpdFxuICAgKiBtYXRjaGVzIGlmIGFueSBvZiB0aGUgY29tcG9uZW50cyBtYXRjaGVzLlxuICAgKi9cbiAgY29tcG9uZW50czogQXJyYXk8Q29tcG9uZW50IHwgQ29tcG9uZW50W10+O1xuICBzY2hlbWFWZXJzaW9uOiBzdHJpbmc7XG4gIHNldmVyaXR5Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGdpdmVuIGNvbXBvbmVudHMgc3RydWN0dXJlIGludG8gRE5GIGZvcm1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50cyh4czogQXJyYXk8Q29tcG9uZW50IHwgQ29tcG9uZW50W10+KTogQ29tcG9uZW50W11bXSB7XG4gIHJldHVybiB4cy5tYXAoeCA9PiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNvbmp1bmN0aW9uKHhzOiBDb21wb25lbnRbXSk6IHN0cmluZyB7XG4gIHJldHVybiB4cy5tYXAoYyA9PiBgJHtjLm5hbWV9OiAke2MudmVyc2lvbn1gKS5qb2luKCcgQU5EICcpO1xufVxuXG4vKipcbiAqIE5vdGljZSBhZnRlciBwYXNzaW5nIHRoZSBmaWx0ZXIuIEEgZmlsdGVyIGNhbiBhdWdtZW50IGEgbm90aWNlIHdpdGhcbiAqIGR5bmFtaWMgdmFsdWVzIGFzIGl0IGhhcyBhY2Nlc3MgdG8gdGhlIGR5bmFtaWMgbWF0Y2hpbmcgZGF0YS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZpbHRlcmVkTm90aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkeW5hbWljVmFsdWVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBub3RpY2U6IE5vdGljZSkge1xuICB9XG5cbiAgcHVibGljIGFkZER5bmFtaWNWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZHluYW1pY1ZhbHVlc1tge3Jlc29sdmU6JHtrZXl9fWBdID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgZm9ybWF0KCk6IHN0cmluZyB7XG4gICAgY29uc3QgY29tcG9uZW50c1ZhbHVlID0gbm9ybWFsaXplQ29tcG9uZW50cyh0aGlzLm5vdGljZS5jb21wb25lbnRzKS5tYXAocmVuZGVyQ29uanVuY3Rpb24pLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZUR5bmFtaWNWYWx1ZXMoW1xuICAgICAgYCR7dGhpcy5ub3RpY2UuaXNzdWVOdW1iZXJ9XFx0JHt0aGlzLm5vdGljZS50aXRsZX1gLFxuICAgICAgdGhpcy5mb3JtYXRPdmVydmlldygpLFxuICAgICAgYFxcdEFmZmVjdGVkIHZlcnNpb25zOiAke2NvbXBvbmVudHNWYWx1ZX1gLFxuICAgICAgYFxcdE1vcmUgaW5mb3JtYXRpb24gYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvJHt0aGlzLm5vdGljZS5pc3N1ZU51bWJlcn1gLFxuICAgIF0uam9pbignXFxuXFxuJykgKyAnXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdE92ZXJ2aWV3KCkge1xuICAgIGNvbnN0IHdyYXAgPSAoczogc3RyaW5nKSA9PiBzLnJlcGxhY2UoLyg/IVteXFxuXXsxLDYwfSQpKFteXFxuXXsxLDYwfSlcXHMvZywgJyQxXFxuJyk7XG5cbiAgICBjb25zdCBoZWFkaW5nID0gJ092ZXJ2aWV3OiAnO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IGBcXG5cXHQkeycgJy5yZXBlYXQoaGVhZGluZy5sZW5ndGgpfWA7XG4gICAgY29uc3QgY29udGVudCA9IHdyYXAodGhpcy5ub3RpY2Uub3ZlcnZpZXcpXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuam9pbihzZXBhcmF0b3IpO1xuXG4gICAgcmV0dXJuICdcXHQnICsgaGVhZGluZyArIGNvbnRlbnQ7XG4gIH1cblxuICBwcml2YXRlIHJlc29sdmVEeW5hbWljVmFsdWVzKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKHRoaXMuZHluYW1pY1ZhbHVlcykuam9pbignfCcpLCAnZycpO1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKHBhdHRlcm4sIChtYXRjaGVkKSA9PiB0aGlzLmR5bmFtaWNWYWx1ZXNbbWF0Y2hlZF0gPz8gbWF0Y2hlZCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RpY2VEYXRhU291cmNlIHtcbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT47XG59XG5cbmV4cG9ydCBjbGFzcyBXZWJzaXRlTm90aWNlRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFNka0h0dHBPcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFNka0h0dHBPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSAzMDAwO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgcmVxOiBDbGllbnRSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuXG4gICAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgIHJlcS5kZXN0cm95KG5ldyBUb29sa2l0RXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgdGltZXIudW5yZWYoKTtcblxuICAgICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGFnZW50OiBBd3NDbGlDb21wYXRpYmxlLnByb3h5QWdlbnQodGhpcy5vcHRpb25zKSxcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcSA9IGh0dHBzLmdldCgnaHR0cHM6Ly9jbGkuY2RrLmRldi10b29scy5hd3MuZGV2L25vdGljZXMuanNvbicsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICByZXMgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgICAgICAgICAgcmVzLnNldEVuY29kaW5nKCd1dGY4Jyk7XG4gICAgICAgICAgICAgIGxldCByYXdEYXRhID0gJyc7XG4gICAgICAgICAgICAgIHJlcy5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIHJhd0RhdGEgKz0gY2h1bms7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSkubm90aWNlcyBhcyBOb3RpY2VbXTtcbiAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKFwiJ25vdGljZXMnIGtleSBpcyBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVidWcoJ05vdGljZXMgcmVmcmVzaGVkJyk7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEgPz8gW10pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBUb29sa2l0RXJyb3IoYEZhaWxlZCB0byBwYXJzZSBub3RpY2VzOiAke2Zvcm1hdEVycm9yTWVzc2FnZShlKX1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlczogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbm90aWNlcy4gU3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICByZWplY3QobmV3IFRvb2xraXRFcnJvcihgSFRUUFMgJ2dldCcgY2FsbCB0aHJldyBhbiBlcnJvcjogJHtmb3JtYXRFcnJvck1lc3NhZ2UoZSl9YCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBDYWNoZWROb3RpY2VzIHtcbiAgZXhwaXJhdGlvbjogbnVtYmVyO1xuICBub3RpY2VzOiBOb3RpY2VbXTtcbn1cblxuY29uc3QgVElNRV9UT19MSVZFX1NVQ0NFU1MgPSA2MCAqIDYwICogMTAwMDsgLy8gMSBob3VyXG5jb25zdCBUSU1FX1RPX0xJVkVfRVJST1IgPSAxICogNjAgKiAxMDAwOyAvLyAxIG1pbnV0ZVxuXG5leHBvcnQgY2xhc3MgQ2FjaGVkRGF0YVNvdXJjZSBpbXBsZW1lbnRzIE5vdGljZURhdGFTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpbGVOYW1lOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkYXRhU291cmNlOiBOb3RpY2VEYXRhU291cmNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2tpcENhY2hlPzogYm9vbGVhbikge1xuICB9XG5cbiAgYXN5bmMgZmV0Y2goKTogUHJvbWlzZTxOb3RpY2VbXT4ge1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBjb25zdCBkYXRhID0gY2FjaGVkRGF0YS5ub3RpY2VzO1xuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBjYWNoZWREYXRhLmV4cGlyYXRpb24gPz8gMDtcblxuICAgIGlmIChEYXRlLm5vdygpID4gZXhwaXJhdGlvbiB8fCB0aGlzLnNraXBDYWNoZSkge1xuICAgICAgY29uc3QgZnJlc2hEYXRhID0gYXdhaXQgdGhpcy5mZXRjaElubmVyKCk7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoZnJlc2hEYXRhKTtcbiAgICAgIHJldHVybiBmcmVzaERhdGEubm90aWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoYFJlYWRpbmcgY2FjaGVkIG5vdGljZXMgZnJvbSAke3RoaXMuZmlsZU5hbWV9YCk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoSW5uZXIoKTogUHJvbWlzZTxDYWNoZWROb3RpY2VzPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cGlyYXRpb246IERhdGUubm93KCkgKyBUSU1FX1RPX0xJVkVfU1VDQ0VTUyxcbiAgICAgICAgbm90aWNlczogYXdhaXQgdGhpcy5kYXRhU291cmNlLmZldGNoKCksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKGBDb3VsZCBub3QgcmVmcmVzaCBub3RpY2VzOiAke2V9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHBpcmF0aW9uOiBEYXRlLm5vdygpICsgVElNRV9UT19MSVZFX0VSUk9SLFxuICAgICAgICBub3RpY2VzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkKCk6IFByb21pc2U8Q2FjaGVkTm90aWNlcz4ge1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHtcbiAgICAgIGV4cGlyYXRpb246IDAsXG4gICAgICBub3RpY2VzOiBbXSxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmcy5leGlzdHNTeW5jKHRoaXMuZmlsZU5hbWUpXG4gICAgICAgID8gYXdhaXQgZnMucmVhZEpTT04odGhpcy5maWxlTmFtZSkgYXMgQ2FjaGVkTm90aWNlc1xuICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhgRmFpbGVkIHRvIGxvYWQgbm90aWNlcyBmcm9tIGNhY2hlOiAke2V9YCk7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2F2ZShjYWNoZWQ6IENhY2hlZE5vdGljZXMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMud3JpdGVKU09OKHRoaXMuZmlsZU5hbWUsIGNhY2hlZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoYEZhaWxlZCB0byBzdG9yZSBub3RpY2VzIGluIHRoZSBjYWNoZTogJHtlfWApO1xuICAgIH1cbiAgfVxufVxuIl19