import os
import shutil
import asyncio
import aiofiles
from enum import StrEnum
from typing import Callable
from cookiecutter.main import cookiecutter
from fastapi_forge.dtos import ProjectSpec, Model
from fastapi_forge.jinja import (
    render_model_to_dto,
    render_model_to_model,
    render_model_to_dao,
    render_model_to_routers,
    render_model_to_post_test,
    render_model_to_get_test,
    render_model_to_get_id_test,
    render_model_to_patch_test,
    render_model_to_delete_test,
)
from fastapi_forge.string_utils import camel_to_snake
from fastapi_forge.logger import logger


def _get_template_path() -> str:
    """Return the absolute path to the project template directory."""
    template_path = os.path.join(os.path.dirname(__file__), "template")
    if not os.path.exists(template_path):
        raise RuntimeError(f"Template directory not found: {template_path}")
    return template_path


async def _teardown_project(project_name: str) -> None:
    """Forcefully remove the project directory and all its contents."""
    project_dir = os.path.join(os.getcwd(), project_name)
    if os.path.exists(project_dir):
        await asyncio.to_thread(shutil.rmtree, project_dir)
        logger.info(f"Removed project directory: {project_dir}")


async def build_project(spec: ProjectSpec) -> None:
    """Create a new project using the provided template and specifications."""
    try:
        builder = ProjectBuilder(spec.project_name, None)
        await builder.build_artifacts(spec.models)

        template_path = _get_template_path()
        cookiecutter(
            template_path,
            output_dir=os.getcwd(),
            no_input=True,
            overwrite_if_exists=True,
            extra_context={
                **spec.model_dump(exclude={"models"}),
                "models": {
                    "models": [model.model_dump() for model in spec.models],
                },
            },
        )
        logger.info(f"Project '{spec.project_name}' created successfully.")
    except Exception as e:
        logger.error(f"Failed to create project: {e}")
        await _teardown_project(spec.project_name)
        raise


class HttpMethod(StrEnum):
    GET = "get"
    GET_ID = "get_id"
    POST = "post"
    PATCH = "patch"
    DELETE = "delete"


TEST_RENDERERS: dict[HttpMethod, Callable[[Model], str]] = {
    HttpMethod.GET: render_model_to_get_test,
    HttpMethod.GET_ID: render_model_to_get_id_test,
    HttpMethod.POST: render_model_to_post_test,
    HttpMethod.PATCH: render_model_to_patch_test,
    HttpMethod.DELETE: render_model_to_delete_test,
}


class ProjectBuilder:
    """Handles the creation of project artifacts."""

    def __init__(self, project_name: str, base_path: str | None = None) -> None:
        self.project_name = project_name
        self.base_path = base_path or os.getcwd()
        self.project_dir = os.path.join(self.base_path, self.project_name)
        self.src_dir = os.path.join(self.project_dir, "src")

    async def _create_directory(self, path: str) -> None:
        """Create a directory if it doesn't exist."""
        if not os.path.exists(path):
            os.makedirs(path)
            logger.info(f"Created directory: {path}")

    async def _write_file(self, path: str, content: str) -> None:
        """Write content to a file."""
        try:
            async with aiofiles.open(path, "w") as file:
                await file.write(content)
            logger.info(f"Created file: {path}")
        except IOError as e:
            logger.error(f"Failed to write file {path}: {e}")
            raise

    async def _init_project_directories(self) -> None:
        """Initialize project directories."""
        await self._create_directory(self.project_dir)
        await self._create_directory(self.src_dir)

    async def _create_module_path(self, module: str) -> str:
        """Create a path for a module (e.g., dtos, models, daos, routes)."""
        path = os.path.join(self.src_dir, module)
        await self._create_directory(path)
        return path

    async def _write_artifact(
        self,
        module: str,
        model: Model,
        render_func: Callable[[Model], str],
    ) -> None:
        """Write an artifact (e.g., DTO, model, DAO, router) to a file."""
        path = await self._create_module_path(module)
        file_name = f"{camel_to_snake(model.name)}_{module}.py"
        file_path = os.path.join(path, file_name)
        await self._write_file(file_path, render_func(model))

    async def _write_tests(self, model: Model) -> None:
        """Write test files for a model."""
        test_dir = os.path.join(
            self.project_dir, "tests", "endpoint_tests", camel_to_snake(model.name)
        )
        await self._create_directory(test_dir)

        init_file = os.path.join(test_dir, "__init__.py")
        await self._write_file(
            init_file, "# Automatically generated by FastAPI Forge\n"
        )

        for method, render_func in TEST_RENDERERS.items():
            method_suffix = "id" if method == HttpMethod.GET_ID else ""
            file_name = (
                f"test_{method.value.replace('_id', '')}_"
                f"{camel_to_snake(model.name)}"
                f"{f'_{method_suffix}' if method_suffix else ''}.py"
            )
            file_path = os.path.join(test_dir, file_name)
            await self._write_file(file_path, render_func(model))

    async def build_artifacts(self, models: list[Model]) -> None:
        """Build all project artifacts for the given models."""
        await self._init_project_directories()

        for model in models:
            await self._write_artifact("dtos", model, render_model_to_dto)
            await self._write_artifact("models", model, render_model_to_model)
            await self._write_artifact("daos", model, render_model_to_dao)
            await self._write_artifact("routes", model, render_model_to_routers)
            await self._write_tests(model)
