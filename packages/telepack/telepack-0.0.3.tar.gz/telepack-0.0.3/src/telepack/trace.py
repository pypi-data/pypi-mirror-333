# Copyright 2025 Koales Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from functools import partial, wraps
from newrelic_telemetry_sdk import Span, SpanClient
from .endpoints import TRACE_API_HOST_EU

__all__ = (
    "timed",
    "TimedContext",
    "TraceLogger",
)

# Class to log spans (and by implication the trace that they belong to) to New Relic
class TraceLogger(object):
    _license_key = None
    _api_host = None

    _client_service_name = None
    _client_host = None

    _span_client = None

    _span_batch = []
    _batch_send = True
    _auto_flush = True

    trace_id = None

    _span_parent_id_stack = []

    _active = False    
    _configured = False
    
    def __init__(
        self,
        client_service_name,
        client_host,
        license_key=None,
        use_kaggle_secret=False,
        license_key_secret_name=None,
        early_init=True,
        eu_hosted=False,
        batch_send=True,
        auto_flush=True,
        trace_id=None,
        ):
        if license_key is not None:
            TraceLogger._license_key = license_key
        else:
            if use_kaggle_secret:
                # Import Kaggle Secrets if available, will raise an exception if not installed
                from kaggle_secrets import UserSecretsClient
                TraceLogger._license_key = UserSecretsClient().get_secret(license_key_secret_name)
                
        if TraceLogger._license_key is None or TraceLogger._license_key == "":
            raise Exception("No license key provided, must provide license key directly or Kaggle secret name")
        
        if eu_hosted:
            TraceLogger._api_host = TRACE_API_HOST_EU

        TraceLogger._client_service_name = client_service_name
        TraceLogger._client_host = client_host

        TraceLogger._batch_send = batch_send
        TraceLogger._auto_flush = auto_flush
        TraceLogger.trace_id = trace_id

        # Clear any previous spans
        TraceLogger._span_batch = []
        TraceLogger._span_parent_id_stack = []
        
        TraceLogger._configured = True
        
        if early_init:
            TraceLogger._init_client(force=True)

        TraceLogger.enable()

    @staticmethod
    def enable():
        TraceLogger._active = True

    @staticmethod
    def disable():
        TraceLogger._active = False

    @staticmethod
    def is_enabled():
        return TraceLogger._active == True

    @staticmethod
    def _init_client(force=False):
        if force or TraceLogger._span_client is None:
            TraceLogger._span_client = SpanClient(TraceLogger._license_key, host=TraceLogger._api_host)
            
            # We don't need the license key anymore, so clear it
            TraceLogger._license_key = None

    @staticmethod
    def guard_is_configured():
        if not TraceLogger._configured:
            raise Exception("TraceLogger not configured")

    @staticmethod
    def new_trace(trace_id=None):
        # Start a new trace by changing the trace_id used for future spans
        # Used to re-use a class instance for multiple traces
        # If no trace ID is provided, the trace_id will be auto-generated by the first span
        TraceLogger.trace_id = trace_id

    @staticmethod
    def flush():
        TraceLogger.guard_is_configured()
        TraceLogger._report_span_batch()
    
    @staticmethod
    def log_span(span):
        TraceLogger.guard_is_configured()
        
        if TraceLogger._batch_send:
            TraceLogger._span_batch.append(span)
            
            # Automatically flush and restart the batch if flag is set and
            # there are no parent spans
            # i.e. this is a top-level span
            if TraceLogger._auto_flush and not TraceLogger.has_span_parent():
                TraceLogger.flush()
                TraceLogger.new_trace()
        else:
            TraceLogger._report_single_span(span)

    @staticmethod
    def _report_single_span(span):
        TraceLogger._init_client()
        response = TraceLogger._span_client.send(span)
        response.raise_for_status()

    @staticmethod
    def _report_span_batch():
        if len(TraceLogger._span_batch) == 0:
            # nothing to do, no spans to send
            return
        
        TraceLogger._init_client()

        response = TraceLogger._span_client.send_batch(TraceLogger._span_batch)
        response.raise_for_status()
        
        # clear the batch
        TraceLogger._span_batch = []

    @staticmethod
    def push_span_parent_id(span_id):
        TraceLogger._span_parent_id_stack.append(span_id)
        
    @staticmethod
    def pop_span_parent_id():
        TraceLogger._span_parent_id_stack.pop()

    @staticmethod
    def get_span_parent_id():
        return TraceLogger._span_parent_id_stack[-1] if TraceLogger._span_parent_id_stack else None

    @staticmethod
    def has_span_parent():
        return TraceLogger.get_span_parent_id() is not None

    @staticmethod
    def common_span_attributes():
        return {
            "service.name": TraceLogger._client_service_name,
            "host": TraceLogger._client_host,
        }

def timed(func=None, *, span_name=None):
    """Decorator to log the time taken by the decorated function"""
    # Allow usage with and without optional arguments
    # If the decorator is used with parentheses, func will be None
    if func is None:
        return partial(timed, span_name=span_name)

    @wraps(func)
    def wrapper(*args, **kwargs):
        # Just run the wrapped function if TraceLogger is not active
        if not TraceLogger.is_enabled():
            return func(*args, **kwargs)

        TraceLogger.guard_is_configured()
        
        # Use the name of the function being decorated as the span name by default, otherwise use the provided name
        local_span_name = span_name or func.__name__

        span_kwargs = {
            'name': local_span_name,
            'tags': TraceLogger.common_span_attributes()
            }

        # Set the parent span ID if there is one
        parent_span_id = TraceLogger.get_span_parent_id()
        if parent_span_id is not None:
            span_kwargs['parent_id'] = parent_span_id

        # Combine all spans from the same execution run together into a single trace
        if TraceLogger.trace_id is not None:
            span_kwargs['trace_id'] = TraceLogger.trace_id
        
        with Span(**span_kwargs) as span:
            # Keep the trace ID consistent across all spans within a trace
            # A trace is a set of one or more spans, connected by a common trace ID
            # When executed initially, we will not have a retained trace ID, i.e. this is
            # the first span in a series of spans which together make up a trace
            if TraceLogger.trace_id is None:
                TraceLogger.trace_id = span['trace.id']

            # In case the decorated function itself includes a function call that is also decorated,
            # push this span's ID onto the parent stack
            TraceLogger.push_span_parent_id(span['id'])

            # execute the decorated function
            result = func(*args, **kwargs)
            
            # Remove this span's ID from the parent stack
            TraceLogger.pop_span_parent_id()

        TraceLogger.log_span(span)
        return result
    return wrapper

class TimedContext(object):
    def __init__(self, span_name):
        self._span_name = span_name
        self._span = None

    def __enter__(self):
        TraceLogger.guard_is_configured()

        span_kwargs = {
            'name': self._span_name,
            'tags': TraceLogger.common_span_attributes()
        }

        # Set the parent span ID if there is one
        parent_span_id = TraceLogger.get_span_parent_id()
        if parent_span_id is not None:
            span_kwargs['parent_id'] = parent_span_id

        # Combine all spans from the same execution run together into a single trace
        if TraceLogger.trace_id is not None:
            span_kwargs['trace_id'] = TraceLogger.trace_id

        self._span = Span(**span_kwargs)
        self._span.__enter__() # Manually enter the span context

        # Keep the trace ID consistent across all spans within a trace
        if TraceLogger.trace_id is None:
            TraceLogger.trace_id = self._span['trace.id']

        # Push this span's ID onto the parent stack
        TraceLogger.push_span_parent_id(self._span['id'])
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self._span.__exit__(exc_type, exc_val, exc_tb) # Manually exit the span context

        # Close off this span:
        #  - remove this span's ID from the parent stack
        #  - log the span
        TraceLogger.pop_span_parent_id()
        TraceLogger.log_span(self._span)
        self._span = None
