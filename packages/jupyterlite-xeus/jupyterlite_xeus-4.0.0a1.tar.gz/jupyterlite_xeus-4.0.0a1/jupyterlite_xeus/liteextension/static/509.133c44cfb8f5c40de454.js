"use strict";(self.webpackChunk_jupyterlite_xeus_kernels_extension=self.webpackChunk_jupyterlite_xeus_kernels_extension||[]).push([[509],{151:(e,t,n)=>{n.d(t,{B:()=>s});const s=new(n(262).Token)("@jupyterlite/xeus:IEmpackEnvMetaFile")},509:(e,t,n)=>{n.a(e,(async(e,s)=>{try{n.r(t),n.d(t,{IEmpackEnvMetaFile:()=>i.B,default:()=>p});var r=n(367),a=n(446),o=n(985),c=n(588),i=n(151);const l=await n.e(687).then(n.t.bind(n,687,23));async function u(e){const t=r.URLExt.join(r.PageConfig.getBaseUrl(),e),n=await fetch(t,{method:"GET"});if(!n.ok)throw new Error(`HTTP error! status: ${n.status}`);return await n.json()}const k={id:"@jupyterlite/xeus-kernel:register",autoStart:!0,requires:[c.IKernelSpecs],optional:[a.IServiceWorkerManager,o.IBroadcastChannelWrapper,i.B],activate:async(e,t,n,s,a)=>{let o=[];try{o=await u("xeus/kernels.json")}catch(e){throw console.log(`Could not fetch xeus/kernels.json: ${e}`),e}const c=e.serviceManager.contents;for(const e of o){const o=await u("xeus/kernels/"+e+"/kernel.json");o.name=e,o.dir=e;for(const[e,t]of Object.entries(o.resources))o.resources[e]=r.URLExt.join(r.PageConfig.getBaseUrl(),t);t.register({spec:o,create:async e=>{const t=!!((null==n?void 0:n.enabled)&&(null==s?void 0:s.enabled)||crossOriginIsolated);t?console.info(`${o.name} contents will be synced with Jupyter Contents`):console.warn(`${o.name} contents will NOT be synced with Jupyter Contents`);const r=a?await a.getLink(o):"";return new l.WebWorkerKernel({...e,contentsManager:c,mountDrive:t,kernelSpec:o,empackEnvMetaLink:r})}})}await e.serviceManager.kernelspecs.refreshSpecs()}},p=[{id:"@jupyterlite/xeus:empack-env-meta",autoStart:!0,provides:i.B,activate:()=>({getLink:async e=>{const t=e.name;return`${r.URLExt.join(r.PageConfig.getBaseUrl(),`xeus/kernels/${t}`)}`}})},k];s()}catch(g){s(g)}}),1)}}]);