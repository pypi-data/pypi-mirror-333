from random import randint
import networkx as nx
import openpyxl
import matplotlib.pyplot as plt


class Drevo:
    # получает на вход список и выдаёт два списка, один с узлами, а второй с их цветом
    def cvet_uzlov(self, mas):
        """Данная функция выполняет задачу разделения списка входных данных на рёбра,
            а так же запоминает, к какой групе цвета относиться  каждое ребро,
             Функция принимает список ыеток дерева, обработанных функцией ctenie.
             Пример входных данных:
             ['a b c f g h','a g k'] """

        isxodn_uzl = []  # вспомогательный список, нужный для хранения вершин, которые образуют ребра
        cvet_uzlov = []  # Вспомогательный список, хранящий информацию о том, к какой ветки относится данная ветка
        # Цикл по длине списка входных данных, счётчик i показывает номер ветки которую обрабатывает функция
        for i in range(len(mas)):
            # Запись ветки списка под номером i в вспомогательную переменную
            x = mas[i]
            x = x.split()  # С помощью функции строка.split, ветка, записанная в переменную x, превращается в список
            for j in range(len(x) - 1):  # Цикл, проходящий по длинне списка x - 1
                # Добавление в список двух соседних элементов, которые будут образовывать ребро
                isxodn_uzl.append(x[j] + ' ' + x[j + 1])
                # Добавление номера ветки, к которой относиться ребро записанное в список  isxodn_uzl
                cvet_uzlov.append(i + 1)
        # вывод списка вершин образующих ребра и списка принадлежности каждой вершины к определённой ветке дерева
        return isxodn_uzl, cvet_uzlov

    def otdelno_uzl(self, mas):  # Функция нужна для нахождения всех рёбер в дереве без повторений
        '''
        :param mas: список веток дерева, заданных пользователем, предварительно обработанных функцией ctenie
        :return: список уникальных ребер* дерева.
        Ребро-это две вершины ветки, которые должны быть соединены.
        '''

        con_mass = []  # Вспомогательный список в котором будут храниться ребра дерева
        for i in range(len(mas)):  # Цикл переберающий все ветки из входных данных
            x = mas[i].split()  # Вспомогательная переменная,
            # хронящая ветку из списка входных данных под номером i (с помощью строка.split(), из строки превращается в список)

            # Цикл, запущенный до длинны  списка x -1 (переберает все вершины из ветки лежащей в x)
            for j in range(len(x) - 1):
                # добавляет в вспомогательный список ребро, которое образовано двумя соседними вершинами в ветке x
                con_mass.append(x[j] + ' ' + x[j + 1])
        # вывод списка ребер, с помощью list(set()), из списка удаляются все повторяющиеся элементы и остаются только уникальные ребра
        return list(set(con_mass))

    def conus(self, mas, iskom):
        '''
        Данная функция строит конус дерева по элементу iskom.
            :param mas: список веток дерева заданнных пользователем, обработанных функцией ctenie
            :param iskom: какая либо вершина в дереве, относительно нее будет строиться конус дерева
            :return: список веток, вершиной в которых является элемент iskom

        '''
        massiv_conusov = []  # Создается вспомогательный список, в котором будут храниться ветки конуса
        for j in mas:  # Цикл, бегущий по веткам дерева из списка mas
            if j.count(iskom) != 0:  # Если в ветке есть элемент iskom, то
                # В вспомогательный список добавляется ветка дерева, с элемента iskom и до конца
                massiv_conusov.append(j[j.index(iskom):])
        return massiv_conusov  # вывод вспомогательного списка.

    # сравнивает значения с исходным цветом узлов с конусом
    def konecha(self, mas_isxod_uzl, cvet_uzlov, conus_mas):
        '''
         Данная функция нужна, что бы программа при построение конуса в дереве, понимала, какие ребра конуса должны быть одного цвета
         на вход подается:
            mas_isxod_uzl - список хранящий ребер в данном дереве формата(['a b','b c'])
            cvet_uzlov -  список хранящий числовые обозначения [1, 2,...,n], каждое число это номер ветки к которой относиться ребро.
            conus_mas - список хранящий ребра  конуса. Пример: ['a b', 'c d']
         на выходе подается список чисел, которые обозначают цвет ребер между узлами из conus_mas связи :[1,2]
         '''

        conus_cvet = []  # Вспомогательный список, в котором будет храниться информация о том, к какой ветке относиться каждое ребро в конусе
        for i in conus_mas:  # Цикл бежащий по элементам conus_mas
            # Добавление в список элемента из списка cveta_uzlov c индексом таким же как у ребра в mas_isxod_uzl
            conus_cvet.append(cvet_uzlov[mas_isxod_uzl.index(i)])
        return conus_cvet  # Вывод списка

    def grupp_cveta_konus(self, mas, isxod):  # для построения конуса
        '''

            :param mas: список строк формата ['a b c v']
            :param isxod: название вершины относительно которой строить сам конус
            :return: конус в виде дерева
        '''
        '''
            Если узлом конуса является крайний элемент дерева не имеющий потомков или элемент которого нет в самом дереве, то функция выведит просто один узел, который
            подавался пользователем в функцию.
        '''

        s = []
        v, n = self.cvet_uzlov(mas)  # запрашивает связи в дереве и цвета ребер
        s.append(
            self.konecha(v, n, self.otdelno_uzl(self.conus(mas, isxod))))  # добавляет в массив s цвета ребер в конусе

        # добавляет в массив s  ребера в конусе
        s.append(self.otdelno_uzl(self.conus(mas, isxod)))

        if s[1] == []:
            # создания пустого дерева
            G = nx.Graph()
            nx.draw_planar(G, with_labels=True)

            # Добавление узла который вводит пользователь
            G.add_node(isxod)
            nx.draw_planar(G, with_labels=True)

            # пока дерева
            plt.show()
            return "конус образован одним элементом, или не имеет отношения к дереву"

        """"создает массив цветов
        которые используются в построение"""
        # создание пустого массива цветов
        mas_cvetov = []
        # запускаем цикл, который генерирует цвета в виде 16тиричного кода, цветов генерируется в 10 раз больше, для того, что бы гарантированно у каждого каждого ребра мог быть свой цвет
        for i in range(len(s[1]) * 10):
            # Генерация 16тиричных кодов и их запись в масив цветов
            mas_cvetov.append('#%06X' % randint(0, 0xFFFFFF))
        # удаление всех повторящихся элементов
        mas_cvetov = list(set(mas_cvetov))

        mas_sviz = s[1]
        mas_uzl_cvet = s[0]
        mass = self.p_sme(mas_sviz)  # создаем сет элементов всего конуса
        # Создаем граф
        G = nx.Graph()

        nx.draw_planar(G, with_labels=True)

        # Добавляем узлы
        G.add_nodes_from(mass)

        # Добавляем ребра с разными цветами
        for i in range(len(mas_sviz) - 1, -1, -1):
            s = mas_sviz[i].split()
            G.add_edge(s[0], s[1], color=mas_cvetov[mas_uzl_cvet[i]])

        '''создаем словарь который содержит верщины и их цвет, первая верншина(корень) всегда красная, так мы обозначаем корень дерева, все остальные голубые'''
        node_colors = {
            isxod: 'red'}  # создание словаря где корень имеет красный цвет
        # удаляем корень из сета всех вершин конуса
        n = mass.pop(mass.index(isxod))
        for i in mass:  # цикл которые заполнит оставшийся словарь где ключем будет вершина, а его аргументом цвет, в данном случем голубой
            node_colors[i] = ('lightblue')

        # Получаем список цветов для ребер
        edge_colors = [G[u][v]['color'] for u, v in G.edges()]

        # Позиции узлов для отображения
        # Рисуем дерево по шаблону planar с разными цветами вершин и ребер
        nx.draw_planar(G, with_labels=True, node_color=[
                       node_colors[n] for n in G.nodes()], edge_color=edge_colors)
        # сохраняем получившееся дерево в формате .jpg
        plt.savefig('image_conus.jpg')
        plt.show()  # показываем дерево

        '''
        Функция на вход получает массив строк типа:['a b c d'], а так же элемент isxod который нужен что бы панять от какого элемента строить конус
        на выход функция ничего не возвращает, только делает изображение получившегося конуса
        примечание, для узлов значение обязательно должно храниться в словаре
        '''

    def postroenie(self, mas):
        '''
        :param mas: список веток задаваемыз пользователем, предварительно обработанных функцией ctenie
        :return: Список чисел, каждое число обозначает к какой ветки относиться каждое ребро. Список ребер.
        '''

        '''
        При прочтении документации к данной функции возникает вопрос, почему нельзя просто воспользоваться функцией "cvet_uzlov". Данная функция нужна для того, что бы точно убедиться, 
        что ребра расположены так, как они находятся в ветках дерева.
        '''
        s = []  # Вспомогательный список, который будет хранить в себе список пренадлежности ребра к определенной ветке и сами ребра.
        # С помощью функции cvet_uzlov в вспомогательные переменные "v" и "n
        v, n = self.cvet_uzlov(mas)
        # заносяться список ребер всего дерева и список принадлежности каждой вершины к определеной ветке.
        # Добавление в вспомогательный список цветов ребер.
        s.append(self.konecha(v, n, self.otdelno_uzl(
            self.conus(mas, mas[0][0]))))
        # Добавление в вспомогательный список ребер дерева.
        s.append(self.otdelno_uzl(self.conus(mas, mas[0][0])))
        return s  # Вывод списка

    def uroven(self, mas, c):
        '''
        :param mas: список веток дерева, которое задаёт пользователь, предварительно обработанные функцией ctenie.
        :param c: переменная типа int, обозначающая уровень в дереве, кототрый хочет вывести пользователь.
        :return: строка формата 'с: a b ... g', которая показывает какие вершины лежат на данном уровне в дереве.
        Пример выходных данных: '3: a v f'
        '''

        # Вспомогательный список, в котором будут храниться вершины дерева, которые находяться на искомом уровне.
        uzels = []
        for i in range(len(mas)):  # Запускается цикл по длинне переменной mas.
            # В вспомогательную переменную "x" заносится ветка под номером i, с помошью функции строка.split(), содержащая ветку дерева.
            x = mas[i].split()
            if len(x) >= c:  # Если количество вершин в x>= переменной "c".
                # В вспомогательный список uzels добавляется элемент из обрабатываемой ветки под номером "c".
                uzels.append(x[c - 1])
        # С помощью функций list(set()) в списке uzels, остаются только уникальные элементы.
        uzels = list(set(uzels))
        # Создвется вспомогательная переменная, в которую записывается str(переменная "c") и ":", в ней будет храниться то, что будет возвращать функция.
        stroka_vod = str(c) + ':'
        for i in uzels:  # Цикл по элементам списка uzels.
            # Добавление в строку ответа  " " и элемента из списка uzels
            stroka_vod += ' ' + str(i)
        return stroka_vod  # Возвращение строки

    def codirovka(self, Stroca, Set_elementov):
        '''
        :param Stroca: Ветка дерева обработанная функцией ctenie
        :param Set_elementov: Список уникальных вершин всего дерева
        :return: список чисел, каждое число это номер вершины из переменной Stroca, в списке Set_elementov
        '''

        # Вспомогательный список, в котором будет храниться то, что возвращает данная функция.
        conecn = []
        # С помощью функции строка.split(), переменная Stroca становиться списком.
        Stroca1 = Stroca.split()
        for i in range(len(Stroca1)):  # Цикл по длинне списка Stroca.
            # В список ответа добавляется номер, на котором стоит вершина из списка Stroca в списке Set_elementov
            conecn.append(Set_elementov.index(Stroca1[i]) + 1)
        return conecn  # Возвращение списка

    def p_sme(self, mas):  # список всех вершин без повторений
        '''
        :param mas: список вершин
        :return: отсортированный масив всех вершин без повторений формата ['a','b','c']
        '''

        # строка, которая впосредствии будет представленна в виде отсортированого набора уникальных элементов
        nabor_elementov = ''
        for i in range(len(mas)):
            # добавляем все имеищиеся вершины в строку
            nabor_elementov += mas[i] + ' '
        # удаляем последний элемент который будет ' '
        nabor_elementov = nabor_elementov[:-1]
        # превращаем строку в список и убираем при помощи set() все повторения и снова превращаем set() в список
        nabor_elementov1 = list(set(nabor_elementov.split()))
        # сортируем набор вершин для удобства в будущем
        return sorted(nabor_elementov1)

    def tabl_smegmm(self, mas):  # вход масив входных данных выводит таблицу смежности
        '''

        :param mas: список веток дерева, задаваемых пользователем, предварительно обработанных функцией ctenie.
        :return: таблица смежности всего дерева.
        Пример одного из вариантов работы функции:

          a b c d f
        a 0 1 0 0 1
        b 1 0 0 0 0
        c 0 0 0 0 0
        f 1 0 0 0 0

        '''

        # На основе функции p_sme() в вспомогательную переменную записываются все уникальные вершины в дереве.
        set_elementov = self.p_sme(mas)
        # Вспомогательный список, который будет хранить уникальный код для каждой вершины.
        conechn_mas = []

        for i in range(len(mas)):  # цикл по длинне списка веток
            # Создание и запись уникальных кодов для каждой вершины, на основе функции codirovka
            conechn_mas.append(self.codirovka(mas[i], set_elementov))

        ''' Создание вспомогательной переменной в которой будет храниться таблица смежности, 
            в нее записывается матрица из '0' количество которых равно количеству уникальных вершин в дерева +1 в квадрате, +1 сделано для того,
            что бы в крайнюю верхнюю строку и крайний левый столбец записать вершины  '''
        tablica_smeg = (len(set_elementov) + 1) * ['0']
        for i in range(len(set_elementov) + 1):
            tablica_smeg[i] = (len(set_elementov) + 1) * ['0']

        '''
        заполняем таблицу смежности, если находим один элемент, то симетрично заполняем и второй
        '''

        for i in range(len(conechn_mas)):
            for j in range(len(conechn_mas[i]) - 1):
                tablica_smeg[conechn_mas[i][j]][conechn_mas[i][j + 1]] = '1'
                tablica_smeg[conechn_mas[i][j + 1]][conechn_mas[i][j]] = '1'

        '''
        Дабовляем в крайнюю верхнюю строку вершины дерева, так же поступаем с левой строкой. 
        '''

        tablica_smeg[0][0] = ' '  # убираем верхний левый элемент
        for i in range(len(set_elementov)):
            # заполяем вершины по строке
            tablica_smeg[0][i + 1] = set_elementov[i]
            # завполныем вершины в столбце
            tablica_smeg[i + 1][0] = set_elementov[i]

        return tablica_smeg  # возвращаем таблицу смежности

    def postroenie_grafa(self, mass):
        '''

        :param mass: масиив строк типа:['a b c', 'f g h']
        :return: n-арное дерево построенное по шаблону planar библиотеки NetworkX
        '''

        mas = self.p_sme(mass)  # сет всех элементов
        """"создает массив цветов
        которые используются в построение"""
        mas_cvetov = []  # массив в котором будут лежать все цвета
        for i in range(
                len(mas) * 10):  # Запускаем цикл по генерации цветов, запустил что бы цветов было в 10 раз больше
            # чем самих вершин, это нужно, что бы исключить, что цвета повторяются
            # генерация цветов в 16ти ричной кодировке
            mas_cvetov.append('#%06X' % randint(0, 0xFFFFFF))
        mas_cvetov = list(set(mas_cvetov))  # удаляем все повторяющиеся цвета

        mas_sviz, mas_uzl_cvet = self.cvet_uzlov(mass)

        # Создаем граф
        G = nx.Graph()

        nx.draw_planar(G, with_labels=True)

        # Добавляем узлы
        G.add_nodes_from(mas)

        # Добавляем ребра с разными цветами
        for i in range(len(mas_sviz) - 1, -1, -1):
            s = mas_sviz[i].split()
            G.add_edge(s[0], s[1], color=mas_cvetov[mas_uzl_cvet[i]])

        '''создаем словарь который содержит верщины и их цвет, первая верншина всегда красная, 
        так мы обозначаем корень дерева, все остальные голубые'''
        node_colors = {mass[0][0]: 'red'}
        n = mas.pop(mas.index(mass[0][0]))
        for i in mas:
            node_colors[i] = ('lightblue')

        # Получаем список цветов для ребер
        edge_colors = [G[u][v]['color'] for u, v in G.edges()]

        # Позиции узлов для отображения

        nx.draw_planar(G, with_labels=True, node_color=[
                       node_colors[n] for n in G.nodes()], edge_color=edge_colors)
        plt.savefig('image.jpg')  # сохраняем изображение n-арного дерева
        plt.show()  # рисуем граф

    '''Функция агент фрейм'''

    def agent(self, mas, n):
        '''

        :param mas: масиив строк типа:['a b c', 'f g h']
        :param n: номер ветки
        :return: на выводе мы получим ветку которую запросил пользователь, а так же изображение самой ветки
        '''
        if n > len(mas) or n < 0:  # проверка на наличие данной ветки в дереве, если таковой нет, то выводится 0
            return (0)

        stroka_massiv = mas[n - 1]  # сама ветка

        '''
        построение ветки дерева по шаблону planar библиотеки NetworkX
        '''
        massiv = stroka_massiv.split()  # разделяем ветку на вершины

        G = nx.Graph()  # создаем пустой граф
        G.add_nodes_from(massiv)  # Добавляем в граф все вершины

        # Добавляю связи между элементами
        for i in range(len(massiv) - 1):
            G.add_edge(massiv[i], massiv[i + 1])

        nx.draw_planar(G, with_labels=True)  # строим дерево пошаблону Planar
        plt.savefig('image_agent.jpg')  # сохраняем изображение ветки дерева
        plt.show()  # рисуем ветку дерева по шаблону Planar библиотеки NetworkX

        return stroka_massiv

    def agent_frame(self, mass, n):
        '''
        :param mass: список строк типа:['1: a b c', '2: f g h']
        :param n: номер ветки
        :return: на выводе мы получим ветку которую запросил пользователь, а так же изображение самой ветки
        '''
        return (self.agent(ctenie(mass), n))

    def layer(self, mas, n):
        '''
        :param mas: список строк типа:['a b c', 'f g h']
        :param n: уровень который требуется
        :return: на выводе получаем изображение узлов, а так же сами узлы
        '''

        stroka = []  # массив в котором будут находится все уровни без повторений
        '''
        добавляляем элементы в массив
        '''
        for i in mas:
            lous = i.split()  # разделяем каждую строку, на массив
            if len(lous) >= n and n > 0:
                # добавляем элемент в массив, если такой есть
                stroka.append(lous[n - 1])
        stroka = list(set(stroka))  # удаляем все повторяющиеся элементы
        otvet = ''  # конечная строка, которая будет содержать в себе весь уровень фрейма
        for i in stroka:
            otvet += i + ' '

        mass = self.p_sme(mas)  # сет всех элементов

        """"создает массив цветов
        которые используются в построение"""
        mas_cvetov = []  # массив в котором будут лежать все цвета
        for i in range(
                len(mass) * 10):  # Запускаем цикл по генерации цветов, запустил что бы цветов было в 10 раз больше чемсамих вершин, это нужно, что бы исключить, что цвета повторяются
            # генерация цветов в 16ти ричной кодировке
            mas_cvetov.append('#%06X' % randint(0, 0xFFFFFF))
        mas_cvetov = list(set(mas_cvetov))  # удаляем все повторяющиеся цвета

        mas_sviz, mas_uzl_cvet = self.cvet_uzlov(mas)

        # Создаем граф
        G = nx.Graph()

        nx.draw_planar(G, with_labels=True)

        # Добавляем узлы
        G.add_nodes_from(mass)

        # Добавляем ребра с разными цветами
        for i in range(len(mas_sviz) - 1, -1, -1):
            s = mas_sviz[i].split()
            G.add_edge(s[0], s[1], color=mas_cvetov[mas_uzl_cvet[i]])

        '''создаем словарь который содержит верщины и их цвет, первая верншина всегда красная,
         так мы обозначаем корень дерева, все остальные голубые'''
        '''Дополнительная проверки, если уровень в фрейме равен 1'''
        if n != 1:
            # первый элемент а так же вершина была красной
            node_colors = {mas[0][0]: 'red'}
            for i in stroka:
                node_colors[i] = ('green')  # все вершины уровня будут зелеными
                # удаляем вершины уровня из массива
                n = mass.pop(mass.index(i))

            n = mass.pop(mass.index(mass[0][0]))  # удаление вершины
            for i in mass:
                # все оставшиеся вершины будут голубыми
                node_colors[i] = ('lightblue')
        else:
            node_colors = {mas[0][0]: 'green'}  # корень красив в зеленый
            n = mass.pop(mass.index(mass[0][0]))  # удаляем корень
            for i in mass:
                # все оставшиеся вершины будут голубыми
                node_colors[i] = ('lightblue')
        # Получаем список цветов для ребер
        edge_colors = [G[u][v]['color'] for u, v in G.edges()]

        # Позиции узлов для отображения

        nx.draw_planar(G, with_labels=True, node_color=[
                       node_colors[n] for n in G.nodes()], edge_color=edge_colors)
        plt.savefig('layer.jpg')  # сохраняем изображение n-арного дерева
        plt.show()  # рисуем граф

        return (otvet)

    '''конечная функция'''

    def layer_frame(self, mas, n):
        '''
        :param mas: масиив строк типа:['1: a b c', '2: f g h']
        :param n: номер уровня
        :return: изображение уровня и вывод его в виде строки
        '''

        return self.layer(ctenie(mas), n)

    def postroenie_Excel(self, mas):  # Функция для построения таблицы Exel
        '''
        :param mas: список веток дерева, задаваемых пользователем, предварительно обработанных функцией ctenie
        :return: xlsx файл, содержащий таблицу смежности.
        '''

        # В вспомогательную переменную записывается таблица смежности всего дерева.
        massiv = self.tabl_smegmm(mas)
        wb = openpyxl.Workbook()  # Создание рабочей книги с помощью библиотеки openpyxl

        sheet = wb.active  # активируем таблицу для работы с ней.
        '''
        заполняем таблицу смежности
        '''
        for i in range(len(massiv)):  # Цикл по количеству строк в таблице смежности
            # заполняем посимвольно таблицу
            # Цикл по количеству элементов в строке
            for j in range(len(massiv[i])):
                # Указывается ячейка в которую можно вносить изменение.
                c = sheet.cell(row=i + 1, column=j + 1)
                # В ячейку заноситься элемент из таблицы смежноости
                c.value = massiv[i][j]

        wb.save("sampling.xlsx")  # сохраняем таблицу Excel

    def postroenie_grafa_frame(self, mass):
        '''
        :param mass: масиив строк типа:['1: a b c', '2: f g h']
        :return: n-арное дерево построенное по шаблону planar библиотеки NetworkX
        '''
        mas = ctenie(mass)  # убираем первые 3 символа во входных данных
        self.postroenie_grafa(mas)

        self.postroenie_Excel(mas)

    '''конечная функция которая выводит конусы и строит таблицу смежности если конус >1'''

    def conus_frame(self, mass, isxod):
        '''
        :param mass: масиив строк типа:['1: a b c', '2: f g h']
        :param isxod: название вершины относительно которой строить сам конус
        :return: построение конуса и вывод его веток
        '''
        mas = ctenie(mass)  # убираем первые 3 символа во входных данных
        self.postroenie_Excel(self.conus(mas, isxod))
        n = self.grupp_cveta_konus(mas, isxod)
        return self.p_sme(self.conus(mas, isxod))


def ctenie(mas):  # функция для чтения входных данных
    '''
    :param mas: список веток дерева задаваемый пользователем
    Пример:['1: a b c', '2: f g h']
    :return: Список веток, без их номера и запятых, если они имеются.
    Пример: ['a b c', 'f g h']
    '''
    '''
    Одним из обязательным условий правильной работы функции является то,
    что бы между номером и первой вершиной ветки стоял 1 пробел, а так же, что бы номер ветки не содержал в себе пробелов.
    '''

    # Вспомогательный список, в котором будут храниться обработанные ветки дерева.
    konecnkl_massiv = []
    for i in mas:  # Цикл по ветка дерева, лежащим в переменой mas.
        stroka = i[i.index(' ') + 1:]  # Удаление номера ветки.
        # Вспомогательная строка в которой будет храниться ветка дерева, с которой в данный момент работает цикл.
        konechnai_stroka = ''
        for i in stroka:  # цикл по ветке дерева у которой удалили номер.
            if i != ',':  # Проверка символа, если он является ",", то он не добавляется в строку konechnai_stroka
                konechnai_stroka += i
        # добавление отформатирован ветки дерева в вспомогательный список.
        konecnkl_massiv.append(konechnai_stroka)

    '''
    может обрабатывать как последовательности строк содержащие запятые между вершинами
    например:
    ['1: a, b, c, d', '2: a, b, c, e', '3: a, b, c, f']
    так и просто массив входных данных:
    ['1: a b c d', '2: a b c e', '3: a b c f']
    '''

    return (konecnkl_massiv)  # Вывод вспомогательного списка
