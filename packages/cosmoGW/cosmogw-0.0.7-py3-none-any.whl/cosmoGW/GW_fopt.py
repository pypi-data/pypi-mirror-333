"""
GW_fopt.py is a Python routine that contains the functions to make
calculations related to the analytical templates that describe the
different contributions to the cosmological GW background from first-order
phase transitions (FOPT).
"""

import numpy as np
import matplotlib.pyplot as plt
import GW_analytical as an
import plot_sets
import os

dir0 = os.getcwd()

def kappa(alpha):
    
    """"
    Function that computes the efficiency in converting vacuum to
    kinetic energy density.
    
    Based on J. R. Espinosa, T. Konstandin, J. M. No and G. Servant,
    ``Energy Budget of Cosmological First-order Phase Transitions,''
    JCAP 06, 028 (2010), arXiv:1004.4187 (see eq. 42).
    """
    
    kap = alpha/(0.73 + 0.083*np.sqrt(alpha) + alpha)
    
    return kap

def Oms_alpha(alpha, w=1/3, eps=1):
    
    """"
    Function that computes the amount of vacuum energy that goes into turbulent
    energy density (kinetic + magnetic) as a function of the phase transition strength
    alpha assuming equipartition.
    
    Default prefactor is for radiation-dominated era: 1/(1 + w) ~ 4/3
    """
    
    kap = kappa(alpha)
    K = kap*alpha/(1 + alpha)
    
    return K*eps

def beta_Rs(beta, vw=1, w=1/3):
    
    """
    Function that computes the characteristic size of bubbles from the
    parameter beta.
    It can also be used to compute the value of beta from the mean
    characteristic size of the bubbles.
    
    Default assumes radiation-dominated era.
    """
    
    cs = np.sqrt(w)
    Rs = (8*np.pi)**(1/3)*max(vw, cs)/beta
    
    return Rs

def SSM_M_function(s, rb=1):
    
    """
    Function that computes the spectral shape derived for GWs
    generated by sound waves according to the Sound Shell Model (SSM),
    based in M. Hindmarsh & M. Hijazi, "Gravitational waves from first
    order cosmological phase transitions in the Sound Shell Model,"
    https://arxiv.org/pdf/1909.10040.pdf.
    
    Defined in their eq.~(5.7).
    
    rb refers to the ratio between peak frequencies, determined by
    the shell thickness.
    
    s is the normalized wave number by the shell thickness.
    """
    
    s = s*rb
    m = (9*rb**4 + 1)/(rb**4 + 1)
    M1 = ((rb**4 + 1)/(rb**4 + s**4))**2
    M2 = (5/(5 - m + m*s**2))**(5/2)
    
    return M1*M2*s**9

def Sf_soundwaves_Higgsless(f, rb=1, a1=2, a2=4, n1=3, n2=1):
    
    """
    Function that computes the spectral shape derived for GWs
    generated by sound waves according to the Higgsless simulations
    results, based in R. Jinno, T. Konstandin, H. Rubira, I. Stomberg,
    "Higgsless simulations of cosmological phase transitions and gravitational
    waves," https://arxiv.org/abs/2209.04369
    
    rb refers to the ratio between peak frequencies, determined by
    the shell thickness.
    
    s is the normalized wave number by the mean size of nucleated
    bubbles.
    """
    
    f2 = f*rb
    S = f**n1*(1 + f**a1)**((-n1+n2)/a1)*(1 + f2**a2)**((-n2+n3)/a2)
    
    return S

def mu_vs_rb():
    
    """
    Function that computes numerically the term \mu (r_b) of the Sound
    Shell Model in M. Hindmarsh & M. Hijazi, "Gravitational waves from first
    order cosmological phase transitions in the Sound Shell Model,"
    https://arxiv.org/pdf/1909.10040.pdf.
    
    Defined in their eq.~(5.9).
    They give a fit that seems to have a 1/2 factor typo.
    """
    
    rbs = np.linspace(0, 1, 1000)
    ss = np.logspace(-5, 4, 10000)

    Ms = np.zeros((len(rbs), len(ss)))
    for i in range(0, len(rbs)):
        Ms[i, :] = SSM_M_function(ss, rb=rbs[i])
    mu_b = np.trapz(Ms, np.log(ss), axis=1)
    mu_fit = .5*(4.78 - 6.27*rbs + 3.34*rbs**2)
    
    return rbs, mu_b, mu_fit

def mu_vs_rb_higgsless(a1=2, a2=4, n1=3, n2=1):
    
    """
    Function that computes numerically the term \mu (r_b) of the fit based in
    Higgsless simulations in R. Jinno, T. Konstandin, H. Rubira, I. Stomberg,
    "Higgsless simulations of cosmological phase transitions and gravitational
    waves," https://arxiv.org/abs/2209.04369
    """
    
    rbs = np.linspace(0, 1, 1000)
    ss = np.logspace(-5, 4, 10000)

    Ms = np.zeros((len(rbs), len(ss)))
    for i in range(0, len(rbs)):
        Ms[i, :] = Sf_soundwaves_Higgsless(ss, rb=rbs[i],
                                           a1=a1, a2=a2, n1=n1, n2=n2)
    mu_b = np.trapz(Ms, np.log(ss), axis=1)
    
    return rbs, mu_b

def Delta_w(vw=1, w=1/3):
    
    """
    Function that computes the thickness of the sound shells
    according to the Sound Shell Model in M. Hindmarsh & M.
    Hijazi, "Gravitational waves from first order cosmological
    phase transitions in the Sound Shell Model,"
    https://arxiv.org/pdf/1909.10040.pdf.
    
    Default assumes radiation-dominated era.
    """
    
    cs = np.sqrt(w)
    
    return abs(vw - cs)/vw

def AA_soundwaves(vw, w=1/3, Omgwtilde=1e-2):
    
    """
    Function that computes the amplitude of the sound wave template
    \tilde \Omega/mu(r_b) according to the Sound Shell Model in
    M. Hindmarsh & M. Hijazi, "Gravitational waves from first order
    cosmological phase transitions in the Sound Shell Model,"
    https://arxiv.org/pdf/1909.10040.pdf (eq.~5.8)
    """
    
    Dw = Delta_w(vw=vw, w=w)
    rbs, mu_b, _ = mu_vs_rb()
    mu = np.interp(Dw, rbs, mu_b)
    
    return Omgwtilde/mu

def AA_soundwaves_higgsless(vw, w=1/3, A=2, a1=2, a2=4, n1=3, n2=1):
    
    """
    Function that computes the amplitude of the sound wave template
    according to the fit based in Higgsless simulations in R. Jinno,
    T. Konstandin, H. Rubira, I. Stomberg, "Higgsless simulations of
    cosmological phase transitions and gravitational waves,"
    https://arxiv.org/abs/2209.04369
    """
    
    Dw = Delta_w(vw=vw, w=w)
    rbs, mu_b = mu_vs_rb_higgsless(a1=a1, a2=a2, n1=n1, n2=n2)
    mu = np.interp(Dw, rbs, mu_b)
    Omgwtilde = A/3*Dw*4/3/np.pi**2
    
    return Omgwtilde/mu

def AA_MHDturb(alpha=6/17, a=4, b=5/3, alpPi=2.15, fPi=2.2):
    
    """
    Function that computes the amplitude of the MHD turbulence
    template (1/8pi^2) A/C^2 based on the model developed in
    A. Roper Pol et al., "The gravitational wave signal from primordial
    magnetic fields in the Pulsar Timing Array frequency band,"
    https://arxiv.org/abs/2201.05630 (2022).
    
    The factor 1/2 has been added to take into account average over
    oscillations that were ignored in the original work.
    
    The factor 1/(4pi^2) has been added to define a normalized
    spectral shape function.
    """
    
    A = an.A_alpha(alp=alpha, a=a, b=b)
    C = an.C_alpha(alp=alpha, a=a, b=b)
    #xx = np.logspace(-1, 1, 10000)
    #pi1, fGW, pimax = pPi_fit(xx)
    pimax = (11/8)**(-11/3/alpPi)
    fGW = fPi*(3/8)**(1/alpPi)
    
    return C/A**2/(8*np.pi**2)*pimax*fGW

def TGW_func(f, N=2, Oms=.1, lf=1, w=1/3, equip=False, multi=False):
    
    """
    Function that computes the logarithmic function obtained
    as the envelope of the GW template in the constant-in-time
    assumption for the unequal time correlator of the turbulent
    stresses, developed in A. Roper Pol et al., "The gravitational
    wave signal from primordial magnetic fields in the Pulsar
    Timing Array frequency band," https://arxiv.org/abs/2201.05630
    (2022) (eq.~24).
    
    Assumes equipartition.
    """
    
    # equipartition assumption Omega_M = Omega_s/2
    Omm = Oms
    if equip: Omm = .5*Oms
    vA = Alfven_velocity(Omm, w=w)
    dtfin = N/vA
    
    if multi:
    
        f_ij, lf_ij, Oms_ij = np.meshgrid(f, lf, Oms, indexing='ij')
        TGW1 = np.log(1 + lf_ij/2/np.pi/f_ij)**2

        lf_ij, dtfin_ij = np.meshgrid(lf, dtfin, indexing='ij')
        TGW0 = np.log(1 + dtfin_ij*lf_ij/2/np.pi)**2

    #    lf_ij, dtfin_ij = np.meshgrid(lf, dtfin, indexing='ij')

        TGW = np.zeros((len(f), len(lf), len(Oms)))
        for i in range(0, len(dtfin)):
            TGW[f < 1/dtfin[i], :, i] = TGW0[:, i]
            TGW[f >= 1/dtfin[i], :, i] = TGW1[f >= 1/dtfin[i], :, i]
    else:
        TGW = np.zeros(len(f))
        TGW[f < 1/dtfin] = np.log(1 + dtfin/2/np.pi*lf)**2*f[(f < 1/dtfin)]**0
        TGW[f >= 1/dtfin] = np.log(1 + 1/2/np.pi/f[np.where(f >= 1/dtfin)]*lf)**2
    
    return TGW

def pPi_fit(f, alpPi=2.15, fPi=2.2):
    
    """
    Function that computes the fit for the stress convoluted
    spectrum (good for a magnetic spectrum with
    alpha=6/17, a=4, b=5/3).
    """
    
    Pi = (1 + (f/fPi)**alpPi)**(-11/3/alpPi)
    ind = np.argmax(f*Pi)
    fGW = f[ind]
    pimax = Pi[ind]
    
    return Pi, fGW, pimax
    
def BB_MHDturb(lf=1, alpPi=2.15, fPi=2.2):
    
    #Pi, fGW, pimax = pPi_fit(f)
    pimax = (11/8)**(-11/3/alpPi)
    fGW = fPi*(3/8)**(1/alpPi)
    BB = 4*np.pi**2/pimax/fGW/lf**2
    
    return BB
    
def Sf_MHDturb(f, N=2, Oms=.1, lf=1, w=1/3, equip=False, ref='f', multi=False):
    
    if ref=='k': lf = 2*np.pi/lf
    
    Pi, fGW, pimax = pPi_fit(f)
    BB = BB_MHDturb(lf=lf)
    
    #if multi:
    #    f, Oms, lf = np.meshgrid(f, Oms, lf, indexing='ij')
    
    TGW = TGW_func(f, N=N, Oms=Oms, lf=lf, w=w, equip=equip, multi=multi)
    f3Pi = f**3*Pi
    
    if multi:
        f3Pi, BB, _ = np.meshgrid(f3Pi, BB, Oms, indexing='ij')
    
    #pi1 = pPi_fit(1)
    #print(BB)
    Sf = BB*f3Pi*TGW
    
    return Sf
    
def eddy_turnover(Om, k, s='mag'):
    
    """
    Function that computes the eddy turnover time.
    """
    
    if s == 'mag': v = Alfven_velocity(Om)
    if s == 'kin': v = Alfven_velocity(Om, w=0)
        
    te = 1/k/v
    
    return te
    
    
def Alfven_velocity(OmM, w=1/3):
    
    """
    Function that computes the Alfv√©n velocity.
    Default assumes radiation-dominated era.
    """
    
    vA = np.sqrt(2*OmM/(1 + w))
    
    return vA
    