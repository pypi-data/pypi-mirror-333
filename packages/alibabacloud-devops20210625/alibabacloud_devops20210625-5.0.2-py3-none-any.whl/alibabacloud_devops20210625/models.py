# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List, Dict, Any


class AddGroupMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        access_level: int = None,
        aliyun_pks: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.access_level = access_level
        # This parameter is required.
        self.aliyun_pks = aliyun_pks
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.aliyun_pks is not None:
            result['aliyunPks'] = self.aliyun_pks
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('aliyunPks') is not None:
            self.aliyun_pks = m.get('aliyunPks')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class AddGroupMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        source_id: int = None,
        state: str = None,
        username: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.source_id = source_id
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class AddGroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[AddGroupMemberResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = AddGroupMemberResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class AddGroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddGroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddGroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddPipelineRelationsRequest(TeaModel):
    def __init__(
        self,
        rel_object_ids: str = None,
        rel_object_type: str = None,
    ):
        # This parameter is required.
        self.rel_object_ids = rel_object_ids
        # This parameter is required.
        self.rel_object_type = rel_object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rel_object_ids is not None:
            result['relObjectIds'] = self.rel_object_ids
        if self.rel_object_type is not None:
            result['relObjectType'] = self.rel_object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('relObjectIds') is not None:
            self.rel_object_ids = m.get('relObjectIds')
        if m.get('relObjectType') is not None:
            self.rel_object_type = m.get('relObjectType')
        return self


class AddPipelineRelationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class AddPipelineRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddPipelineRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddPipelineRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddRepositoryMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        access_level: int = None,
        aliyun_pks: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.access_level = access_level
        # This parameter is required.
        self.aliyun_pks = aliyun_pks
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.aliyun_pks is not None:
            result['aliyunPks'] = self.aliyun_pks
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('aliyunPks') is not None:
            self.aliyun_pks = m.get('aliyunPks')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class AddRepositoryMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        state: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class AddRepositoryMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[AddRepositoryMemberResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = AddRepositoryMemberResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class AddRepositoryMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddRepositoryMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddRepositoryMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddWebhookRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        description: str = None,
        enable_ssl_verification: bool = None,
        merge_requests_events: bool = None,
        note_events: bool = None,
        push_events: bool = None,
        secret_token: str = None,
        tag_push_events: bool = None,
        url: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.description = description
        self.enable_ssl_verification = enable_ssl_verification
        self.merge_requests_events = merge_requests_events
        self.note_events = note_events
        self.push_events = push_events
        self.secret_token = secret_token
        self.tag_push_events = tag_push_events
        # This parameter is required.
        self.url = url
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.description is not None:
            result['description'] = self.description
        if self.enable_ssl_verification is not None:
            result['enableSslVerification'] = self.enable_ssl_verification
        if self.merge_requests_events is not None:
            result['mergeRequestsEvents'] = self.merge_requests_events
        if self.note_events is not None:
            result['noteEvents'] = self.note_events
        if self.push_events is not None:
            result['pushEvents'] = self.push_events
        if self.secret_token is not None:
            result['secretToken'] = self.secret_token
        if self.tag_push_events is not None:
            result['tagPushEvents'] = self.tag_push_events
        if self.url is not None:
            result['url'] = self.url
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enableSslVerification') is not None:
            self.enable_ssl_verification = m.get('enableSslVerification')
        if m.get('mergeRequestsEvents') is not None:
            self.merge_requests_events = m.get('mergeRequestsEvents')
        if m.get('noteEvents') is not None:
            self.note_events = m.get('noteEvents')
        if m.get('pushEvents') is not None:
            self.push_events = m.get('pushEvents')
        if m.get('secretToken') is not None:
            self.secret_token = m.get('secretToken')
        if m.get('tagPushEvents') is not None:
            self.tag_push_events = m.get('tagPushEvents')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class AddWebhookResponseBodyResult(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        description: str = None,
        enable_ssl_verification: bool = None,
        id: int = None,
        last_test_result: str = None,
        merge_requests_events: bool = None,
        note_events: bool = None,
        push_events: bool = None,
        repository_id: int = None,
        secret_token: str = None,
        tag_push_events: bool = None,
        url: str = None,
    ):
        self.created_at = created_at
        self.description = description
        self.enable_ssl_verification = enable_ssl_verification
        self.id = id
        self.last_test_result = last_test_result
        self.merge_requests_events = merge_requests_events
        self.note_events = note_events
        self.push_events = push_events
        self.repository_id = repository_id
        self.secret_token = secret_token
        self.tag_push_events = tag_push_events
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.enable_ssl_verification is not None:
            result['enableSslVerification'] = self.enable_ssl_verification
        if self.id is not None:
            result['id'] = self.id
        if self.last_test_result is not None:
            result['lastTestResult'] = self.last_test_result
        if self.merge_requests_events is not None:
            result['mergeRequestsEvents'] = self.merge_requests_events
        if self.note_events is not None:
            result['noteEvents'] = self.note_events
        if self.push_events is not None:
            result['pushEvents'] = self.push_events
        if self.repository_id is not None:
            result['repositoryId'] = self.repository_id
        if self.secret_token is not None:
            result['secretToken'] = self.secret_token
        if self.tag_push_events is not None:
            result['tagPushEvents'] = self.tag_push_events
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enableSslVerification') is not None:
            self.enable_ssl_verification = m.get('enableSslVerification')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastTestResult') is not None:
            self.last_test_result = m.get('lastTestResult')
        if m.get('mergeRequestsEvents') is not None:
            self.merge_requests_events = m.get('mergeRequestsEvents')
        if m.get('noteEvents') is not None:
            self.note_events = m.get('noteEvents')
        if m.get('pushEvents') is not None:
            self.push_events = m.get('pushEvents')
        if m.get('repositoryId') is not None:
            self.repository_id = m.get('repositoryId')
        if m.get('secretToken') is not None:
            self.secret_token = m.get('secretToken')
        if m.get('tagPushEvents') is not None:
            self.tag_push_events = m.get('tagPushEvents')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class AddWebhookResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: AddWebhookResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = AddWebhookResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class AddWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: AddWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelExecutionReleaseStageRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CancelExecutionReleaseStageResponseBody(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CancelExecutionReleaseStageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CancelExecutionReleaseStageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelExecutionReleaseStageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CloseMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CloseMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class CloseMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CloseMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CloseMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CloseMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CloseMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CloseMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAppMembersRequestPlayerList(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateAppMembersRequest(TeaModel):
    def __init__(
        self,
        player_list: List[CreateAppMembersRequestPlayerList] = None,
        role_names: List[str] = None,
        organization_id: str = None,
    ):
        self.player_list = player_list
        self.role_names = role_names
        self.organization_id = organization_id

    def validate(self):
        if self.player_list:
            for k in self.player_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['playerList'] = []
        if self.player_list is not None:
            for k in self.player_list:
                result['playerList'].append(k.to_map() if k else None)
        if self.role_names is not None:
            result['roleNames'] = self.role_names
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.player_list = []
        if m.get('playerList') is not None:
            for k in m.get('playerList'):
                temp_model = CreateAppMembersRequestPlayerList()
                self.player_list.append(temp_model.from_map(k))
        if m.get('roleNames') is not None:
            self.role_names = m.get('roleNames')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateAppMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: str = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            self.body = m.get('body')
        return self


class CreateBranchRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        branch_name: str = None,
        ref: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.branch_name = branch_name
        # This parameter is required.
        self.ref = ref
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.ref is not None:
            result['ref'] = self.ref
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('ref') is not None:
            self.ref = m.get('ref')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateBranchResponseBodyResultCommit(TeaModel):
    def __init__(
        self,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        committed_date: str = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        title: str = None,
    ):
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.committed_date = committed_date
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateBranchResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit: CreateBranchResponseBodyResultCommit = None,
        name: str = None,
        protected: bool = None,
    ):
        self.commit = commit
        self.name = name
        self.protected = protected

    def validate(self):
        if self.commit:
            self.commit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit is not None:
            result['commit'] = self.commit.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.protected is not None:
            result['protected'] = self.protected
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commit') is not None:
            temp_model = CreateBranchResponseBodyResultCommit()
            self.commit = temp_model.from_map(m['commit'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('protected') is not None:
            self.protected = m.get('protected')
        return self


class CreateBranchResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateBranchResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateBranchResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateBranchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateBranchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateBranchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateChangeRequestRequest(TeaModel):
    def __init__(
        self,
        app_code_repo_sn: str = None,
        auto_delete_branch_when_end: bool = None,
        branch_name: str = None,
        create_branch: bool = None,
        owner_account_id: str = None,
        owner_id: str = None,
        title: str = None,
        organization_id: str = None,
    ):
        # This parameter is required.
        self.app_code_repo_sn = app_code_repo_sn
        self.auto_delete_branch_when_end = auto_delete_branch_when_end
        # This parameter is required.
        self.branch_name = branch_name
        self.create_branch = create_branch
        self.owner_account_id = owner_account_id
        # This parameter is required.
        self.owner_id = owner_id
        # This parameter is required.
        self.title = title
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_code_repo_sn is not None:
            result['appCodeRepoSn'] = self.app_code_repo_sn
        if self.auto_delete_branch_when_end is not None:
            result['autoDeleteBranchWhenEnd'] = self.auto_delete_branch_when_end
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.create_branch is not None:
            result['createBranch'] = self.create_branch
        if self.owner_account_id is not None:
            result['ownerAccountId'] = self.owner_account_id
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.title is not None:
            result['title'] = self.title
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appCodeRepoSn') is not None:
            self.app_code_repo_sn = m.get('appCodeRepoSn')
        if m.get('autoDeleteBranchWhenEnd') is not None:
            self.auto_delete_branch_when_end = m.get('autoDeleteBranchWhenEnd')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('createBranch') is not None:
            self.create_branch = m.get('createBranch')
        if m.get('ownerAccountId') is not None:
            self.owner_account_id = m.get('ownerAccountId')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateChangeRequestResponseBody(TeaModel):
    def __init__(
        self,
        app_code_repo_sn: str = None,
        app_name: str = None,
        auto_delete_branch_when_end: bool = None,
        branch: str = None,
        creator_account_id: str = None,
        creator_id: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        name: str = None,
        origin_branch: str = None,
        origin_branch_revision_sha: str = None,
        owner_account_id: str = None,
        owner_id: str = None,
        sn: str = None,
        state: str = None,
        type: str = None,
    ):
        self.app_code_repo_sn = app_code_repo_sn
        self.app_name = app_name
        self.auto_delete_branch_when_end = auto_delete_branch_when_end
        self.branch = branch
        self.creator_account_id = creator_account_id
        self.creator_id = creator_id
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.name = name
        self.origin_branch = origin_branch
        self.origin_branch_revision_sha = origin_branch_revision_sha
        self.owner_account_id = owner_account_id
        self.owner_id = owner_id
        self.sn = sn
        self.state = state
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_code_repo_sn is not None:
            result['appCodeRepoSn'] = self.app_code_repo_sn
        if self.app_name is not None:
            result['appName'] = self.app_name
        if self.auto_delete_branch_when_end is not None:
            result['autoDeleteBranchWhenEnd'] = self.auto_delete_branch_when_end
        if self.branch is not None:
            result['branch'] = self.branch
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.name is not None:
            result['name'] = self.name
        if self.origin_branch is not None:
            result['originBranch'] = self.origin_branch
        if self.origin_branch_revision_sha is not None:
            result['originBranchRevisionSha'] = self.origin_branch_revision_sha
        if self.owner_account_id is not None:
            result['ownerAccountId'] = self.owner_account_id
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.sn is not None:
            result['sn'] = self.sn
        if self.state is not None:
            result['state'] = self.state
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appCodeRepoSn') is not None:
            self.app_code_repo_sn = m.get('appCodeRepoSn')
        if m.get('appName') is not None:
            self.app_name = m.get('appName')
        if m.get('autoDeleteBranchWhenEnd') is not None:
            self.auto_delete_branch_when_end = m.get('autoDeleteBranchWhenEnd')
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('originBranch') is not None:
            self.origin_branch = m.get('originBranch')
        if m.get('originBranchRevisionSha') is not None:
            self.origin_branch_revision_sha = m.get('originBranchRevisionSha')
        if m.get('ownerAccountId') is not None:
            self.owner_account_id = m.get('ownerAccountId')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('sn') is not None:
            self.sn = m.get('sn')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateChangeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateChangeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateChangeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCheckRunRequestAnnotations(TeaModel):
    def __init__(
        self,
        annotation_level: str = None,
        end_column: int = None,
        end_line: int = None,
        message: str = None,
        path: str = None,
        raw_details: str = None,
        start_column: int = None,
        start_line: int = None,
        title: str = None,
    ):
        # This parameter is required.
        self.annotation_level = annotation_level
        self.end_column = end_column
        # This parameter is required.
        self.end_line = end_line
        # This parameter is required.
        self.message = message
        # This parameter is required.
        self.path = path
        self.raw_details = raw_details
        self.start_column = start_column
        # This parameter is required.
        self.start_line = start_line
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation_level is not None:
            result['annotationLevel'] = self.annotation_level
        if self.end_column is not None:
            result['endColumn'] = self.end_column
        if self.end_line is not None:
            result['endLine'] = self.end_line
        if self.message is not None:
            result['message'] = self.message
        if self.path is not None:
            result['path'] = self.path
        if self.raw_details is not None:
            result['rawDetails'] = self.raw_details
        if self.start_column is not None:
            result['startColumn'] = self.start_column
        if self.start_line is not None:
            result['startLine'] = self.start_line
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotationLevel') is not None:
            self.annotation_level = m.get('annotationLevel')
        if m.get('endColumn') is not None:
            self.end_column = m.get('endColumn')
        if m.get('endLine') is not None:
            self.end_line = m.get('endLine')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('rawDetails') is not None:
            self.raw_details = m.get('rawDetails')
        if m.get('startColumn') is not None:
            self.start_column = m.get('startColumn')
        if m.get('startLine') is not None:
            self.start_line = m.get('startLine')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateCheckRunRequestOutputImages(TeaModel):
    def __init__(
        self,
        alt: str = None,
        caption: str = None,
        image_url: str = None,
    ):
        # This parameter is required.
        self.alt = alt
        self.caption = caption
        # This parameter is required.
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alt is not None:
            result['alt'] = self.alt
        if self.caption is not None:
            result['caption'] = self.caption
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alt') is not None:
            self.alt = m.get('alt')
        if m.get('caption') is not None:
            self.caption = m.get('caption')
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        return self


class CreateCheckRunRequestOutput(TeaModel):
    def __init__(
        self,
        images: List[CreateCheckRunRequestOutputImages] = None,
        summary: str = None,
        text: str = None,
        title: str = None,
    ):
        self.images = images
        # This parameter is required.
        self.summary = summary
        self.text = text
        # This parameter is required.
        self.title = title

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['images'] = []
        if self.images is not None:
            for k in self.images:
                result['images'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary
        if self.text is not None:
            result['text'] = self.text
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('images') is not None:
            for k in m.get('images'):
                temp_model = CreateCheckRunRequestOutputImages()
                self.images.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateCheckRunRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        annotations: List[CreateCheckRunRequestAnnotations] = None,
        completed_at: str = None,
        conclusion: str = None,
        details_url: str = None,
        external_id: str = None,
        head_sha: str = None,
        name: str = None,
        output: CreateCheckRunRequestOutput = None,
        started_at: str = None,
        status: str = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        self.annotations = annotations
        self.completed_at = completed_at
        self.conclusion = conclusion
        self.details_url = details_url
        self.external_id = external_id
        # This parameter is required.
        self.head_sha = head_sha
        # This parameter is required.
        self.name = name
        self.output = output
        self.started_at = started_at
        self.status = status
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.conclusion is not None:
            result['conclusion'] = self.conclusion
        if self.details_url is not None:
            result['detailsUrl'] = self.details_url
        if self.external_id is not None:
            result['externalId'] = self.external_id
        if self.head_sha is not None:
            result['headSha'] = self.head_sha
        if self.name is not None:
            result['name'] = self.name
        if self.output is not None:
            result['output'] = self.output.to_map()
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = CreateCheckRunRequestAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('conclusion') is not None:
            self.conclusion = m.get('conclusion')
        if m.get('detailsUrl') is not None:
            self.details_url = m.get('detailsUrl')
        if m.get('externalId') is not None:
            self.external_id = m.get('externalId')
        if m.get('headSha') is not None:
            self.head_sha = m.get('headSha')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('output') is not None:
            temp_model = CreateCheckRunRequestOutput()
            self.output = temp_model.from_map(m['output'])
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class CreateCheckRunResponseBodyResultAnnotations(TeaModel):
    def __init__(
        self,
        annotation_level: str = None,
        end_column: int = None,
        end_line: int = None,
        id: int = None,
        message: str = None,
        path: str = None,
        raw_details: str = None,
        start_column: int = None,
        start_line: int = None,
        title: str = None,
    ):
        self.annotation_level = annotation_level
        self.end_column = end_column
        self.end_line = end_line
        self.id = id
        self.message = message
        self.path = path
        self.raw_details = raw_details
        self.start_column = start_column
        self.start_line = start_line
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation_level is not None:
            result['annotationLevel'] = self.annotation_level
        if self.end_column is not None:
            result['endColumn'] = self.end_column
        if self.end_line is not None:
            result['endLine'] = self.end_line
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.path is not None:
            result['path'] = self.path
        if self.raw_details is not None:
            result['rawDetails'] = self.raw_details
        if self.start_column is not None:
            result['startColumn'] = self.start_column
        if self.start_line is not None:
            result['startLine'] = self.start_line
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotationLevel') is not None:
            self.annotation_level = m.get('annotationLevel')
        if m.get('endColumn') is not None:
            self.end_column = m.get('endColumn')
        if m.get('endLine') is not None:
            self.end_line = m.get('endLine')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('rawDetails') is not None:
            self.raw_details = m.get('rawDetails')
        if m.get('startColumn') is not None:
            self.start_column = m.get('startColumn')
        if m.get('startLine') is not None:
            self.start_line = m.get('startLine')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateCheckRunResponseBodyResultCheckSuite(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class CreateCheckRunResponseBodyResultOutputImages(TeaModel):
    def __init__(
        self,
        alt: str = None,
        caption: str = None,
        image_url: str = None,
    ):
        self.alt = alt
        self.caption = caption
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alt is not None:
            result['alt'] = self.alt
        if self.caption is not None:
            result['caption'] = self.caption
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alt') is not None:
            self.alt = m.get('alt')
        if m.get('caption') is not None:
            self.caption = m.get('caption')
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        return self


class CreateCheckRunResponseBodyResultOutput(TeaModel):
    def __init__(
        self,
        images: List[CreateCheckRunResponseBodyResultOutputImages] = None,
        summary: str = None,
        text: str = None,
        title: str = None,
    ):
        self.images = images
        self.summary = summary
        self.text = text
        self.title = title

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['images'] = []
        if self.images is not None:
            for k in self.images:
                result['images'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary
        if self.text is not None:
            result['text'] = self.text
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('images') is not None:
            for k in m.get('images'):
                temp_model = CreateCheckRunResponseBodyResultOutputImages()
                self.images.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateCheckRunResponseBodyResultWriter(TeaModel):
    def __init__(
        self,
        id: str = None,
        logo_url: str = None,
        name: str = None,
        slug: str = None,
        type: str = None,
    ):
        self.id = id
        self.logo_url = logo_url
        self.name = name
        self.slug = slug
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.logo_url is not None:
            result['logoUrl'] = self.logo_url
        if self.name is not None:
            result['name'] = self.name
        if self.slug is not None:
            result['slug'] = self.slug
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('logoUrl') is not None:
            self.logo_url = m.get('logoUrl')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('slug') is not None:
            self.slug = m.get('slug')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateCheckRunResponseBodyResult(TeaModel):
    def __init__(
        self,
        annotations: List[CreateCheckRunResponseBodyResultAnnotations] = None,
        check_suite: CreateCheckRunResponseBodyResultCheckSuite = None,
        completed_at: str = None,
        conclusion: str = None,
        created_at: str = None,
        details_url: str = None,
        external_id: str = None,
        head_sha: str = None,
        id: int = None,
        name: str = None,
        output: CreateCheckRunResponseBodyResultOutput = None,
        started_at: str = None,
        status: str = None,
        updated_at: str = None,
        writer: CreateCheckRunResponseBodyResultWriter = None,
    ):
        self.annotations = annotations
        self.check_suite = check_suite
        self.completed_at = completed_at
        self.conclusion = conclusion
        self.created_at = created_at
        self.details_url = details_url
        self.external_id = external_id
        self.head_sha = head_sha
        self.id = id
        self.name = name
        self.output = output
        self.started_at = started_at
        self.status = status
        self.updated_at = updated_at
        self.writer = writer

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.check_suite:
            self.check_suite.validate()
        if self.output:
            self.output.validate()
        if self.writer:
            self.writer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.check_suite is not None:
            result['checkSuite'] = self.check_suite.to_map()
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.conclusion is not None:
            result['conclusion'] = self.conclusion
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.details_url is not None:
            result['detailsUrl'] = self.details_url
        if self.external_id is not None:
            result['externalId'] = self.external_id
        if self.head_sha is not None:
            result['headSha'] = self.head_sha
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.output is not None:
            result['output'] = self.output.to_map()
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.writer is not None:
            result['writer'] = self.writer.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = CreateCheckRunResponseBodyResultAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('checkSuite') is not None:
            temp_model = CreateCheckRunResponseBodyResultCheckSuite()
            self.check_suite = temp_model.from_map(m['checkSuite'])
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('conclusion') is not None:
            self.conclusion = m.get('conclusion')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('detailsUrl') is not None:
            self.details_url = m.get('detailsUrl')
        if m.get('externalId') is not None:
            self.external_id = m.get('externalId')
        if m.get('headSha') is not None:
            self.head_sha = m.get('headSha')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('output') is not None:
            temp_model = CreateCheckRunResponseBodyResultOutput()
            self.output = temp_model.from_map(m['output'])
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('writer') is not None:
            temp_model = CreateCheckRunResponseBodyResultWriter()
            self.writer = temp_model.from_map(m['writer'])
        return self


class CreateCheckRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateCheckRunResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateCheckRunResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateCheckRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCheckRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCheckRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCommentRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        comment_type: str = None,
        content: str = None,
        draft: bool = None,
        file_path: str = None,
        from_pach_set_biz_id: str = None,
        line_number: int = None,
        parent_comment_biz_id: str = None,
        patch_set_biz_id: str = None,
        resolved: bool = None,
        to_patch_set_biz_id: str = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.comment_type = comment_type
        # This parameter is required.
        self.content = content
        self.draft = draft
        self.file_path = file_path
        self.from_pach_set_biz_id = from_pach_set_biz_id
        self.line_number = line_number
        self.parent_comment_biz_id = parent_comment_biz_id
        self.patch_set_biz_id = patch_set_biz_id
        self.resolved = resolved
        self.to_patch_set_biz_id = to_patch_set_biz_id
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.comment_type is not None:
            result['commentType'] = self.comment_type
        if self.content is not None:
            result['content'] = self.content
        if self.draft is not None:
            result['draft'] = self.draft
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.from_pach_set_biz_id is not None:
            result['fromPachSetBizId'] = self.from_pach_set_biz_id
        if self.line_number is not None:
            result['lineNumber'] = self.line_number
        if self.parent_comment_biz_id is not None:
            result['parentCommentBizId'] = self.parent_comment_biz_id
        if self.patch_set_biz_id is not None:
            result['patchSetBizId'] = self.patch_set_biz_id
        if self.resolved is not None:
            result['resolved'] = self.resolved
        if self.to_patch_set_biz_id is not None:
            result['toPatchSetBizId'] = self.to_patch_set_biz_id
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('commentType') is not None:
            self.comment_type = m.get('commentType')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('draft') is not None:
            self.draft = m.get('draft')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('fromPachSetBizId') is not None:
            self.from_pach_set_biz_id = m.get('fromPachSetBizId')
        if m.get('lineNumber') is not None:
            self.line_number = m.get('lineNumber')
        if m.get('parentCommentBizId') is not None:
            self.parent_comment_biz_id = m.get('parentCommentBizId')
        if m.get('patchSetBizId') is not None:
            self.patch_set_biz_id = m.get('patchSetBizId')
        if m.get('resolved') is not None:
            self.resolved = m.get('resolved')
        if m.get('toPatchSetBizId') is not None:
            self.to_patch_set_biz_id = m.get('toPatchSetBizId')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class CreateCommentResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class CreateCommentResponseBodyResultRelatedPatchSet(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        created_at: str = None,
        patch_set_biz_id: str = None,
        patch_set_name: str = None,
        patch_set_no: str = None,
        related_merge_item_type: str = None,
        short_id: str = None,
    ):
        self.commit_id = commit_id
        self.created_at = created_at
        self.patch_set_biz_id = patch_set_biz_id
        self.patch_set_name = patch_set_name
        self.patch_set_no = patch_set_no
        self.related_merge_item_type = related_merge_item_type
        self.short_id = short_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.patch_set_biz_id is not None:
            result['patchSetBizId'] = self.patch_set_biz_id
        if self.patch_set_name is not None:
            result['patchSetName'] = self.patch_set_name
        if self.patch_set_no is not None:
            result['patchSetNo'] = self.patch_set_no
        if self.related_merge_item_type is not None:
            result['relatedMergeItemType'] = self.related_merge_item_type
        if self.short_id is not None:
            result['shortId'] = self.short_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('patchSetBizId') is not None:
            self.patch_set_biz_id = m.get('patchSetBizId')
        if m.get('patchSetName') is not None:
            self.patch_set_name = m.get('patchSetName')
        if m.get('patchSetNo') is not None:
            self.patch_set_no = m.get('patchSetNo')
        if m.get('relatedMergeItemType') is not None:
            self.related_merge_item_type = m.get('relatedMergeItemType')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        return self


class CreateCommentResponseBodyResult(TeaModel):
    def __init__(
        self,
        author: CreateCommentResponseBodyResultAuthor = None,
        comment_biz_id: str = None,
        comment_time: str = None,
        comment_type: str = None,
        content: str = None,
        deleted: bool = None,
        file_path: str = None,
        last_edit_time: str = None,
        line_number: str = None,
        parent_comment_biz_id: str = None,
        related_patch_set: CreateCommentResponseBodyResultRelatedPatchSet = None,
        resolved: bool = None,
        root_comment_biz_id: str = None,
        state: str = None,
    ):
        self.author = author
        self.comment_biz_id = comment_biz_id
        self.comment_time = comment_time
        self.comment_type = comment_type
        self.content = content
        self.deleted = deleted
        self.file_path = file_path
        self.last_edit_time = last_edit_time
        self.line_number = line_number
        self.parent_comment_biz_id = parent_comment_biz_id
        self.related_patch_set = related_patch_set
        self.resolved = resolved
        self.root_comment_biz_id = root_comment_biz_id
        self.state = state

    def validate(self):
        if self.author:
            self.author.validate()
        if self.related_patch_set:
            self.related_patch_set.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.comment_biz_id is not None:
            result['commentBizId'] = self.comment_biz_id
        if self.comment_time is not None:
            result['commentTime'] = self.comment_time
        if self.comment_type is not None:
            result['commentType'] = self.comment_type
        if self.content is not None:
            result['content'] = self.content
        if self.deleted is not None:
            result['deleted'] = self.deleted
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.last_edit_time is not None:
            result['lastEditTime'] = self.last_edit_time
        if self.line_number is not None:
            result['lineNumber'] = self.line_number
        if self.parent_comment_biz_id is not None:
            result['parentCommentBizId'] = self.parent_comment_biz_id
        if self.related_patch_set is not None:
            result['relatedPatchSet'] = self.related_patch_set.to_map()
        if self.resolved is not None:
            result['resolved'] = self.resolved
        if self.root_comment_biz_id is not None:
            result['rootCommentBizId'] = self.root_comment_biz_id
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = CreateCommentResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('commentBizId') is not None:
            self.comment_biz_id = m.get('commentBizId')
        if m.get('commentTime') is not None:
            self.comment_time = m.get('commentTime')
        if m.get('commentType') is not None:
            self.comment_type = m.get('commentType')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('deleted') is not None:
            self.deleted = m.get('deleted')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('lastEditTime') is not None:
            self.last_edit_time = m.get('lastEditTime')
        if m.get('lineNumber') is not None:
            self.line_number = m.get('lineNumber')
        if m.get('parentCommentBizId') is not None:
            self.parent_comment_biz_id = m.get('parentCommentBizId')
        if m.get('relatedPatchSet') is not None:
            temp_model = CreateCommentResponseBodyResultRelatedPatchSet()
            self.related_patch_set = temp_model.from_map(m['relatedPatchSet'])
        if m.get('resolved') is not None:
            self.resolved = m.get('resolved')
        if m.get('rootCommentBizId') is not None:
            self.root_comment_biz_id = m.get('rootCommentBizId')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class CreateCommentResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateCommentResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateCommentResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateCommentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCommentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCommentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCommitStatusRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        context: str = None,
        description: str = None,
        state: str = None,
        target_url: str = None,
        organization_id: str = None,
        repository_identity: str = None,
        sha: str = None,
    ):
        self.access_token = access_token
        self.context = context
        self.description = description
        # This parameter is required.
        self.state = state
        self.target_url = target_url
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity
        # This parameter is required.
        self.sha = sha

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.context is not None:
            result['context'] = self.context
        if self.description is not None:
            result['description'] = self.description
        if self.state is not None:
            result['state'] = self.state
        if self.target_url is not None:
            result['targetUrl'] = self.target_url
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        if self.sha is not None:
            result['sha'] = self.sha
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('targetUrl') is not None:
            self.target_url = m.get('targetUrl')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        if m.get('sha') is not None:
            self.sha = m.get('sha')
        return self


class CreateCommitStatusResponseBodyResultCreator(TeaModel):
    def __init__(
        self,
        aliyun_pk: int = None,
        avatar_url: str = None,
        login: str = None,
        type: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.login = login
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.login is not None:
            result['login'] = self.login
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('login') is not None:
            self.login = m.get('login')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateCommitStatusResponseBodyResult(TeaModel):
    def __init__(
        self,
        context: str = None,
        creator: CreateCommitStatusResponseBodyResultCreator = None,
        description: str = None,
        id: int = None,
        sha: str = None,
        state: str = None,
        target_url: str = None,
    ):
        self.context = context
        self.creator = creator
        self.description = description
        self.id = id
        self.sha = sha
        self.state = state
        self.target_url = target_url

    def validate(self):
        if self.creator:
            self.creator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['context'] = self.context
        if self.creator is not None:
            result['creator'] = self.creator.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.sha is not None:
            result['sha'] = self.sha
        if self.state is not None:
            result['state'] = self.state
        if self.target_url is not None:
            result['targetUrl'] = self.target_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('creator') is not None:
            temp_model = CreateCommitStatusResponseBodyResultCreator()
            self.creator = temp_model.from_map(m['creator'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('sha') is not None:
            self.sha = m.get('sha')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('targetUrl') is not None:
            self.target_url = m.get('targetUrl')
        return self


class CreateCommitStatusResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateCommitStatusResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateCommitStatusResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateCommitStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCommitStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCommitStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCommitWithMultipleFilesRequestActions(TeaModel):
    def __init__(
        self,
        action: str = None,
        content: str = None,
        file_path: str = None,
        previous_path: str = None,
    ):
        self.action = action
        self.content = content
        self.file_path = file_path
        self.previous_path = previous_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['action'] = self.action
        if self.content is not None:
            result['content'] = self.content
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.previous_path is not None:
            result['previousPath'] = self.previous_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action') is not None:
            self.action = m.get('action')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('previousPath') is not None:
            self.previous_path = m.get('previousPath')
        return self


class CreateCommitWithMultipleFilesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        actions: List[CreateCommitWithMultipleFilesRequestActions] = None,
        branch: str = None,
        commit_message: str = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.actions = actions
        # This parameter is required.
        self.branch = branch
        self.commit_message = commit_message
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.branch is not None:
            result['branch'] = self.branch
        if self.commit_message is not None:
            result['commitMessage'] = self.commit_message
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = CreateCommitWithMultipleFilesRequestActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('commitMessage') is not None:
            self.commit_message = m.get('commitMessage')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class CreateCommitWithMultipleFilesResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
        website_url: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username
        self.website_url = website_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.website_url is not None:
            result['websiteUrl'] = self.website_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('websiteUrl') is not None:
            self.website_url = m.get('websiteUrl')
        return self


class CreateCommitWithMultipleFilesResponseBodyResultCommitter(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
        website_url: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username
        self.website_url = website_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.website_url is not None:
            result['websiteUrl'] = self.website_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('websiteUrl') is not None:
            self.website_url = m.get('websiteUrl')
        return self


class CreateCommitWithMultipleFilesResponseBodyResult(TeaModel):
    def __init__(
        self,
        author: CreateCommitWithMultipleFilesResponseBodyResultAuthor = None,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        committed_date: str = None,
        committer: CreateCommitWithMultipleFilesResponseBodyResultCommitter = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        title: str = None,
    ):
        self.author = author
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.committed_date = committed_date
        self.committer = committer
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.title = title

    def validate(self):
        if self.author:
            self.author.validate()
        if self.committer:
            self.committer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer is not None:
            result['committer'] = self.committer.to_map()
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = CreateCommitWithMultipleFilesResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committer') is not None:
            temp_model = CreateCommitWithMultipleFilesResponseBodyResultCommitter()
            self.committer = temp_model.from_map(m['committer'])
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateCommitWithMultipleFilesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        result: CreateCommitWithMultipleFilesResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateCommitWithMultipleFilesResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateCommitWithMultipleFilesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateCommitWithMultipleFilesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCommitWithMultipleFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeployKeyRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        key: str = None,
        title: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.key = key
        # This parameter is required.
        self.title = title
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.key is not None:
            result['key'] = self.key
        if self.title is not None:
            result['title'] = self.title
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateDeployKeyResponseBodyResult(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        fingerprint: str = None,
        id: int = None,
        key: str = None,
        title: str = None,
    ):
        self.created_at = created_at
        self.fingerprint = fingerprint
        self.id = id
        self.key = key
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.fingerprint is not None:
            result['fingerprint'] = self.fingerprint
        if self.id is not None:
            result['id'] = self.id
        if self.key is not None:
            result['key'] = self.key
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('fingerprint') is not None:
            self.fingerprint = m.get('fingerprint')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateDeployKeyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateDeployKeyResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateDeployKeyResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateDeployKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateDeployKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeployKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFileRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        branch_name: str = None,
        commit_message: str = None,
        content: str = None,
        encoding: str = None,
        file_path: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.branch_name = branch_name
        # This parameter is required.
        self.commit_message = commit_message
        # This parameter is required.
        self.content = content
        self.encoding = encoding
        # This parameter is required.
        self.file_path = file_path
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.commit_message is not None:
            result['commitMessage'] = self.commit_message
        if self.content is not None:
            result['content'] = self.content
        if self.encoding is not None:
            result['encoding'] = self.encoding
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('commitMessage') is not None:
            self.commit_message = m.get('commitMessage')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('encoding') is not None:
            self.encoding = m.get('encoding')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateFileResponseBodyResult(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
        file_path: str = None,
    ):
        self.branch_name = branch_name
        self.file_path = file_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.file_path is not None:
            result['filePath'] = self.file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        return self


class CreateFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateFileResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateFileResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFlowTagRequest(TeaModel):
    def __init__(
        self,
        color: str = None,
        flow_tag_group_id: int = None,
        name: str = None,
    ):
        # This parameter is required.
        self.color = color
        # This parameter is required.
        self.flow_tag_group_id = flow_tag_group_id
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.flow_tag_group_id is not None:
            result['flowTagGroupId'] = self.flow_tag_group_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('flowTagGroupId') is not None:
            self.flow_tag_group_id = m.get('flowTagGroupId')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateFlowTagResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.id = id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateFlowTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFlowTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFlowTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateFlowTagGroupRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateFlowTagGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.id = id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateFlowTagGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateFlowTagGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateFlowTagGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHostGroupRequest(TeaModel):
    def __init__(
        self,
        aliyun_region: str = None,
        ecs_label_key: str = None,
        ecs_label_value: str = None,
        ecs_type: str = None,
        env_id: str = None,
        machine_infos: str = None,
        name: str = None,
        service_connection_id: int = None,
        tag_ids: str = None,
        type: str = None,
    ):
        self.aliyun_region = aliyun_region
        self.ecs_label_key = ecs_label_key
        self.ecs_label_value = ecs_label_value
        self.ecs_type = ecs_type
        self.env_id = env_id
        self.machine_infos = machine_infos
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.service_connection_id = service_connection_id
        self.tag_ids = tag_ids
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_region is not None:
            result['aliyunRegion'] = self.aliyun_region
        if self.ecs_label_key is not None:
            result['ecsLabelKey'] = self.ecs_label_key
        if self.ecs_label_value is not None:
            result['ecsLabelValue'] = self.ecs_label_value
        if self.ecs_type is not None:
            result['ecsType'] = self.ecs_type
        if self.env_id is not None:
            result['envId'] = self.env_id
        if self.machine_infos is not None:
            result['machineInfos'] = self.machine_infos
        if self.name is not None:
            result['name'] = self.name
        if self.service_connection_id is not None:
            result['serviceConnectionId'] = self.service_connection_id
        if self.tag_ids is not None:
            result['tagIds'] = self.tag_ids
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunRegion') is not None:
            self.aliyun_region = m.get('aliyunRegion')
        if m.get('ecsLabelKey') is not None:
            self.ecs_label_key = m.get('ecsLabelKey')
        if m.get('ecsLabelValue') is not None:
            self.ecs_label_value = m.get('ecsLabelValue')
        if m.get('ecsType') is not None:
            self.ecs_type = m.get('ecsType')
        if m.get('envId') is not None:
            self.env_id = m.get('envId')
        if m.get('machineInfos') is not None:
            self.machine_infos = m.get('machineInfos')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('serviceConnectionId') is not None:
            self.service_connection_id = m.get('serviceConnectionId')
        if m.get('tagIds') is not None:
            self.tag_ids = m.get('tagIds')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CreateHostGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        host_group_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.host_group_id = host_group_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.host_group_id is not None:
            result['hostGroupId'] = self.host_group_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('hostGroupId') is not None:
            self.host_group_id = m.get('hostGroupId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateHostGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateHostGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHostGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        create_from: str = None,
        description: str = None,
        reviewer_ids: List[str] = None,
        source_branch: str = None,
        source_project_id: int = None,
        target_branch: str = None,
        target_project_id: int = None,
        title: str = None,
        work_item_ids: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.create_from = create_from
        self.description = description
        self.reviewer_ids = reviewer_ids
        # This parameter is required.
        self.source_branch = source_branch
        # This parameter is required.
        self.source_project_id = source_project_id
        # This parameter is required.
        self.target_branch = target_branch
        # This parameter is required.
        self.target_project_id = target_project_id
        # This parameter is required.
        self.title = title
        self.work_item_ids = work_item_ids
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.create_from is not None:
            result['createFrom'] = self.create_from
        if self.description is not None:
            result['description'] = self.description
        if self.reviewer_ids is not None:
            result['reviewerIds'] = self.reviewer_ids
        if self.source_branch is not None:
            result['sourceBranch'] = self.source_branch
        if self.source_project_id is not None:
            result['sourceProjectId'] = self.source_project_id
        if self.target_branch is not None:
            result['targetBranch'] = self.target_branch
        if self.target_project_id is not None:
            result['targetProjectId'] = self.target_project_id
        if self.title is not None:
            result['title'] = self.title
        if self.work_item_ids is not None:
            result['workItemIds'] = self.work_item_ids
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('createFrom') is not None:
            self.create_from = m.get('createFrom')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('reviewerIds') is not None:
            self.reviewer_ids = m.get('reviewerIds')
        if m.get('sourceBranch') is not None:
            self.source_branch = m.get('sourceBranch')
        if m.get('sourceProjectId') is not None:
            self.source_project_id = m.get('sourceProjectId')
        if m.get('targetBranch') is not None:
            self.target_branch = m.get('targetBranch')
        if m.get('targetProjectId') is not None:
            self.target_project_id = m.get('targetProjectId')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('workItemIds') is not None:
            self.work_item_ids = m.get('workItemIds')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateMergeRequestResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class CreateMergeRequestResponseBodyResultReviewers(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        has_reviewed: bool = None,
        id: int = None,
        name: str = None,
        review_opinion_status: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.has_reviewed = has_reviewed
        self.id = id
        self.name = name
        self.review_opinion_status = review_opinion_status
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.has_reviewed is not None:
            result['hasReviewed'] = self.has_reviewed
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.review_opinion_status is not None:
            result['reviewOpinionStatus'] = self.review_opinion_status
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('hasReviewed') is not None:
            self.has_reviewed = m.get('hasReviewed')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('reviewOpinionStatus') is not None:
            self.review_opinion_status = m.get('reviewOpinionStatus')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class CreateMergeRequestResponseBodyResultSubscribers(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class CreateMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        ahead: int = None,
        all_requirements_pass: bool = None,
        author: CreateMergeRequestResponseBodyResultAuthor = None,
        behind: int = None,
        create_from: str = None,
        create_time: str = None,
        description: str = None,
        detail_url: str = None,
        local_id: int = None,
        mr_biz_id: str = None,
        mr_type: str = None,
        project_id: int = None,
        reviewers: List[CreateMergeRequestResponseBodyResultReviewers] = None,
        source_branch: str = None,
        source_project_id: int = None,
        status: str = None,
        subscribers: List[CreateMergeRequestResponseBodyResultSubscribers] = None,
        support_merge_fast_forward_only: bool = None,
        target_branch: str = None,
        target_project_id: int = None,
        title: str = None,
        update_time: str = None,
        web_url: str = None,
    ):
        self.ahead = ahead
        self.all_requirements_pass = all_requirements_pass
        self.author = author
        self.behind = behind
        self.create_from = create_from
        self.create_time = create_time
        self.description = description
        self.detail_url = detail_url
        self.local_id = local_id
        self.mr_biz_id = mr_biz_id
        self.mr_type = mr_type
        self.project_id = project_id
        self.reviewers = reviewers
        self.source_branch = source_branch
        self.source_project_id = source_project_id
        self.status = status
        self.subscribers = subscribers
        self.support_merge_fast_forward_only = support_merge_fast_forward_only
        self.target_branch = target_branch
        self.target_project_id = target_project_id
        self.title = title
        self.update_time = update_time
        self.web_url = web_url

    def validate(self):
        if self.author:
            self.author.validate()
        if self.reviewers:
            for k in self.reviewers:
                if k:
                    k.validate()
        if self.subscribers:
            for k in self.subscribers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ahead is not None:
            result['ahead'] = self.ahead
        if self.all_requirements_pass is not None:
            result['allRequirementsPass'] = self.all_requirements_pass
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.behind is not None:
            result['behind'] = self.behind
        if self.create_from is not None:
            result['createFrom'] = self.create_from
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.mr_biz_id is not None:
            result['mrBizId'] = self.mr_biz_id
        if self.mr_type is not None:
            result['mrType'] = self.mr_type
        if self.project_id is not None:
            result['projectId'] = self.project_id
        result['reviewers'] = []
        if self.reviewers is not None:
            for k in self.reviewers:
                result['reviewers'].append(k.to_map() if k else None)
        if self.source_branch is not None:
            result['sourceBranch'] = self.source_branch
        if self.source_project_id is not None:
            result['sourceProjectId'] = self.source_project_id
        if self.status is not None:
            result['status'] = self.status
        result['subscribers'] = []
        if self.subscribers is not None:
            for k in self.subscribers:
                result['subscribers'].append(k.to_map() if k else None)
        if self.support_merge_fast_forward_only is not None:
            result['supportMergeFastForwardOnly'] = self.support_merge_fast_forward_only
        if self.target_branch is not None:
            result['targetBranch'] = self.target_branch
        if self.target_project_id is not None:
            result['targetProjectId'] = self.target_project_id
        if self.title is not None:
            result['title'] = self.title
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ahead') is not None:
            self.ahead = m.get('ahead')
        if m.get('allRequirementsPass') is not None:
            self.all_requirements_pass = m.get('allRequirementsPass')
        if m.get('author') is not None:
            temp_model = CreateMergeRequestResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('behind') is not None:
            self.behind = m.get('behind')
        if m.get('createFrom') is not None:
            self.create_from = m.get('createFrom')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            self.detail_url = m.get('detailUrl')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('mrBizId') is not None:
            self.mr_biz_id = m.get('mrBizId')
        if m.get('mrType') is not None:
            self.mr_type = m.get('mrType')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        self.reviewers = []
        if m.get('reviewers') is not None:
            for k in m.get('reviewers'):
                temp_model = CreateMergeRequestResponseBodyResultReviewers()
                self.reviewers.append(temp_model.from_map(k))
        if m.get('sourceBranch') is not None:
            self.source_branch = m.get('sourceBranch')
        if m.get('sourceProjectId') is not None:
            self.source_project_id = m.get('sourceProjectId')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.subscribers = []
        if m.get('subscribers') is not None:
            for k in m.get('subscribers'):
                temp_model = CreateMergeRequestResponseBodyResultSubscribers()
                self.subscribers.append(temp_model.from_map(k))
        if m.get('supportMergeFastForwardOnly') is not None:
            self.support_merge_fast_forward_only = m.get('supportMergeFastForwardOnly')
        if m.get('targetBranch') is not None:
            self.target_branch = m.get('targetBranch')
        if m.get('targetProjectId') is not None:
            self.target_project_id = m.get('targetProjectId')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class CreateMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateOAuthTokenRequest(TeaModel):
    def __init__(
        self,
        client_id: str = None,
        client_secret: str = None,
        code: str = None,
        grant_type: str = None,
        login: str = None,
        scope: str = None,
    ):
        # clientId
        # 
        # This parameter is required.
        self.client_id = client_id
        # client_secret
        # 
        # This parameter is required.
        self.client_secret = client_secret
        self.code = code
        # This parameter is required.
        self.grant_type = grant_type
        self.login = login
        # This parameter is required.
        self.scope = scope

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_id is not None:
            result['clientId'] = self.client_id
        if self.client_secret is not None:
            result['clientSecret'] = self.client_secret
        if self.code is not None:
            result['code'] = self.code
        if self.grant_type is not None:
            result['grantType'] = self.grant_type
        if self.login is not None:
            result['login'] = self.login
        if self.scope is not None:
            result['scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clientId') is not None:
            self.client_id = m.get('clientId')
        if m.get('clientSecret') is not None:
            self.client_secret = m.get('clientSecret')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('grantType') is not None:
            self.grant_type = m.get('grantType')
        if m.get('login') is not None:
            self.login = m.get('login')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        return self


class CreateOAuthTokenResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        id: str = None,
        scope: str = None,
        token_type: str = None,
    ):
        self.access_token = access_token
        # id
        self.id = id
        self.scope = scope
        self.token_type = token_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.id is not None:
            result['id'] = self.id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.token_type is not None:
            result['tokenType'] = self.token_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('tokenType') is not None:
            self.token_type = m.get('tokenType')
        return self


class CreateOAuthTokenResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateOAuthTokenResponseBodyResult = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateOAuthTokenResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateOAuthTokenResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateOAuthTokenResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateOAuthTokenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePipelineRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        name: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreatePipelineResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipelin_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipelin_id = pipelin_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.pipelin_id is not None:
            result['pipelinId'] = self.pipelin_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('pipelinId') is not None:
            self.pipelin_id = m.get('pipelinId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreatePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePipelineGroupRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreatePipelineGroupResponseBodyPipelineGroup(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreatePipelineGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipeline_group: CreatePipelineGroupResponseBodyPipelineGroup = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipeline_group = pipeline_group
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.pipeline_group:
            self.pipeline_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.pipeline_group is not None:
            result['pipelineGroup'] = self.pipeline_group.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('pipelineGroup') is not None:
            temp_model = CreatePipelineGroupResponseBodyPipelineGroup()
            self.pipeline_group = temp_model.from_map(m['pipelineGroup'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreatePipelineGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePipelineGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePipelineGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectRequest(TeaModel):
    def __init__(
        self,
        custom_code: str = None,
        name: str = None,
        scope: str = None,
        template_identifier: str = None,
    ):
        # This parameter is required.
        self.custom_code = custom_code
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.scope = scope
        # This parameter is required.
        self.template_identifier = template_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_code is not None:
            result['customCode'] = self.custom_code
        if self.name is not None:
            result['name'] = self.name
        if self.scope is not None:
            result['scope'] = self.scope
        if self.template_identifier is not None:
            result['templateIdentifier'] = self.template_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('customCode') is not None:
            self.custom_code = m.get('customCode')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('templateIdentifier') is not None:
            self.template_identifier = m.get('templateIdentifier')
        return self


class CreateProjectResponseBodyProject(TeaModel):
    def __init__(
        self,
        category_identifier: str = None,
        creator: str = None,
        custom_code: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        icon: str = None,
        identifier: str = None,
        logical_status: str = None,
        modifier: str = None,
        name: str = None,
        organization_identifier: str = None,
        scope: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        type_identifier: str = None,
    ):
        self.category_identifier = category_identifier
        self.creator = creator
        self.custom_code = custom_code
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.icon = icon
        self.identifier = identifier
        self.logical_status = logical_status
        self.modifier = modifier
        self.name = name
        self.organization_identifier = organization_identifier
        self.scope = scope
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.type_identifier = type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.custom_code is not None:
            result['customCode'] = self.custom_code
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.icon is not None:
            result['icon'] = self.icon
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.organization_identifier is not None:
            result['organizationIdentifier'] = self.organization_identifier
        if self.scope is not None:
            result['scope'] = self.scope
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.type_identifier is not None:
            result['typeIdentifier'] = self.type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('customCode') is not None:
            self.custom_code = m.get('customCode')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationIdentifier') is not None:
            self.organization_identifier = m.get('organizationIdentifier')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('typeIdentifier') is not None:
            self.type_identifier = m.get('typeIdentifier')
        return self


class CreateProjectResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        project: CreateProjectResponseBodyProject = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.project = project
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.project is not None:
            result['project'] = self.project.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('project') is not None:
            temp_model = CreateProjectResponseBodyProject()
            self.project = temp_model.from_map(m['project'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProjectLabelRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        color: str = None,
        description: str = None,
        name: str = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.color = color
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class CreateProjectLabelResponseBodyResult(TeaModel):
    def __init__(
        self,
        color: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
    ):
        self.color = color
        self.description = description
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateProjectLabelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateProjectLabelResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateProjectLabelResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateProjectLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProjectLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProjectLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateProtectdBranchRequestMergeRequestSetting(TeaModel):
    def __init__(
        self,
        allow_merge_request_roles: List[int] = None,
        default_assignees: List[str] = None,
        is_allow_self_approval: bool = None,
        is_require_discussion_processed: bool = None,
        is_required: bool = None,
        is_reset_approval_when_new_push: bool = None,
        minimum_approval: int = None,
        mr_mode: str = None,
        white_list: str = None,
    ):
        self.allow_merge_request_roles = allow_merge_request_roles
        self.default_assignees = default_assignees
        self.is_allow_self_approval = is_allow_self_approval
        self.is_require_discussion_processed = is_require_discussion_processed
        self.is_required = is_required
        self.is_reset_approval_when_new_push = is_reset_approval_when_new_push
        self.minimum_approval = minimum_approval
        self.mr_mode = mr_mode
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_request_roles is not None:
            result['allowMergeRequestRoles'] = self.allow_merge_request_roles
        if self.default_assignees is not None:
            result['defaultAssignees'] = self.default_assignees
        if self.is_allow_self_approval is not None:
            result['isAllowSelfApproval'] = self.is_allow_self_approval
        if self.is_require_discussion_processed is not None:
            result['isRequireDiscussionProcessed'] = self.is_require_discussion_processed
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_reset_approval_when_new_push is not None:
            result['isResetApprovalWhenNewPush'] = self.is_reset_approval_when_new_push
        if self.minimum_approval is not None:
            result['minimumApproval'] = self.minimum_approval
        if self.mr_mode is not None:
            result['mrMode'] = self.mr_mode
        if self.white_list is not None:
            result['whiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRequestRoles') is not None:
            self.allow_merge_request_roles = m.get('allowMergeRequestRoles')
        if m.get('defaultAssignees') is not None:
            self.default_assignees = m.get('defaultAssignees')
        if m.get('isAllowSelfApproval') is not None:
            self.is_allow_self_approval = m.get('isAllowSelfApproval')
        if m.get('isRequireDiscussionProcessed') is not None:
            self.is_require_discussion_processed = m.get('isRequireDiscussionProcessed')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isResetApprovalWhenNewPush') is not None:
            self.is_reset_approval_when_new_push = m.get('isResetApprovalWhenNewPush')
        if m.get('minimumApproval') is not None:
            self.minimum_approval = m.get('minimumApproval')
        if m.get('mrMode') is not None:
            self.mr_mode = m.get('mrMode')
        if m.get('whiteList') is not None:
            self.white_list = m.get('whiteList')
        return self


class CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems(TeaModel):
    def __init__(
        self,
        is_required: bool = None,
        name: str = None,
    ):
        self.is_required = is_required
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateProtectdBranchRequestTestSettingDTOCheckConfig(TeaModel):
    def __init__(
        self,
        check_items: List[CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems] = None,
    ):
        self.check_items = check_items

    def validate(self):
        if self.check_items:
            for k in self.check_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['checkItems'] = []
        if self.check_items is not None:
            for k in self.check_items:
                result['checkItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_items = []
        if m.get('checkItems') is not None:
            for k in m.get('checkItems'):
                temp_model = CreateProtectdBranchRequestTestSettingDTOCheckConfigCheckItems()
                self.check_items.append(temp_model.from_map(k))
        return self


class CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig(TeaModel):
    def __init__(
        self,
        biz_no: str = None,
        enabled: bool = None,
        message: str = None,
        task_name: str = None,
    ):
        self.biz_no = biz_no
        self.enabled = enabled
        self.message = message
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_no is not None:
            result['bizNo'] = self.biz_no
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizNo') is not None:
            self.biz_no = m.get('bizNo')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class CreateProtectdBranchRequestTestSettingDTO(TeaModel):
    def __init__(
        self,
        check_config: CreateProtectdBranchRequestTestSettingDTOCheckConfig = None,
        check_task_quality_config: CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig = None,
        code_guidelines_detection: CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection = None,
        is_required: bool = None,
        sensitive_info_detection: CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection = None,
    ):
        self.check_config = check_config
        self.check_task_quality_config = check_task_quality_config
        self.code_guidelines_detection = code_guidelines_detection
        self.is_required = is_required
        self.sensitive_info_detection = sensitive_info_detection

    def validate(self):
        if self.check_config:
            self.check_config.validate()
        if self.check_task_quality_config:
            self.check_task_quality_config.validate()
        if self.code_guidelines_detection:
            self.code_guidelines_detection.validate()
        if self.sensitive_info_detection:
            self.sensitive_info_detection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_config is not None:
            result['checkConfig'] = self.check_config.to_map()
        if self.check_task_quality_config is not None:
            result['checkTaskQualityConfig'] = self.check_task_quality_config.to_map()
        if self.code_guidelines_detection is not None:
            result['codeGuidelinesDetection'] = self.code_guidelines_detection.to_map()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.sensitive_info_detection is not None:
            result['sensitiveInfoDetection'] = self.sensitive_info_detection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkConfig') is not None:
            temp_model = CreateProtectdBranchRequestTestSettingDTOCheckConfig()
            self.check_config = temp_model.from_map(m['checkConfig'])
        if m.get('checkTaskQualityConfig') is not None:
            temp_model = CreateProtectdBranchRequestTestSettingDTOCheckTaskQualityConfig()
            self.check_task_quality_config = temp_model.from_map(m['checkTaskQualityConfig'])
        if m.get('codeGuidelinesDetection') is not None:
            temp_model = CreateProtectdBranchRequestTestSettingDTOCodeGuidelinesDetection()
            self.code_guidelines_detection = temp_model.from_map(m['codeGuidelinesDetection'])
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('sensitiveInfoDetection') is not None:
            temp_model = CreateProtectdBranchRequestTestSettingDTOSensitiveInfoDetection()
            self.sensitive_info_detection = temp_model.from_map(m['sensitiveInfoDetection'])
        return self


class CreateProtectdBranchRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        allow_merge_roles: List[int] = None,
        allow_merge_user_ids: List[str] = None,
        allow_push_roles: List[int] = None,
        allow_push_user_ids: List[str] = None,
        branch: str = None,
        id: int = None,
        merge_request_setting: CreateProtectdBranchRequestMergeRequestSetting = None,
        test_setting_dto: CreateProtectdBranchRequestTestSettingDTO = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.allow_merge_roles = allow_merge_roles
        self.allow_merge_user_ids = allow_merge_user_ids
        self.allow_push_roles = allow_push_roles
        self.allow_push_user_ids = allow_push_user_ids
        # This parameter is required.
        self.branch = branch
        self.id = id
        self.merge_request_setting = merge_request_setting
        self.test_setting_dto = test_setting_dto
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.merge_request_setting:
            self.merge_request_setting.validate()
        if self.test_setting_dto:
            self.test_setting_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.allow_merge_roles is not None:
            result['allowMergeRoles'] = self.allow_merge_roles
        if self.allow_merge_user_ids is not None:
            result['allowMergeUserIds'] = self.allow_merge_user_ids
        if self.allow_push_roles is not None:
            result['allowPushRoles'] = self.allow_push_roles
        if self.allow_push_user_ids is not None:
            result['allowPushUserIds'] = self.allow_push_user_ids
        if self.branch is not None:
            result['branch'] = self.branch
        if self.id is not None:
            result['id'] = self.id
        if self.merge_request_setting is not None:
            result['mergeRequestSetting'] = self.merge_request_setting.to_map()
        if self.test_setting_dto is not None:
            result['testSettingDTO'] = self.test_setting_dto.to_map()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('allowMergeRoles') is not None:
            self.allow_merge_roles = m.get('allowMergeRoles')
        if m.get('allowMergeUserIds') is not None:
            self.allow_merge_user_ids = m.get('allowMergeUserIds')
        if m.get('allowPushRoles') is not None:
            self.allow_push_roles = m.get('allowPushRoles')
        if m.get('allowPushUserIds') is not None:
            self.allow_push_user_ids = m.get('allowPushUserIds')
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mergeRequestSetting') is not None:
            temp_model = CreateProtectdBranchRequestMergeRequestSetting()
            self.merge_request_setting = temp_model.from_map(m['mergeRequestSetting'])
        if m.get('testSettingDTO') is not None:
            temp_model = CreateProtectdBranchRequestTestSettingDTO()
            self.test_setting_dto = temp_model.from_map(m['testSettingDTO'])
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateProtectdBranchResponseBodyResultMergeRequestSetting(TeaModel):
    def __init__(
        self,
        allow_merge_request_roles: List[int] = None,
        default_assignees: List[str] = None,
        is_allow_self_approval: bool = None,
        is_require_discussion_processed: bool = None,
        is_required: bool = None,
        is_reset_approval_when_new_push: bool = None,
        minimum_approval: int = None,
        mr_mode: str = None,
        white_list: str = None,
    ):
        self.allow_merge_request_roles = allow_merge_request_roles
        self.default_assignees = default_assignees
        self.is_allow_self_approval = is_allow_self_approval
        self.is_require_discussion_processed = is_require_discussion_processed
        self.is_required = is_required
        self.is_reset_approval_when_new_push = is_reset_approval_when_new_push
        self.minimum_approval = minimum_approval
        self.mr_mode = mr_mode
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_request_roles is not None:
            result['allowMergeRequestRoles'] = self.allow_merge_request_roles
        if self.default_assignees is not None:
            result['defaultAssignees'] = self.default_assignees
        if self.is_allow_self_approval is not None:
            result['isAllowSelfApproval'] = self.is_allow_self_approval
        if self.is_require_discussion_processed is not None:
            result['isRequireDiscussionProcessed'] = self.is_require_discussion_processed
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_reset_approval_when_new_push is not None:
            result['isResetApprovalWhenNewPush'] = self.is_reset_approval_when_new_push
        if self.minimum_approval is not None:
            result['minimumApproval'] = self.minimum_approval
        if self.mr_mode is not None:
            result['mrMode'] = self.mr_mode
        if self.white_list is not None:
            result['whiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRequestRoles') is not None:
            self.allow_merge_request_roles = m.get('allowMergeRequestRoles')
        if m.get('defaultAssignees') is not None:
            self.default_assignees = m.get('defaultAssignees')
        if m.get('isAllowSelfApproval') is not None:
            self.is_allow_self_approval = m.get('isAllowSelfApproval')
        if m.get('isRequireDiscussionProcessed') is not None:
            self.is_require_discussion_processed = m.get('isRequireDiscussionProcessed')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isResetApprovalWhenNewPush') is not None:
            self.is_reset_approval_when_new_push = m.get('isResetApprovalWhenNewPush')
        if m.get('minimumApproval') is not None:
            self.minimum_approval = m.get('minimumApproval')
        if m.get('mrMode') is not None:
            self.mr_mode = m.get('mrMode')
        if m.get('whiteList') is not None:
            self.white_list = m.get('whiteList')
        return self


class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems(TeaModel):
    def __init__(
        self,
        is_required: bool = None,
        name: str = None,
    ):
        self.is_required = is_required
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig(TeaModel):
    def __init__(
        self,
        check_items: List[CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems] = None,
    ):
        self.check_items = check_items

    def validate(self):
        if self.check_items:
            for k in self.check_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['checkItems'] = []
        if self.check_items is not None:
            for k in self.check_items:
                result['checkItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_items = []
        if m.get('checkItems') is not None:
            for k in m.get('checkItems'):
                temp_model = CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfigCheckItems()
                self.check_items.append(temp_model.from_map(k))
        return self


class CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig(TeaModel):
    def __init__(
        self,
        biz_no: str = None,
        enabled: bool = None,
        message: str = None,
        task_name: str = None,
    ):
        self.biz_no = biz_no
        self.enabled = enabled
        self.message = message
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_no is not None:
            result['bizNo'] = self.biz_no
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizNo') is not None:
            self.biz_no = m.get('bizNo')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class CreateProtectdBranchResponseBodyResultTestSettingDTO(TeaModel):
    def __init__(
        self,
        check_config: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig = None,
        check_task_quality_config: CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig = None,
        code_guidelines_detection: CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection = None,
        is_required: bool = None,
        sensitive_info_detection: CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection = None,
    ):
        self.check_config = check_config
        self.check_task_quality_config = check_task_quality_config
        self.code_guidelines_detection = code_guidelines_detection
        self.is_required = is_required
        self.sensitive_info_detection = sensitive_info_detection

    def validate(self):
        if self.check_config:
            self.check_config.validate()
        if self.check_task_quality_config:
            self.check_task_quality_config.validate()
        if self.code_guidelines_detection:
            self.code_guidelines_detection.validate()
        if self.sensitive_info_detection:
            self.sensitive_info_detection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_config is not None:
            result['checkConfig'] = self.check_config.to_map()
        if self.check_task_quality_config is not None:
            result['checkTaskQualityConfig'] = self.check_task_quality_config.to_map()
        if self.code_guidelines_detection is not None:
            result['codeGuidelinesDetection'] = self.code_guidelines_detection.to_map()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.sensitive_info_detection is not None:
            result['sensitiveInfoDetection'] = self.sensitive_info_detection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkConfig') is not None:
            temp_model = CreateProtectdBranchResponseBodyResultTestSettingDTOCheckConfig()
            self.check_config = temp_model.from_map(m['checkConfig'])
        if m.get('checkTaskQualityConfig') is not None:
            temp_model = CreateProtectdBranchResponseBodyResultTestSettingDTOCheckTaskQualityConfig()
            self.check_task_quality_config = temp_model.from_map(m['checkTaskQualityConfig'])
        if m.get('codeGuidelinesDetection') is not None:
            temp_model = CreateProtectdBranchResponseBodyResultTestSettingDTOCodeGuidelinesDetection()
            self.code_guidelines_detection = temp_model.from_map(m['codeGuidelinesDetection'])
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('sensitiveInfoDetection') is not None:
            temp_model = CreateProtectdBranchResponseBodyResultTestSettingDTOSensitiveInfoDetection()
            self.sensitive_info_detection = temp_model.from_map(m['sensitiveInfoDetection'])
        return self


class CreateProtectdBranchResponseBodyResult(TeaModel):
    def __init__(
        self,
        allow_merge_roles: List[int] = None,
        allow_merge_user_ids: List[int] = None,
        allow_push_roles: List[int] = None,
        allow_push_user_ids: List[int] = None,
        branch: str = None,
        id: int = None,
        merge_request_setting: CreateProtectdBranchResponseBodyResultMergeRequestSetting = None,
        test_setting_dto: CreateProtectdBranchResponseBodyResultTestSettingDTO = None,
    ):
        self.allow_merge_roles = allow_merge_roles
        self.allow_merge_user_ids = allow_merge_user_ids
        self.allow_push_roles = allow_push_roles
        self.allow_push_user_ids = allow_push_user_ids
        self.branch = branch
        self.id = id
        self.merge_request_setting = merge_request_setting
        self.test_setting_dto = test_setting_dto

    def validate(self):
        if self.merge_request_setting:
            self.merge_request_setting.validate()
        if self.test_setting_dto:
            self.test_setting_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_roles is not None:
            result['allowMergeRoles'] = self.allow_merge_roles
        if self.allow_merge_user_ids is not None:
            result['allowMergeUserIds'] = self.allow_merge_user_ids
        if self.allow_push_roles is not None:
            result['allowPushRoles'] = self.allow_push_roles
        if self.allow_push_user_ids is not None:
            result['allowPushUserIds'] = self.allow_push_user_ids
        if self.branch is not None:
            result['branch'] = self.branch
        if self.id is not None:
            result['id'] = self.id
        if self.merge_request_setting is not None:
            result['mergeRequestSetting'] = self.merge_request_setting.to_map()
        if self.test_setting_dto is not None:
            result['testSettingDTO'] = self.test_setting_dto.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRoles') is not None:
            self.allow_merge_roles = m.get('allowMergeRoles')
        if m.get('allowMergeUserIds') is not None:
            self.allow_merge_user_ids = m.get('allowMergeUserIds')
        if m.get('allowPushRoles') is not None:
            self.allow_push_roles = m.get('allowPushRoles')
        if m.get('allowPushUserIds') is not None:
            self.allow_push_user_ids = m.get('allowPushUserIds')
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mergeRequestSetting') is not None:
            temp_model = CreateProtectdBranchResponseBodyResultMergeRequestSetting()
            self.merge_request_setting = temp_model.from_map(m['mergeRequestSetting'])
        if m.get('testSettingDTO') is not None:
            temp_model = CreateProtectdBranchResponseBodyResultTestSettingDTO()
            self.test_setting_dto = temp_model.from_map(m['testSettingDTO'])
        return self


class CreateProtectdBranchResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateProtectdBranchResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateProtectdBranchResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateProtectdBranchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateProtectdBranchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateProtectdBranchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePushRuleRequestRuleInfos(TeaModel):
    def __init__(
        self,
        checker_name: str = None,
        checker_type: str = None,
        extra_message: str = None,
        file_rule_regexes: List[str] = None,
    ):
        self.checker_name = checker_name
        self.checker_type = checker_type
        self.extra_message = extra_message
        self.file_rule_regexes = file_rule_regexes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checker_name is not None:
            result['checkerName'] = self.checker_name
        if self.checker_type is not None:
            result['checkerType'] = self.checker_type
        if self.extra_message is not None:
            result['extraMessage'] = self.extra_message
        if self.file_rule_regexes is not None:
            result['fileRuleRegexes'] = self.file_rule_regexes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkerName') is not None:
            self.checker_name = m.get('checkerName')
        if m.get('checkerType') is not None:
            self.checker_type = m.get('checkerType')
        if m.get('extraMessage') is not None:
            self.extra_message = m.get('extraMessage')
        if m.get('fileRuleRegexes') is not None:
            self.file_rule_regexes = m.get('fileRuleRegexes')
        return self


class CreatePushRuleRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        rule_infos: List[CreatePushRuleRequestRuleInfos] = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.rule_infos = rule_infos
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.rule_infos:
            for k in self.rule_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        result['ruleInfos'] = []
        if self.rule_infos is not None:
            for k in self.rule_infos:
                result['ruleInfos'].append(k.to_map() if k else None)
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        self.rule_infos = []
        if m.get('ruleInfos') is not None:
            for k in m.get('ruleInfos'):
                temp_model = CreatePushRuleRequestRuleInfos()
                self.rule_infos.append(temp_model.from_map(k))
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreatePushRuleResponseBodyResultRuleInfos(TeaModel):
    def __init__(
        self,
        checker_name: str = None,
        checker_type: str = None,
        extra_message: str = None,
        file_rule_regexes: List[str] = None,
    ):
        self.checker_name = checker_name
        self.checker_type = checker_type
        self.extra_message = extra_message
        self.file_rule_regexes = file_rule_regexes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checker_name is not None:
            result['checkerName'] = self.checker_name
        if self.checker_type is not None:
            result['checkerType'] = self.checker_type
        if self.extra_message is not None:
            result['extraMessage'] = self.extra_message
        if self.file_rule_regexes is not None:
            result['fileRuleRegexes'] = self.file_rule_regexes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkerName') is not None:
            self.checker_name = m.get('checkerName')
        if m.get('checkerType') is not None:
            self.checker_type = m.get('checkerType')
        if m.get('extraMessage') is not None:
            self.extra_message = m.get('extraMessage')
        if m.get('fileRuleRegexes') is not None:
            self.file_rule_regexes = m.get('fileRuleRegexes')
        return self


class CreatePushRuleResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        rule_infos: List[CreatePushRuleResponseBodyResultRuleInfos] = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.rule_infos = rule_infos

    def validate(self):
        if self.rule_infos:
            for k in self.rule_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        result['ruleInfos'] = []
        if self.rule_infos is not None:
            for k in self.rule_infos:
                result['ruleInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        self.rule_infos = []
        if m.get('ruleInfos') is not None:
            for k in m.get('ruleInfos'):
                temp_model = CreatePushRuleResponseBodyResultRuleInfos()
                self.rule_infos.append(temp_model.from_map(k))
        return self


class CreatePushRuleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreatePushRuleResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreatePushRuleResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreatePushRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreatePushRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePushRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRepositoryRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        avatar_url: str = None,
        description: str = None,
        gitignore_type: str = None,
        import_account: str = None,
        import_demo_project: bool = None,
        import_repo_type: str = None,
        import_token: str = None,
        import_token_encrypted: str = None,
        import_url: str = None,
        init_standard_service: bool = None,
        is_crypto_enabled: bool = None,
        local_import_url: str = None,
        name: str = None,
        namespace_id: int = None,
        path: str = None,
        readme_type: str = None,
        visibility_level: int = None,
        create_parent_path: bool = None,
        organization_id: str = None,
        sync: bool = None,
    ):
        self.access_token = access_token
        self.avatar_url = avatar_url
        self.description = description
        self.gitignore_type = gitignore_type
        self.import_account = import_account
        self.import_demo_project = import_demo_project
        self.import_repo_type = import_repo_type
        self.import_token = import_token
        self.import_token_encrypted = import_token_encrypted
        self.import_url = import_url
        self.init_standard_service = init_standard_service
        self.is_crypto_enabled = is_crypto_enabled
        self.local_import_url = local_import_url
        # This parameter is required.
        self.name = name
        self.namespace_id = namespace_id
        self.path = path
        self.readme_type = readme_type
        self.visibility_level = visibility_level
        self.create_parent_path = create_parent_path
        # This parameter is required.
        self.organization_id = organization_id
        self.sync = sync

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.gitignore_type is not None:
            result['gitignoreType'] = self.gitignore_type
        if self.import_account is not None:
            result['importAccount'] = self.import_account
        if self.import_demo_project is not None:
            result['importDemoProject'] = self.import_demo_project
        if self.import_repo_type is not None:
            result['importRepoType'] = self.import_repo_type
        if self.import_token is not None:
            result['importToken'] = self.import_token
        if self.import_token_encrypted is not None:
            result['importTokenEncrypted'] = self.import_token_encrypted
        if self.import_url is not None:
            result['importUrl'] = self.import_url
        if self.init_standard_service is not None:
            result['initStandardService'] = self.init_standard_service
        if self.is_crypto_enabled is not None:
            result['isCryptoEnabled'] = self.is_crypto_enabled
        if self.local_import_url is not None:
            result['localImportUrl'] = self.local_import_url
        if self.name is not None:
            result['name'] = self.name
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.path is not None:
            result['path'] = self.path
        if self.readme_type is not None:
            result['readmeType'] = self.readme_type
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.create_parent_path is not None:
            result['createParentPath'] = self.create_parent_path
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.sync is not None:
            result['sync'] = self.sync
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gitignoreType') is not None:
            self.gitignore_type = m.get('gitignoreType')
        if m.get('importAccount') is not None:
            self.import_account = m.get('importAccount')
        if m.get('importDemoProject') is not None:
            self.import_demo_project = m.get('importDemoProject')
        if m.get('importRepoType') is not None:
            self.import_repo_type = m.get('importRepoType')
        if m.get('importToken') is not None:
            self.import_token = m.get('importToken')
        if m.get('importTokenEncrypted') is not None:
            self.import_token_encrypted = m.get('importTokenEncrypted')
        if m.get('importUrl') is not None:
            self.import_url = m.get('importUrl')
        if m.get('initStandardService') is not None:
            self.init_standard_service = m.get('initStandardService')
        if m.get('isCryptoEnabled') is not None:
            self.is_crypto_enabled = m.get('isCryptoEnabled')
        if m.get('localImportUrl') is not None:
            self.local_import_url = m.get('localImportUrl')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('readmeType') is not None:
            self.readme_type = m.get('readmeType')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('createParentPath') is not None:
            self.create_parent_path = m.get('createParentPath')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('sync') is not None:
            self.sync = m.get('sync')
        return self


class CreateRepositoryResponseBodyResultNamespace(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        created_at: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        owner_id: int = None,
        path: str = None,
        public: bool = None,
        updated_at: str = None,
        visibility_level: str = None,
    ):
        self.avatar = avatar
        self.created_at = created_at
        self.description = description
        # id
        self.id = id
        self.name = name
        self.owner_id = owner_id
        self.path = path
        self.public = public
        self.updated_at = updated_at
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.path is not None:
            result['path'] = self.path
        if self.public is not None:
            result['public'] = self.public
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('public') is not None:
            self.public = m.get('public')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class CreateRepositoryResponseBodyResult(TeaModel):
    def __init__(
        self,
        import_from_svn: bool = None,
        archived: bool = None,
        avatar_url: str = None,
        created_at: str = None,
        creator_id: int = None,
        default_branch: str = None,
        demo_project: bool = None,
        description: str = None,
        http_url_to_repo: str = None,
        id: int = None,
        last_activity_at: str = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace: CreateRepositoryResponseBodyResultNamespace = None,
        path: str = None,
        path_with_namespace: str = None,
        ssh_url_to_repo: str = None,
        visibility_level: str = None,
        web_url: str = None,
    ):
        self.import_from_svn = import_from_svn
        self.archived = archived
        self.avatar_url = avatar_url
        self.created_at = created_at
        self.creator_id = creator_id
        self.default_branch = default_branch
        self.demo_project = demo_project
        self.description = description
        self.http_url_to_repo = http_url_to_repo
        # id
        self.id = id
        self.last_activity_at = last_activity_at
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace = namespace
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.ssh_url_to_repo = ssh_url_to_repo
        self.visibility_level = visibility_level
        # web url
        self.web_url = web_url

    def validate(self):
        if self.namespace:
            self.namespace.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.import_from_svn is not None:
            result['Import_from_svn'] = self.import_from_svn
        if self.archived is not None:
            result['archived'] = self.archived
        if self.avatar_url is not None:
            result['avatar_url'] = self.avatar_url
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.default_branch is not None:
            result['defaultBranch'] = self.default_branch
        if self.demo_project is not None:
            result['demoProject'] = self.demo_project
        if self.description is not None:
            result['description'] = self.description
        if self.http_url_to_repo is not None:
            result['httpUrlToRepo'] = self.http_url_to_repo
        if self.id is not None:
            result['id'] = self.id
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace is not None:
            result['namespace'] = self.namespace.to_map()
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.ssh_url_to_repo is not None:
            result['sshUrlToRepo'] = self.ssh_url_to_repo
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Import_from_svn') is not None:
            self.import_from_svn = m.get('Import_from_svn')
        if m.get('archived') is not None:
            self.archived = m.get('archived')
        if m.get('avatar_url') is not None:
            self.avatar_url = m.get('avatar_url')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('defaultBranch') is not None:
            self.default_branch = m.get('defaultBranch')
        if m.get('demoProject') is not None:
            self.demo_project = m.get('demoProject')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('httpUrlToRepo') is not None:
            self.http_url_to_repo = m.get('httpUrlToRepo')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespace') is not None:
            temp_model = CreateRepositoryResponseBodyResultNamespace()
            self.namespace = temp_model.from_map(m['namespace'])
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('sshUrlToRepo') is not None:
            self.ssh_url_to_repo = m.get('sshUrlToRepo')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class CreateRepositoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateRepositoryResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateRepositoryResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateRepositoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRepositoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRepositoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRepositoryGroupRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        avatar_url: str = None,
        description: str = None,
        name: str = None,
        parent_id: int = None,
        path: str = None,
        visibility_level: int = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.avatar_url = avatar_url
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.parent_id = parent_id
        # This parameter is required.
        self.path = path
        # This parameter is required.
        self.visibility_level = visibility_level
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateRepositoryGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        owner_id: int = None,
        parent_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        type: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.description = description
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.type = type
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.type is not None:
            result['type'] = self.type
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class CreateRepositoryGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateRepositoryGroupResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateRepositoryGroupResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateRepositoryGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateRepositoryGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRepositoryGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateResourceMemberRequest(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        role_name: str = None,
    ):
        # This parameter is required.
        self.account_id = account_id
        # This parameter is required.
        self.role_name = role_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.role_name is not None:
            result['roleName'] = self.role_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('roleName') is not None:
            self.role_name = m.get('roleName')
        return self


class CreateResourceMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateResourceMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateResourceMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateResourceMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateServiceAuthRequest(TeaModel):
    def __init__(
        self,
        service_auth_type: str = None,
    ):
        # This parameter is required.
        self.service_auth_type = service_auth_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_auth_type is not None:
            result['serviceAuthType'] = self.service_auth_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('serviceAuthType') is not None:
            self.service_auth_type = m.get('serviceAuthType')
        return self


class CreateServiceAuthResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        id: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.id = id
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateServiceAuthResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateServiceAuthResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateServiceAuthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateServiceConnectionRequest(TeaModel):
    def __init__(
        self,
        auth_type: str = None,
        connection_name: str = None,
        connection_type: str = None,
        scope: str = None,
        service_auth_id: int = None,
    ):
        # This parameter is required.
        self.auth_type = auth_type
        # This parameter is required.
        self.connection_name = connection_name
        # This parameter is required.
        self.connection_type = connection_type
        # This parameter is required.
        self.scope = scope
        # This parameter is required.
        self.service_auth_id = service_auth_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_type is not None:
            result['authType'] = self.auth_type
        if self.connection_name is not None:
            result['connectionName'] = self.connection_name
        if self.connection_type is not None:
            result['connectionType'] = self.connection_type
        if self.scope is not None:
            result['scope'] = self.scope
        if self.service_auth_id is not None:
            result['serviceAuthId'] = self.service_auth_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authType') is not None:
            self.auth_type = m.get('authType')
        if m.get('connectionName') is not None:
            self.connection_name = m.get('connectionName')
        if m.get('connectionType') is not None:
            self.connection_type = m.get('connectionType')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('serviceAuthId') is not None:
            self.service_auth_id = m.get('serviceAuthId')
        return self


class CreateServiceConnectionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.id = id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateServiceConnectionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateServiceConnectionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateServiceConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateServiceCredentialRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
        password: str = None,
        scope: str = None,
        type: str = None,
        username: str = None,
    ):
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.password = password
        self.scope = scope
        # This parameter is required.
        self.type = type
        # This parameter is required.
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.password is not None:
            result['password'] = self.password
        if self.scope is not None:
            result['scope'] = self.scope
        if self.type is not None:
            result['type'] = self.type
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class CreateServiceCredentialResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.id = id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.id is not None:
            result['id'] = self.id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateServiceCredentialResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateServiceCredentialResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateServiceCredentialResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSprintRequest(TeaModel):
    def __init__(
        self,
        end_date: str = None,
        name: str = None,
        space_identifier: str = None,
        staff_ids: List[str] = None,
        start_date: str = None,
    ):
        self.end_date = end_date
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.staff_ids = staff_ids
        self.start_date = start_date

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.name is not None:
            result['name'] = self.name
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.staff_ids is not None:
            result['staffIds'] = self.staff_ids
        if self.start_date is not None:
            result['startDate'] = self.start_date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('staffIds') is not None:
            self.staff_ids = m.get('staffIds')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        return self


class CreateSprintResponseBodySprint(TeaModel):
    def __init__(
        self,
        creator: str = None,
        description: str = None,
        end_date: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        scope: str = None,
        space_identifier: str = None,
        start_date: int = None,
        status: str = None,
    ):
        self.creator = creator
        self.description = description
        self.end_date = end_date
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.scope = scope
        self.space_identifier = space_identifier
        self.start_date = start_date
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.scope is not None:
            result['scope'] = self.scope
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class CreateSprintResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        sprint: CreateSprintResponseBodySprint = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.sprint = sprint
        self.success = success

    def validate(self):
        if self.sprint:
            self.sprint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.sprint is not None:
            result['sprint'] = self.sprint.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sprint') is not None:
            temp_model = CreateSprintResponseBodySprint()
            self.sprint = temp_model.from_map(m['sprint'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateSprintResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSprintResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSprintResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSshKeyResponseBodySshKey(TeaModel):
    def __init__(
        self,
        id: int = None,
        public_key: str = None,
    ):
        self.id = id
        self.public_key = public_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.public_key is not None:
            result['publicKey'] = self.public_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('publicKey') is not None:
            self.public_key = m.get('publicKey')
        return self


class CreateSshKeyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        ssh_key: CreateSshKeyResponseBodySshKey = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.ssh_key = ssh_key
        self.success = success

    def validate(self):
        if self.ssh_key:
            self.ssh_key.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.ssh_key is not None:
            result['sshKey'] = self.ssh_key.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sshKey') is not None:
            temp_model = CreateSshKeyResponseBodySshKey()
            self.ssh_key = temp_model.from_map(m['sshKey'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateSshKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateSshKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSshKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTagRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        message: str = None,
        ref: str = None,
        tag_name: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.message = message
        # This parameter is required.
        self.ref = ref
        # This parameter is required.
        self.tag_name = tag_name
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.message is not None:
            result['message'] = self.message
        if self.ref is not None:
            result['ref'] = self.ref
        if self.tag_name is not None:
            result['tagName'] = self.tag_name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('ref') is not None:
            self.ref = m.get('ref')
        if m.get('tagName') is not None:
            self.tag_name = m.get('tagName')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateTagResponseBodyResultCommit(TeaModel):
    def __init__(
        self,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        committed_date: str = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        title: str = None,
    ):
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.committed_date = committed_date
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateTagResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit: CreateTagResponseBodyResultCommit = None,
        id: str = None,
        message: str = None,
        name: str = None,
    ):
        self.commit = commit
        self.id = id
        self.message = message
        self.name = name

    def validate(self):
        if self.commit:
            self.commit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit is not None:
            result['commit'] = self.commit.to_map()
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commit') is not None:
            temp_model = CreateTagResponseBodyResultCommit()
            self.commit = temp_model.from_map(m['commit'])
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateTagResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateTagResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateTagResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateTestCaseRequestFieldValueList(TeaModel):
    def __init__(
        self,
        field_identifier: str = None,
        value: str = None,
    ):
        self.field_identifier = field_identifier
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateTestCaseRequestTestcaseStepContentInfoStepResultList(TeaModel):
    def __init__(
        self,
        expected: str = None,
        step: str = None,
    ):
        self.expected = expected
        self.step = step

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expected is not None:
            result['expected'] = self.expected
        if self.step is not None:
            result['step'] = self.step
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expected') is not None:
            self.expected = m.get('expected')
        if m.get('step') is not None:
            self.step = m.get('step')
        return self


class CreateTestCaseRequestTestcaseStepContentInfo(TeaModel):
    def __init__(
        self,
        precondition: str = None,
        step_result_list: List[CreateTestCaseRequestTestcaseStepContentInfoStepResultList] = None,
        step_type: str = None,
    ):
        self.precondition = precondition
        self.step_result_list = step_result_list
        # This parameter is required.
        self.step_type = step_type

    def validate(self):
        if self.step_result_list:
            for k in self.step_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.precondition is not None:
            result['precondition'] = self.precondition
        result['stepResultList'] = []
        if self.step_result_list is not None:
            for k in self.step_result_list:
                result['stepResultList'].append(k.to_map() if k else None)
        if self.step_type is not None:
            result['stepType'] = self.step_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('precondition') is not None:
            self.precondition = m.get('precondition')
        self.step_result_list = []
        if m.get('stepResultList') is not None:
            for k in m.get('stepResultList'):
                temp_model = CreateTestCaseRequestTestcaseStepContentInfoStepResultList()
                self.step_result_list.append(temp_model.from_map(k))
        if m.get('stepType') is not None:
            self.step_type = m.get('stepType')
        return self


class CreateTestCaseRequest(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        directory_identifier: str = None,
        field_value_list: List[CreateTestCaseRequestFieldValueList] = None,
        priority: str = None,
        space_identifier: str = None,
        subject: str = None,
        tags: List[str] = None,
        testcase_step_content_info: CreateTestCaseRequestTestcaseStepContentInfo = None,
    ):
        # This parameter is required.
        self.assigned_to = assigned_to
        # This parameter is required.
        self.directory_identifier = directory_identifier
        self.field_value_list = field_value_list
        self.priority = priority
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.subject = subject
        self.tags = tags
        self.testcase_step_content_info = testcase_step_content_info

    def validate(self):
        if self.field_value_list:
            for k in self.field_value_list:
                if k:
                    k.validate()
        if self.testcase_step_content_info:
            self.testcase_step_content_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.directory_identifier is not None:
            result['directoryIdentifier'] = self.directory_identifier
        result['fieldValueList'] = []
        if self.field_value_list is not None:
            for k in self.field_value_list:
                result['fieldValueList'].append(k.to_map() if k else None)
        if self.priority is not None:
            result['priority'] = self.priority
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.tags is not None:
            result['tags'] = self.tags
        if self.testcase_step_content_info is not None:
            result['testcaseStepContentInfo'] = self.testcase_step_content_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('directoryIdentifier') is not None:
            self.directory_identifier = m.get('directoryIdentifier')
        self.field_value_list = []
        if m.get('fieldValueList') is not None:
            for k in m.get('fieldValueList'):
                temp_model = CreateTestCaseRequestFieldValueList()
                self.field_value_list.append(temp_model.from_map(k))
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('testcaseStepContentInfo') is not None:
            temp_model = CreateTestCaseRequestTestcaseStepContentInfo()
            self.testcase_step_content_info = temp_model.from_map(m['testcaseStepContentInfo'])
        return self


class CreateTestCaseResponseBodyTestcaseAssignedTo(TeaModel):
    def __init__(
        self,
        assign_identifier: str = None,
        name: str = None,
        tb_role_id: str = None,
    ):
        self.assign_identifier = assign_identifier
        self.name = name
        self.tb_role_id = tb_role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assign_identifier is not None:
            result['assignIdentifier'] = self.assign_identifier
        if self.name is not None:
            result['name'] = self.name
        if self.tb_role_id is not None:
            result['tbRoleId'] = self.tb_role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignIdentifier') is not None:
            self.assign_identifier = m.get('assignIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tbRoleId') is not None:
            self.tb_role_id = m.get('tbRoleId')
        return self


class CreateTestCaseResponseBodyTestcaseCreator(TeaModel):
    def __init__(
        self,
        create_identifier: str = None,
        name: str = None,
    ):
        self.create_identifier = create_identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_identifier is not None:
            result['createIdentifier'] = self.create_identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createIdentifier') is not None:
            self.create_identifier = m.get('createIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult(TeaModel):
    def __init__(
        self,
        expect_content: str = None,
        expect_content_type: str = None,
        expect_identifier: str = None,
    ):
        self.expect_content = expect_content
        self.expect_content_type = expect_content_type
        self.expect_identifier = expect_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect_content is not None:
            result['expectContent'] = self.expect_content
        if self.expect_content_type is not None:
            result['expectContentType'] = self.expect_content_type
        if self.expect_identifier is not None:
            result['expectIdentifier'] = self.expect_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expectContent') is not None:
            self.expect_content = m.get('expectContent')
        if m.get('expectContentType') is not None:
            self.expect_content_type = m.get('expectContentType')
        if m.get('expectIdentifier') is not None:
            self.expect_identifier = m.get('expectIdentifier')
        return self


class CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition(TeaModel):
    def __init__(
        self,
        pre_content: str = None,
        pre_content_type: str = None,
        pre_identifier: str = None,
    ):
        self.pre_content = pre_content
        self.pre_content_type = pre_content_type
        self.pre_identifier = pre_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_content is not None:
            result['preContent'] = self.pre_content
        if self.pre_content_type is not None:
            result['preContentType'] = self.pre_content_type
        if self.pre_identifier is not None:
            result['preIdentifier'] = self.pre_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('preContent') is not None:
            self.pre_content = m.get('preContent')
        if m.get('preContentType') is not None:
            self.pre_content_type = m.get('preContentType')
        if m.get('preIdentifier') is not None:
            self.pre_identifier = m.get('preIdentifier')
        return self


class CreateTestCaseResponseBodyTestcaseDetailInfoStepContent(TeaModel):
    def __init__(
        self,
        step_content: str = None,
        step_content_type: str = None,
        step_identifier: str = None,
    ):
        self.step_content = step_content
        self.step_content_type = step_content_type
        self.step_identifier = step_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.step_content is not None:
            result['stepContent'] = self.step_content
        if self.step_content_type is not None:
            result['stepContentType'] = self.step_content_type
        if self.step_identifier is not None:
            result['stepIdentifier'] = self.step_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('stepContent') is not None:
            self.step_content = m.get('stepContent')
        if m.get('stepContentType') is not None:
            self.step_content_type = m.get('stepContentType')
        if m.get('stepIdentifier') is not None:
            self.step_identifier = m.get('stepIdentifier')
        return self


class CreateTestCaseResponseBodyTestcaseDetailInfo(TeaModel):
    def __init__(
        self,
        expected_result: CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult = None,
        precondition: CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition = None,
        step_content: CreateTestCaseResponseBodyTestcaseDetailInfoStepContent = None,
        step_type: str = None,
    ):
        self.expected_result = expected_result
        self.precondition = precondition
        self.step_content = step_content
        self.step_type = step_type

    def validate(self):
        if self.expected_result:
            self.expected_result.validate()
        if self.precondition:
            self.precondition.validate()
        if self.step_content:
            self.step_content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expected_result is not None:
            result['expectedResult'] = self.expected_result.to_map()
        if self.precondition is not None:
            result['precondition'] = self.precondition.to_map()
        if self.step_content is not None:
            result['stepContent'] = self.step_content.to_map()
        if self.step_type is not None:
            result['stepType'] = self.step_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expectedResult') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseDetailInfoExpectedResult()
            self.expected_result = temp_model.from_map(m['expectedResult'])
        if m.get('precondition') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseDetailInfoPrecondition()
            self.precondition = temp_model.from_map(m['precondition'])
        if m.get('stepContent') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseDetailInfoStepContent()
            self.step_content = temp_model.from_map(m['stepContent'])
        if m.get('stepType') is not None:
            self.step_type = m.get('stepType')
        return self


class CreateTestCaseResponseBodyTestcaseDirectory(TeaModel):
    def __init__(
        self,
        child_identifier: str = None,
        directory_identifier: str = None,
        name: str = None,
        path_name: List[str] = None,
    ):
        self.child_identifier = child_identifier
        self.directory_identifier = directory_identifier
        self.name = name
        self.path_name = path_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.child_identifier is not None:
            result['childIdentifier'] = self.child_identifier
        if self.directory_identifier is not None:
            result['directoryIdentifier'] = self.directory_identifier
        if self.name is not None:
            result['name'] = self.name
        if self.path_name is not None:
            result['pathName'] = self.path_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('childIdentifier') is not None:
            self.child_identifier = m.get('childIdentifier')
        if m.get('directoryIdentifier') is not None:
            self.directory_identifier = m.get('directoryIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pathName') is not None:
            self.path_name = m.get('pathName')
        return self


class CreateTestCaseResponseBodyTestcaseModifier(TeaModel):
    def __init__(
        self,
        modify_identifier: str = None,
        name: str = None,
    ):
        self.modify_identifier = modify_identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.modify_identifier is not None:
            result['modifyIdentifier'] = self.modify_identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('modifyIdentifier') is not None:
            self.modify_identifier = m.get('modifyIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class CreateTestCaseResponseBodyTestcase(TeaModel):
    def __init__(
        self,
        assigned_to: CreateTestCaseResponseBodyTestcaseAssignedTo = None,
        category_identifier: str = None,
        creator: CreateTestCaseResponseBodyTestcaseCreator = None,
        detail_info: CreateTestCaseResponseBodyTestcaseDetailInfo = None,
        directory: CreateTestCaseResponseBodyTestcaseDirectory = None,
        identifier: str = None,
        modifier: CreateTestCaseResponseBodyTestcaseModifier = None,
        space_identifier: str = None,
        space_type: str = None,
        subject: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.detail_info = detail_info
        self.directory = directory
        self.identifier = identifier
        self.modifier = modifier
        self.space_identifier = space_identifier
        self.space_type = space_type
        self.subject = subject

    def validate(self):
        if self.assigned_to:
            self.assigned_to.validate()
        if self.creator:
            self.creator.validate()
        if self.detail_info:
            self.detail_info.validate()
        if self.directory:
            self.directory.validate()
        if self.modifier:
            self.modifier.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to.to_map()
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator.to_map()
        if self.detail_info is not None:
            result['detailInfo'] = self.detail_info.to_map()
        if self.directory is not None:
            result['directory'] = self.directory.to_map()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier.to_map()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.subject is not None:
            result['subject'] = self.subject
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseAssignedTo()
            self.assigned_to = temp_model.from_map(m['assignedTo'])
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseCreator()
            self.creator = temp_model.from_map(m['creator'])
        if m.get('detailInfo') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseDetailInfo()
            self.detail_info = temp_model.from_map(m['detailInfo'])
        if m.get('directory') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseDirectory()
            self.directory = temp_model.from_map(m['directory'])
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            temp_model = CreateTestCaseResponseBodyTestcaseModifier()
            self.modifier = temp_model.from_map(m['modifier'])
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        return self


class CreateTestCaseResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        testcase: CreateTestCaseResponseBodyTestcase = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.testcase = testcase

    def validate(self):
        if self.testcase:
            self.testcase.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.testcase is not None:
            result['testcase'] = self.testcase.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('testcase') is not None:
            temp_model = CreateTestCaseResponseBodyTestcase()
            self.testcase = temp_model.from_map(m['testcase'])
        return self


class CreateTestCaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateTestCaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateTestCaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUserKeyRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        expire_time: str = None,
        key_scope: str = None,
        public_key: str = None,
        title: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.expire_time = expire_time
        # This parameter is required.
        self.key_scope = key_scope
        # This parameter is required.
        self.public_key = public_key
        # This parameter is required.
        self.title = title
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.expire_time is not None:
            result['expireTime'] = self.expire_time
        if self.key_scope is not None:
            result['keyScope'] = self.key_scope
        if self.public_key is not None:
            result['publicKey'] = self.public_key
        if self.title is not None:
            result['title'] = self.title
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('expireTime') is not None:
            self.expire_time = m.get('expireTime')
        if m.get('keyScope') is not None:
            self.key_scope = m.get('keyScope')
        if m.get('publicKey') is not None:
            self.public_key = m.get('publicKey')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class CreateUserKeyResponseBodyResult(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        expire_time: str = None,
        finger_print: str = None,
        id: int = None,
        key_scope: str = None,
        last_used_time: str = None,
        public_key: str = None,
        title: str = None,
    ):
        self.created_at = created_at
        self.expire_time = expire_time
        self.finger_print = finger_print
        self.id = id
        self.key_scope = key_scope
        self.last_used_time = last_used_time
        self.public_key = public_key
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.expire_time is not None:
            result['expireTime'] = self.expire_time
        if self.finger_print is not None:
            result['fingerPrint'] = self.finger_print
        if self.id is not None:
            result['id'] = self.id
        if self.key_scope is not None:
            result['keyScope'] = self.key_scope
        if self.last_used_time is not None:
            result['lastUsedTime'] = self.last_used_time
        if self.public_key is not None:
            result['publicKey'] = self.public_key
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('expireTime') is not None:
            self.expire_time = m.get('expireTime')
        if m.get('fingerPrint') is not None:
            self.finger_print = m.get('fingerPrint')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('keyScope') is not None:
            self.key_scope = m.get('keyScope')
        if m.get('lastUsedTime') is not None:
            self.last_used_time = m.get('lastUsedTime')
        if m.get('publicKey') is not None:
            self.public_key = m.get('publicKey')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class CreateUserKeyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: CreateUserKeyResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = CreateUserKeyResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateUserKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateUserKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUserKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVariableGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        variables: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.variables = variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.variables is not None:
            result['variables'] = self.variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('variables') is not None:
            self.variables = m.get('variables')
        return self


class CreateVariableGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        variable_group_id: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.variable_group_id = variable_group_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.variable_group_id is not None:
            result['variableGroupId'] = self.variable_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('variableGroupId') is not None:
            self.variable_group_id = m.get('variableGroupId')
        return self


class CreateVariableGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateVariableGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVariableGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkitemRequestFieldValueList(TeaModel):
    def __init__(
        self,
        field_identifier: str = None,
        value: str = None,
        workitem_identifier: str = None,
    ):
        self.field_identifier = field_identifier
        self.value = value
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.value is not None:
            result['value'] = self.value
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemRequest(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category: str = None,
        description: str = None,
        description_format: str = None,
        field_value_list: List[CreateWorkitemRequestFieldValueList] = None,
        parent: str = None,
        participant: List[str] = None,
        space: str = None,
        space_identifier: str = None,
        space_type: str = None,
        sprint: List[str] = None,
        subject: str = None,
        tracker: List[str] = None,
        verifier: List[str] = None,
        workitem_type: str = None,
    ):
        # This parameter is required.
        self.assigned_to = assigned_to
        # This parameter is required.
        self.category = category
        self.description = description
        self.description_format = description_format
        self.field_value_list = field_value_list
        self.parent = parent
        self.participant = participant
        # This parameter is required.
        self.space = space
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.space_type = space_type
        self.sprint = sprint
        # This parameter is required.
        self.subject = subject
        self.tracker = tracker
        self.verifier = verifier
        # This parameter is required.
        self.workitem_type = workitem_type

    def validate(self):
        if self.field_value_list:
            for k in self.field_value_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category is not None:
            result['category'] = self.category
        if self.description is not None:
            result['description'] = self.description
        if self.description_format is not None:
            result['descriptionFormat'] = self.description_format
        result['fieldValueList'] = []
        if self.field_value_list is not None:
            for k in self.field_value_list:
                result['fieldValueList'].append(k.to_map() if k else None)
        if self.parent is not None:
            result['parent'] = self.parent
        if self.participant is not None:
            result['participant'] = self.participant
        if self.space is not None:
            result['space'] = self.space
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.sprint is not None:
            result['sprint'] = self.sprint
        if self.subject is not None:
            result['subject'] = self.subject
        if self.tracker is not None:
            result['tracker'] = self.tracker
        if self.verifier is not None:
            result['verifier'] = self.verifier
        if self.workitem_type is not None:
            result['workitemType'] = self.workitem_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('descriptionFormat') is not None:
            self.description_format = m.get('descriptionFormat')
        self.field_value_list = []
        if m.get('fieldValueList') is not None:
            for k in m.get('fieldValueList'):
                temp_model = CreateWorkitemRequestFieldValueList()
                self.field_value_list.append(temp_model.from_map(k))
        if m.get('parent') is not None:
            self.parent = m.get('parent')
        if m.get('participant') is not None:
            self.participant = m.get('participant')
        if m.get('space') is not None:
            self.space = m.get('space')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('sprint') is not None:
            self.sprint = m.get('sprint')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('tracker') is not None:
            self.tracker = m.get('tracker')
        if m.get('verifier') is not None:
            self.verifier = m.get('verifier')
        if m.get('workitemType') is not None:
            self.workitem_type = m.get('workitemType')
        return self


class CreateWorkitemResponseBodyWorkitem(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category_identifier: str = None,
        creator: str = None,
        document: str = None,
        document_format: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        logical_status: str = None,
        modifier: str = None,
        parent_identifier: str = None,
        serial_number: str = None,
        space_identifier: str = None,
        space_name: str = None,
        space_type: str = None,
        sprint_identifier: str = None,
        status: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        subject: str = None,
        update_status_at: int = None,
        workitem_type_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.document = document
        self.document_format = document_format
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.logical_status = logical_status
        self.modifier = modifier
        self.parent_identifier = parent_identifier
        self.serial_number = serial_number
        self.space_identifier = space_identifier
        self.space_name = space_name
        self.space_type = space_type
        self.sprint_identifier = sprint_identifier
        self.status = status
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.subject = subject
        self.update_status_at = update_status_at
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.document is not None:
            result['document'] = self.document
        if self.document_format is not None:
            result['documentFormat'] = self.document_format
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_name is not None:
            result['spaceName'] = self.space_name
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.sprint_identifier is not None:
            result['sprintIdentifier'] = self.sprint_identifier
        if self.status is not None:
            result['status'] = self.status
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.update_status_at is not None:
            result['updateStatusAt'] = self.update_status_at
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('document') is not None:
            self.document = m.get('document')
        if m.get('documentFormat') is not None:
            self.document_format = m.get('documentFormat')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceName') is not None:
            self.space_name = m.get('spaceName')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('sprintIdentifier') is not None:
            self.sprint_identifier = m.get('sprintIdentifier')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('updateStatusAt') is not None:
            self.update_status_at = m.get('updateStatusAt')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class CreateWorkitemResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        workitem: CreateWorkitemResponseBodyWorkitem = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success
        self.workitem = workitem

    def validate(self):
        if self.workitem:
            self.workitem.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workitem is not None:
            result['workitem'] = self.workitem.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workitem') is not None:
            temp_model = CreateWorkitemResponseBodyWorkitem()
            self.workitem = temp_model.from_map(m['workitem'])
        return self


class CreateWorkitemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkitemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkitemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkitemCommentRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        format_type: str = None,
        parent_id: str = None,
        workitem_identifier: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.format_type = format_type
        self.parent_id = parent_id
        # This parameter is required.
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.format_type is not None:
            result['formatType'] = self.format_type
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('formatType') is not None:
            self.format_type = m.get('formatType')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemCommentResponseBodyCommentUser(TeaModel):
    def __init__(
        self,
        account: str = None,
        avatar: str = None,
        display_name: str = None,
        identifier: str = None,
        nick_name: str = None,
        real_name: str = None,
        target_type: str = None,
    ):
        self.account = account
        self.avatar = avatar
        self.display_name = display_name
        self.identifier = identifier
        self.nick_name = nick_name
        self.real_name = real_name
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['account'] = self.account
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.real_name is not None:
            result['realName'] = self.real_name
        if self.target_type is not None:
            result['targetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('realName') is not None:
            self.real_name = m.get('realName')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        return self


class CreateWorkitemCommentResponseBodyComment(TeaModel):
    def __init__(
        self,
        id: int = None,
        content: str = None,
        create_time: int = None,
        format_type: str = None,
        is_top: bool = None,
        modified_time: int = None,
        parent_id: int = None,
        target_identifier: str = None,
        target_type: str = None,
        top_time: int = None,
        user: CreateWorkitemCommentResponseBodyCommentUser = None,
    ):
        self.id = id
        self.content = content
        self.create_time = create_time
        self.format_type = format_type
        self.is_top = is_top
        self.modified_time = modified_time
        self.parent_id = parent_id
        self.target_identifier = target_identifier
        self.target_type = target_type
        self.top_time = top_time
        self.user = user

    def validate(self):
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.content is not None:
            result['content'] = self.content
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.format_type is not None:
            result['formatType'] = self.format_type
        if self.is_top is not None:
            result['isTop'] = self.is_top
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.target_identifier is not None:
            result['targetIdentifier'] = self.target_identifier
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.top_time is not None:
            result['topTime'] = self.top_time
        if self.user is not None:
            result['user'] = self.user.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('formatType') is not None:
            self.format_type = m.get('formatType')
        if m.get('isTop') is not None:
            self.is_top = m.get('isTop')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('targetIdentifier') is not None:
            self.target_identifier = m.get('targetIdentifier')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('topTime') is not None:
            self.top_time = m.get('topTime')
        if m.get('user') is not None:
            temp_model = CreateWorkitemCommentResponseBodyCommentUser()
            self.user = temp_model.from_map(m['user'])
        return self


class CreateWorkitemCommentResponseBody(TeaModel):
    def __init__(
        self,
        comment: CreateWorkitemCommentResponseBodyComment = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.comment = comment
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.comment:
            self.comment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['Comment'] = self.comment.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Comment') is not None:
            temp_model = CreateWorkitemCommentResponseBodyComment()
            self.comment = temp_model.from_map(m['Comment'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateWorkitemCommentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkitemCommentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkitemCommentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkitemEstimateRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        record_user_identifier: str = None,
        spent_time: str = None,
        type: str = None,
        workitem_identifier: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.record_user_identifier = record_user_identifier
        # This parameter is required.
        self.spent_time = spent_time
        # This parameter is required.
        self.type = type
        # This parameter is required.
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.record_user_identifier is not None:
            result['recordUserIdentifier'] = self.record_user_identifier
        if self.spent_time is not None:
            result['spentTime'] = self.spent_time
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('recordUserIdentifier') is not None:
            self.record_user_identifier = m.get('recordUserIdentifier')
        if m.get('spentTime') is not None:
            self.spent_time = m.get('spentTime')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser(TeaModel):
    def __init__(
        self,
        account: str = None,
        avatar: str = None,
        ding_talk_id: str = None,
        display_name: str = None,
        display_nick_name: str = None,
        display_real_name: str = None,
        email: str = None,
        gender: str = None,
        identifier: str = None,
        is_disabled: bool = None,
        mobile: str = None,
        name_en: str = None,
        nick_name: str = None,
        nick_name_pinyin: str = None,
        real_name: str = None,
        real_name_pinyin: str = None,
        stamp: str = None,
        tb_role_id: str = None,
    ):
        self.account = account
        self.avatar = avatar
        self.ding_talk_id = ding_talk_id
        self.display_name = display_name
        self.display_nick_name = display_nick_name
        self.display_real_name = display_real_name
        self.email = email
        self.gender = gender
        self.identifier = identifier
        self.is_disabled = is_disabled
        self.mobile = mobile
        self.name_en = name_en
        self.nick_name = nick_name
        self.nick_name_pinyin = nick_name_pinyin
        self.real_name = real_name
        self.real_name_pinyin = real_name_pinyin
        self.stamp = stamp
        self.tb_role_id = tb_role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['account'] = self.account
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.ding_talk_id is not None:
            result['dingTalkId'] = self.ding_talk_id
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.display_nick_name is not None:
            result['displayNickName'] = self.display_nick_name
        if self.display_real_name is not None:
            result['displayRealName'] = self.display_real_name
        if self.email is not None:
            result['email'] = self.email
        if self.gender is not None:
            result['gender'] = self.gender
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_disabled is not None:
            result['isDisabled'] = self.is_disabled
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.name_en is not None:
            result['nameEn'] = self.name_en
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.nick_name_pinyin is not None:
            result['nickNamePinyin'] = self.nick_name_pinyin
        if self.real_name is not None:
            result['realName'] = self.real_name
        if self.real_name_pinyin is not None:
            result['realNamePinyin'] = self.real_name_pinyin
        if self.stamp is not None:
            result['stamp'] = self.stamp
        if self.tb_role_id is not None:
            result['tbRoleId'] = self.tb_role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('dingTalkId') is not None:
            self.ding_talk_id = m.get('dingTalkId')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('displayNickName') is not None:
            self.display_nick_name = m.get('displayNickName')
        if m.get('displayRealName') is not None:
            self.display_real_name = m.get('displayRealName')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('gender') is not None:
            self.gender = m.get('gender')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDisabled') is not None:
            self.is_disabled = m.get('isDisabled')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('nameEn') is not None:
            self.name_en = m.get('nameEn')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('nickNamePinyin') is not None:
            self.nick_name_pinyin = m.get('nickNamePinyin')
        if m.get('realName') is not None:
            self.real_name = m.get('realName')
        if m.get('realNamePinyin') is not None:
            self.real_name_pinyin = m.get('realNamePinyin')
        if m.get('stamp') is not None:
            self.stamp = m.get('stamp')
        if m.get('tbRoleId') is not None:
            self.tb_role_id = m.get('tbRoleId')
        return self


class CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate(TeaModel):
    def __init__(
        self,
        description: str = None,
        identifier: str = None,
        record_user: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser = None,
        spent_time: int = None,
        type: str = None,
        workitem_identifier: str = None,
    ):
        self.description = description
        self.identifier = identifier
        self.record_user = record_user
        self.spent_time = spent_time
        self.type = type
        self.workitem_identifier = workitem_identifier

    def validate(self):
        if self.record_user:
            self.record_user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.record_user is not None:
            result['recordUser'] = self.record_user.to_map()
        if self.spent_time is not None:
            result['spentTime'] = self.spent_time
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('recordUser') is not None:
            temp_model = CreateWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser()
            self.record_user = temp_model.from_map(m['recordUser'])
        if m.get('spentTime') is not None:
            self.spent_time = m.get('spentTime')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemEstimateResponseBody(TeaModel):
    def __init__(
        self,
        workitem_time_estimate: CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.workitem_time_estimate = workitem_time_estimate
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.workitem_time_estimate:
            self.workitem_time_estimate.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workitem_time_estimate is not None:
            result['WorkitemTimeEstimate'] = self.workitem_time_estimate.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WorkitemTimeEstimate') is not None:
            temp_model = CreateWorkitemEstimateResponseBodyWorkitemTimeEstimate()
            self.workitem_time_estimate = temp_model.from_map(m['WorkitemTimeEstimate'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateWorkitemEstimateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkitemEstimateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkitemEstimateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkitemRecordRequest(TeaModel):
    def __init__(
        self,
        actual_time: str = None,
        description: str = None,
        gmt_end: str = None,
        gmt_start: str = None,
        record_user_identifier: str = None,
        type: str = None,
        workitem_identifier: str = None,
    ):
        # This parameter is required.
        self.actual_time = actual_time
        self.description = description
        # This parameter is required.
        self.gmt_end = gmt_end
        # This parameter is required.
        self.gmt_start = gmt_start
        # This parameter is required.
        self.record_user_identifier = record_user_identifier
        # This parameter is required.
        self.type = type
        # This parameter is required.
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_time is not None:
            result['actualTime'] = self.actual_time
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_end is not None:
            result['gmtEnd'] = self.gmt_end
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.record_user_identifier is not None:
            result['recordUserIdentifier'] = self.record_user_identifier
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actualTime') is not None:
            self.actual_time = m.get('actualTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtEnd') is not None:
            self.gmt_end = m.get('gmtEnd')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('recordUserIdentifier') is not None:
            self.record_user_identifier = m.get('recordUserIdentifier')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser(TeaModel):
    def __init__(
        self,
        account: str = None,
        avatar: str = None,
        ding_talk_id: str = None,
        display_name: str = None,
        display_nick_name: str = None,
        display_real_name: str = None,
        email: str = None,
        gender: str = None,
        identifier: str = None,
        is_disabled: bool = None,
        mobile: str = None,
        name_en: str = None,
        nick_name: str = None,
        nick_name_pinyin: str = None,
        real_name: str = None,
        real_name_pinyin: str = None,
        stamp: str = None,
        tb_role_id: str = None,
    ):
        self.account = account
        self.avatar = avatar
        self.ding_talk_id = ding_talk_id
        self.display_name = display_name
        self.display_nick_name = display_nick_name
        self.display_real_name = display_real_name
        self.email = email
        self.gender = gender
        self.identifier = identifier
        self.is_disabled = is_disabled
        self.mobile = mobile
        self.name_en = name_en
        self.nick_name = nick_name
        self.nick_name_pinyin = nick_name_pinyin
        self.real_name = real_name
        self.real_name_pinyin = real_name_pinyin
        self.stamp = stamp
        self.tb_role_id = tb_role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['account'] = self.account
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.ding_talk_id is not None:
            result['dingTalkId'] = self.ding_talk_id
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.display_nick_name is not None:
            result['displayNickName'] = self.display_nick_name
        if self.display_real_name is not None:
            result['displayRealName'] = self.display_real_name
        if self.email is not None:
            result['email'] = self.email
        if self.gender is not None:
            result['gender'] = self.gender
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_disabled is not None:
            result['isDisabled'] = self.is_disabled
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.name_en is not None:
            result['nameEn'] = self.name_en
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.nick_name_pinyin is not None:
            result['nickNamePinyin'] = self.nick_name_pinyin
        if self.real_name is not None:
            result['realName'] = self.real_name
        if self.real_name_pinyin is not None:
            result['realNamePinyin'] = self.real_name_pinyin
        if self.stamp is not None:
            result['stamp'] = self.stamp
        if self.tb_role_id is not None:
            result['tbRoleId'] = self.tb_role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('dingTalkId') is not None:
            self.ding_talk_id = m.get('dingTalkId')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('displayNickName') is not None:
            self.display_nick_name = m.get('displayNickName')
        if m.get('displayRealName') is not None:
            self.display_real_name = m.get('displayRealName')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('gender') is not None:
            self.gender = m.get('gender')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDisabled') is not None:
            self.is_disabled = m.get('isDisabled')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('nameEn') is not None:
            self.name_en = m.get('nameEn')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('nickNamePinyin') is not None:
            self.nick_name_pinyin = m.get('nickNamePinyin')
        if m.get('realName') is not None:
            self.real_name = m.get('realName')
        if m.get('realNamePinyin') is not None:
            self.real_name_pinyin = m.get('realNamePinyin')
        if m.get('stamp') is not None:
            self.stamp = m.get('stamp')
        if m.get('tbRoleId') is not None:
            self.tb_role_id = m.get('tbRoleId')
        return self


class CreateWorkitemRecordResponseBodyWorkitemTime(TeaModel):
    def __init__(
        self,
        actual_time: int = None,
        description: str = None,
        gmt_end: int = None,
        gmt_start: int = None,
        identifier: str = None,
        record_user: CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser = None,
        type: str = None,
        workitem_identifier: str = None,
    ):
        self.actual_time = actual_time
        self.description = description
        self.gmt_end = gmt_end
        self.gmt_start = gmt_start
        self.identifier = identifier
        self.record_user = record_user
        self.type = type
        self.workitem_identifier = workitem_identifier

    def validate(self):
        if self.record_user:
            self.record_user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_time is not None:
            result['actualTime'] = self.actual_time
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_end is not None:
            result['gmtEnd'] = self.gmt_end
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.record_user is not None:
            result['recordUser'] = self.record_user.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actualTime') is not None:
            self.actual_time = m.get('actualTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtEnd') is not None:
            self.gmt_end = m.get('gmtEnd')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('recordUser') is not None:
            temp_model = CreateWorkitemRecordResponseBodyWorkitemTimeRecordUser()
            self.record_user = temp_model.from_map(m['recordUser'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemRecordResponseBody(TeaModel):
    def __init__(
        self,
        workitem_time: CreateWorkitemRecordResponseBodyWorkitemTime = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.workitem_time = workitem_time
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.workitem_time:
            self.workitem_time.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workitem_time is not None:
            result['WorkitemTime'] = self.workitem_time.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('WorkitemTime') is not None:
            temp_model = CreateWorkitemRecordResponseBodyWorkitemTime()
            self.workitem_time = temp_model.from_map(m['WorkitemTime'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateWorkitemRecordResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkitemRecordResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkitemRecordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateWorkitemV2RequestFieldValueList(TeaModel):
    def __init__(
        self,
        field_identifier: str = None,
        value: str = None,
    ):
        self.field_identifier = field_identifier
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CreateWorkitemV2Request(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category: str = None,
        description: str = None,
        field_value_list: List[CreateWorkitemV2RequestFieldValueList] = None,
        parent_identifier: str = None,
        participants: List[str] = None,
        space_identifier: str = None,
        sprint_identifier: str = None,
        subject: str = None,
        tags: List[str] = None,
        trackers: List[str] = None,
        verifier: str = None,
        versions: List[str] = None,
        workitem_type_identifier: str = None,
    ):
        # This parameter is required.
        self.assigned_to = assigned_to
        # This parameter is required.
        self.category = category
        self.description = description
        self.field_value_list = field_value_list
        self.parent_identifier = parent_identifier
        self.participants = participants
        # This parameter is required.
        self.space_identifier = space_identifier
        self.sprint_identifier = sprint_identifier
        # This parameter is required.
        self.subject = subject
        self.tags = tags
        self.trackers = trackers
        self.verifier = verifier
        self.versions = versions
        # This parameter is required.
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        if self.field_value_list:
            for k in self.field_value_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category is not None:
            result['category'] = self.category
        if self.description is not None:
            result['description'] = self.description
        result['fieldValueList'] = []
        if self.field_value_list is not None:
            for k in self.field_value_list:
                result['fieldValueList'].append(k.to_map() if k else None)
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.participants is not None:
            result['participants'] = self.participants
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.sprint_identifier is not None:
            result['sprintIdentifier'] = self.sprint_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.tags is not None:
            result['tags'] = self.tags
        if self.trackers is not None:
            result['trackers'] = self.trackers
        if self.verifier is not None:
            result['verifier'] = self.verifier
        if self.versions is not None:
            result['versions'] = self.versions
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('description') is not None:
            self.description = m.get('description')
        self.field_value_list = []
        if m.get('fieldValueList') is not None:
            for k in m.get('fieldValueList'):
                temp_model = CreateWorkitemV2RequestFieldValueList()
                self.field_value_list.append(temp_model.from_map(k))
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('participants') is not None:
            self.participants = m.get('participants')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('sprintIdentifier') is not None:
            self.sprint_identifier = m.get('sprintIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('tags') is not None:
            self.tags = m.get('tags')
        if m.get('trackers') is not None:
            self.trackers = m.get('trackers')
        if m.get('verifier') is not None:
            self.verifier = m.get('verifier')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class CreateWorkitemV2ResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: str = None,
        workitem_identifier: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class CreateWorkitemV2Response(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: CreateWorkitemV2ResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateWorkitemV2ResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAppMemberRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
        subject_id: str = None,
        subject_type: str = None,
    ):
        self.organization_id = organization_id
        self.subject_id = subject_id
        self.subject_type = subject_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.subject_id is not None:
            result['subjectId'] = self.subject_id
        if self.subject_type is not None:
            result['subjectType'] = self.subject_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('subjectId') is not None:
            self.subject_id = m.get('subjectId')
        if m.get('subjectType') is not None:
            self.subject_type = m.get('subjectType')
        return self


class DeleteAppMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: str = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            self.body = m.get('body')
        return self


class DeleteBranchRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        branch_name: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.branch_name = branch_name
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteBranchResponseBodyResult(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
    ):
        self.branch_name = branch_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        return self


class DeleteBranchResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteBranchResponseBodyResult = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteBranchResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteBranchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteBranchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBranchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFileRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        branch_name: str = None,
        commit_message: str = None,
        file_path: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.branch_name = branch_name
        # This parameter is required.
        self.commit_message = commit_message
        # This parameter is required.
        self.file_path = file_path
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.commit_message is not None:
            result['commitMessage'] = self.commit_message
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('commitMessage') is not None:
            self.commit_message = m.get('commitMessage')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteFileResponseBodyResult(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
        file_path: str = None,
    ):
        self.branch_name = branch_name
        self.file_path = file_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.file_path is not None:
            result['filePath'] = self.file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        return self


class DeleteFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteFileResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteFileResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFlowTagResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteFlowTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFlowTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFlowTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteFlowTagGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteFlowTagGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteFlowTagGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteFlowTagGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGroupMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        aliyun_pk: str = None,
        member_type: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.aliyun_pk = aliyun_pk
        # This parameter is required.
        self.member_type = member_type
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteGroupMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        id: int = None,
        member_type: str = None,
        name: str = None,
        source_id: int = None,
        state: str = None,
        username: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.id = id
        self.member_type = member_type
        self.name = name
        self.source_id = source_id
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.id is not None:
            result['id'] = self.id
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.name is not None:
            result['name'] = self.name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class DeleteGroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteGroupMemberResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteGroupMemberResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteGroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteGroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHostGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteHostGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteHostGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHostGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeletePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeletePipelineGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePipelineGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineRelationsRequest(TeaModel):
    def __init__(
        self,
        rel_object_id: str = None,
        rel_object_type: str = None,
    ):
        # This parameter is required.
        self.rel_object_id = rel_object_id
        # This parameter is required.
        self.rel_object_type = rel_object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rel_object_id is not None:
            result['relObjectId'] = self.rel_object_id
        if self.rel_object_type is not None:
            result['relObjectType'] = self.rel_object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('relObjectId') is not None:
            self.rel_object_id = m.get('relObjectId')
        if m.get('relObjectType') is not None:
            self.rel_object_type = m.get('relObjectType')
        return self


class DeletePipelineRelationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeletePipelineRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePipelineRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectRequest(TeaModel):
    def __init__(
        self,
        identifier: str = None,
    ):
        # This parameter is required.
        self.identifier = identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        return self


class DeleteProjectResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        result: bool = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteProjectResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProjectResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProjectLabelRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class DeleteProjectLabelResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteProjectLabelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteProjectLabelResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteProjectLabelResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteProjectLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProjectLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProjectLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteProtectedBranchRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteProtectedBranchResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteProtectedBranchResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteProtectedBranchResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteProtectedBranchResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteProtectedBranchResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteProtectedBranchResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteProtectedBranchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePushRuleRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeletePushRuleResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeletePushRuleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeletePushRuleResponseBodyResult = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeletePushRuleResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeletePushRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeletePushRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePushRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRepositoryRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        reason: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.reason = reason
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.reason is not None:
            result['reason'] = self.reason
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteRepositoryResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteRepositoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteRepositoryResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteRepositoryResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteRepositoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRepositoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRepositoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRepositoryGroupRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        reason: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.reason = reason
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.reason is not None:
            result['reason'] = self.reason
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteRepositoryGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteRepositoryGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteRepositoryGroupResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteRepositoryGroupResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteRepositoryGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRepositoryGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRepositoryGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRepositoryMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        member_type: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.member_type = member_type
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteRepositoryMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        create_at: str = None,
        id: int = None,
        source_id: int = None,
        source_type: str = None,
        update_at: str = None,
        user_id: int = None,
    ):
        self.access_level = access_level
        self.create_at = create_at
        self.id = id
        self.source_id = source_id
        self.source_type = source_type
        self.update_at = update_at
        self.user_id = user_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.create_at is not None:
            result['createAt'] = self.create_at
        if self.id is not None:
            result['id'] = self.id
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.update_at is not None:
            result['updateAt'] = self.update_at
        if self.user_id is not None:
            result['userId'] = self.user_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('createAt') is not None:
            self.create_at = m.get('createAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('updateAt') is not None:
            self.update_at = m.get('updateAt')
        if m.get('userId') is not None:
            self.user_id = m.get('userId')
        return self


class DeleteRepositoryMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteRepositoryMemberResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteRepositoryMemberResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteRepositoryMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRepositoryMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRepositoryMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRepositoryWebhookRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteRepositoryWebhookResponseBodyResult(TeaModel):
    def __init__(
        self,
        build_events: bool = None,
        created_at: str = None,
        description: str = None,
        enable_ssl_verification: bool = None,
        id: int = None,
        issues_events: bool = None,
        last_test_result: str = None,
        merge_requests_events: bool = None,
        note_events: bool = None,
        project_id: int = None,
        push_events: bool = None,
        secret_token: str = None,
        tag_push_events: bool = None,
        type: str = None,
        url: str = None,
    ):
        self.build_events = build_events
        self.created_at = created_at
        self.description = description
        self.enable_ssl_verification = enable_ssl_verification
        self.id = id
        self.issues_events = issues_events
        self.last_test_result = last_test_result
        self.merge_requests_events = merge_requests_events
        self.note_events = note_events
        self.project_id = project_id
        self.push_events = push_events
        self.secret_token = secret_token
        self.tag_push_events = tag_push_events
        self.type = type
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.build_events is not None:
            result['buildEvents'] = self.build_events
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.enable_ssl_verification is not None:
            result['enableSslVerification'] = self.enable_ssl_verification
        if self.id is not None:
            result['id'] = self.id
        if self.issues_events is not None:
            result['issuesEvents'] = self.issues_events
        if self.last_test_result is not None:
            result['lastTestResult'] = self.last_test_result
        if self.merge_requests_events is not None:
            result['mergeRequestsEvents'] = self.merge_requests_events
        if self.note_events is not None:
            result['noteEvents'] = self.note_events
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.push_events is not None:
            result['pushEvents'] = self.push_events
        if self.secret_token is not None:
            result['secretToken'] = self.secret_token
        if self.tag_push_events is not None:
            result['tagPushEvents'] = self.tag_push_events
        if self.type is not None:
            result['type'] = self.type
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('buildEvents') is not None:
            self.build_events = m.get('buildEvents')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enableSslVerification') is not None:
            self.enable_ssl_verification = m.get('enableSslVerification')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('issuesEvents') is not None:
            self.issues_events = m.get('issuesEvents')
        if m.get('lastTestResult') is not None:
            self.last_test_result = m.get('lastTestResult')
        if m.get('mergeRequestsEvents') is not None:
            self.merge_requests_events = m.get('mergeRequestsEvents')
        if m.get('noteEvents') is not None:
            self.note_events = m.get('noteEvents')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('pushEvents') is not None:
            self.push_events = m.get('pushEvents')
        if m.get('secretToken') is not None:
            self.secret_token = m.get('secretToken')
        if m.get('tagPushEvents') is not None:
            self.tag_push_events = m.get('tagPushEvents')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class DeleteRepositoryWebhookResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteRepositoryWebhookResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteRepositoryWebhookResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteRepositoryWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteRepositoryWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRepositoryWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteResourceMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteResourceMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteResourceMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteResourceMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTagRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        tag_name: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.tag_name = tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.tag_name is not None:
            result['tagName'] = self.tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('tagName') is not None:
            self.tag_name = m.get('tagName')
        return self


class DeleteTagResponseBodyResult(TeaModel):
    def __init__(
        self,
        tag_name: str = None,
    ):
        self.tag_name = tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['tagName'] = self.tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tagName') is not None:
            self.tag_name = m.get('tagName')
        return self


class DeleteTagResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteTagResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteTagResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteUserKeyRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class DeleteUserKeyResponseBodyResult(TeaModel):
    def __init__(
        self,
        context: str = None,
        created_at: str = None,
        expire_time: str = None,
        finger_print: str = None,
        id: int = None,
        key_scope: str = None,
        last_used_time: str = None,
        public_key: str = None,
        sha_context: str = None,
        title: str = None,
        updated_at: str = None,
    ):
        self.context = context
        self.created_at = created_at
        self.expire_time = expire_time
        self.finger_print = finger_print
        self.id = id
        self.key_scope = key_scope
        self.last_used_time = last_used_time
        self.public_key = public_key
        self.sha_context = sha_context
        self.title = title
        self.updated_at = updated_at

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['context'] = self.context
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.expire_time is not None:
            result['expireTime'] = self.expire_time
        if self.finger_print is not None:
            result['fingerPrint'] = self.finger_print
        if self.id is not None:
            result['id'] = self.id
        if self.key_scope is not None:
            result['keyScope'] = self.key_scope
        if self.last_used_time is not None:
            result['lastUsedTime'] = self.last_used_time
        if self.public_key is not None:
            result['publicKey'] = self.public_key
        if self.sha_context is not None:
            result['shaContext'] = self.sha_context
        if self.title is not None:
            result['title'] = self.title
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('expireTime') is not None:
            self.expire_time = m.get('expireTime')
        if m.get('fingerPrint') is not None:
            self.finger_print = m.get('fingerPrint')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('keyScope') is not None:
            self.key_scope = m.get('keyScope')
        if m.get('lastUsedTime') is not None:
            self.last_used_time = m.get('lastUsedTime')
        if m.get('publicKey') is not None:
            self.public_key = m.get('publicKey')
        if m.get('shaContext') is not None:
            self.sha_context = m.get('shaContext')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        return self


class DeleteUserKeyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: DeleteUserKeyResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = DeleteUserKeyResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteUserKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteUserKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteUserKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVariableGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteVariableGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteVariableGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVariableGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkitemRequest(TeaModel):
    def __init__(
        self,
        identifier: str = None,
    ):
        # This parameter is required.
        self.identifier = identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        return self


class DeleteWorkitemResponseBody(TeaModel):
    def __init__(
        self,
        delete_flag: bool = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.delete_flag = delete_flag
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        # true/false
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_flag is not None:
            result['deleteFlag'] = self.delete_flag
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deleteFlag') is not None:
            self.delete_flag = m.get('deleteFlag')
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteWorkitemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkitemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkitemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkitemAllCommentRequest(TeaModel):
    def __init__(
        self,
        identifier: str = None,
    ):
        # This parameter is required.
        self.identifier = identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        return self


class DeleteWorkitemAllCommentResponseBody(TeaModel):
    def __init__(
        self,
        delete_flag: bool = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.delete_flag = delete_flag
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_flag is not None:
            result['deleteFlag'] = self.delete_flag
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deleteFlag') is not None:
            self.delete_flag = m.get('deleteFlag')
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteWorkitemAllCommentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkitemAllCommentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkitemAllCommentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteWorkitemCommentRequest(TeaModel):
    def __init__(
        self,
        comment_id: int = None,
        identifier: str = None,
    ):
        # This parameter is required.
        self.comment_id = comment_id
        # This parameter is required.
        self.identifier = identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment_id is not None:
            result['commentId'] = self.comment_id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commentId') is not None:
            self.comment_id = m.get('commentId')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        return self


class DeleteWorkitemCommentResponseBody(TeaModel):
    def __init__(
        self,
        delete_flag: bool = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.delete_flag = delete_flag
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_flag is not None:
            result['deleteFlag'] = self.delete_flag
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deleteFlag') is not None:
            self.delete_flag = m.get('deleteFlag')
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteWorkitemCommentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: DeleteWorkitemCommentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteWorkitemCommentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableDeployKeyRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class EnableDeployKeyResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class EnableDeployKeyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: EnableDeployKeyResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = EnableDeployKeyResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class EnableDeployKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: EnableDeployKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableDeployKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExecuteChangeRequestReleaseStageRequest(TeaModel):
    def __init__(
        self,
        params: Dict[str, Any] = None,
        organization_id: str = None,
    ):
        self.params = params
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.params is not None:
            result['params'] = self.params
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ExecuteChangeRequestReleaseStageResponseBody(TeaModel):
    def __init__(
        self,
        object: int = None,
        pipeline_id: int = None,
        pipeline_run_id: int = None,
    ):
        self.object = object
        self.pipeline_id = pipeline_id
        self.pipeline_run_id = pipeline_run_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.object is not None:
            result['object'] = self.object
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_run_id is not None:
            result['pipelineRunId'] = self.pipeline_run_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('object') is not None:
            self.object = m.get('object')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineRunId') is not None:
            self.pipeline_run_id = m.get('pipelineRunId')
        return self


class ExecuteChangeRequestReleaseStageResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExecuteChangeRequestReleaseStageResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExecuteChangeRequestReleaseStageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightCustomValueRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightCustomValueResponseBodyResult(TeaModel):
    def __init__(
        self,
        double_value: float = None,
        field_id: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        long_value: int = None,
        organization_id: str = None,
        target_id: str = None,
        target_type: str = None,
        type: str = None,
        value: str = None,
    ):
        self.double_value = double_value
        self.field_id = field_id
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.long_value = long_value
        self.organization_id = organization_id
        self.target_id = target_id
        self.target_type = target_type
        self.type = type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.double_value is not None:
            result['doubleValue'] = self.double_value
        if self.field_id is not None:
            result['fieldId'] = self.field_id
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.long_value is not None:
            result['longValue'] = self.long_value
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.target_id is not None:
            result['targetId'] = self.target_id
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('doubleValue') is not None:
            self.double_value = m.get('doubleValue')
        if m.get('fieldId') is not None:
            self.field_id = m.get('fieldId')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('longValue') is not None:
            self.long_value = m.get('longValue')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('targetId') is not None:
            self.target_id = m.get('targetId')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ExportInsightCustomValueResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightCustomValueResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightCustomValueResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightCustomValueResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightCustomValueResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightCustomValueResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightExpectedWorkTimeRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightExpectedWorkTimeResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        organization_id: str = None,
        project_id: str = None,
        recorder_id: str = None,
        source: str = None,
        type: str = None,
        value: float = None,
        workitem_id: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.organization_id = organization_id
        self.project_id = project_id
        self.recorder_id = recorder_id
        self.source = source
        self.type = type
        self.value = value
        self.workitem_id = workitem_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.recorder_id is not None:
            result['recorderId'] = self.recorder_id
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        if self.workitem_id is not None:
            result['workitemId'] = self.workitem_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('recorderId') is not None:
            self.recorder_id = m.get('recorderId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('workitemId') is not None:
            self.workitem_id = m.get('workitemId')
        return self


class ExportInsightExpectedWorkTimeResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightExpectedWorkTimeResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightExpectedWorkTimeResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightExpectedWorkTimeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightExpectedWorkTimeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightExpectedWorkTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightFieldRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightFieldResponseBodyResult(TeaModel):
    def __init__(
        self,
        field_id: str = None,
        field_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        is_system: str = None,
        option_value: str = None,
        organization_id: str = None,
        position: int = None,
        scope: str = None,
        source: str = None,
        target_id: str = None,
        target_type: str = None,
        type: str = None,
    ):
        self.field_id = field_id
        self.field_name = field_name
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.is_system = is_system
        self.option_value = option_value
        self.organization_id = organization_id
        self.position = position
        self.scope = scope
        self.source = source
        self.target_id = target_id
        self.target_type = target_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_id is not None:
            result['fieldId'] = self.field_id
        if self.field_name is not None:
            result['fieldName'] = self.field_name
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.is_system is not None:
            result['isSystem'] = self.is_system
        if self.option_value is not None:
            result['optionValue'] = self.option_value
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.position is not None:
            result['position'] = self.position
        if self.scope is not None:
            result['scope'] = self.scope
        if self.source is not None:
            result['source'] = self.source
        if self.target_id is not None:
            result['targetId'] = self.target_id
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldId') is not None:
            self.field_id = m.get('fieldId')
        if m.get('fieldName') is not None:
            self.field_name = m.get('fieldName')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('isSystem') is not None:
            self.is_system = m.get('isSystem')
        if m.get('optionValue') is not None:
            self.option_value = m.get('optionValue')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('position') is not None:
            self.position = m.get('position')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('targetId') is not None:
            self.target_id = m.get('targetId')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ExportInsightFieldResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightFieldResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightFieldResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightSpaceRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightSpaceResponseBodyResult(TeaModel):
    def __init__(
        self,
        category: str = None,
        custom_code: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        name: str = None,
        organization_id: str = None,
        source: str = None,
        stage: str = None,
        status: str = None,
        type: str = None,
    ):
        self.category = category
        self.custom_code = custom_code
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.name = name
        self.organization_id = organization_id
        self.source = source
        self.stage = stage
        self.status = status
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.custom_code is not None:
            result['customCode'] = self.custom_code
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.name is not None:
            result['name'] = self.name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.source is not None:
            result['source'] = self.source
        if self.stage is not None:
            result['stage'] = self.stage
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('customCode') is not None:
            self.custom_code = m.get('customCode')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('stage') is not None:
            self.stage = m.get('stage')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ExportInsightSpaceResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightSpaceResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightSpaceResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightSpaceResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightSpaceResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightSpaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightSpaceRefRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightSpaceRefResponseBodyResult(TeaModel):
    def __init__(
        self,
        creator_id: str = None,
        from_id: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        modifier_id: str = None,
        organization_id: str = None,
        to_id: str = None,
        type: str = None,
    ):
        self.creator_id = creator_id
        self.from_id = from_id
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.modifier_id = modifier_id
        self.organization_id = organization_id
        self.to_id = to_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.from_id is not None:
            result['fromId'] = self.from_id
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.modifier_id is not None:
            result['modifierId'] = self.modifier_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.to_id is not None:
            result['toId'] = self.to_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('fromId') is not None:
            self.from_id = m.get('fromId')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('modifierId') is not None:
            self.modifier_id = m.get('modifierId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('toId') is not None:
            self.to_id = m.get('toId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ExportInsightSpaceRefResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightSpaceRefResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightSpaceRefResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightSpaceRefResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightSpaceRefResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightSpaceRefResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightSprintRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightSprintResponseBodyResult(TeaModel):
    def __init__(
        self,
        actual_end: int = None,
        actual_start: int = None,
        gmt_create: int = None,
        gmt_end: int = None,
        gmt_modified: int = None,
        gmt_start: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        name: str = None,
        organization_id: str = None,
        project_id: str = None,
        source: str = None,
        status: int = None,
        work_time_capacity: float = None,
    ):
        self.actual_end = actual_end
        self.actual_start = actual_start
        self.gmt_create = gmt_create
        self.gmt_end = gmt_end
        self.gmt_modified = gmt_modified
        self.gmt_start = gmt_start
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.name = name
        self.organization_id = organization_id
        self.project_id = project_id
        self.source = source
        self.status = status
        self.work_time_capacity = work_time_capacity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_end is not None:
            result['actualEnd'] = self.actual_end
        if self.actual_start is not None:
            result['actualStart'] = self.actual_start
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_end is not None:
            result['gmtEnd'] = self.gmt_end
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.name is not None:
            result['name'] = self.name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        if self.work_time_capacity is not None:
            result['workTimeCapacity'] = self.work_time_capacity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actualEnd') is not None:
            self.actual_end = m.get('actualEnd')
        if m.get('actualStart') is not None:
            self.actual_start = m.get('actualStart')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtEnd') is not None:
            self.gmt_end = m.get('gmtEnd')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workTimeCapacity') is not None:
            self.work_time_capacity = m.get('workTimeCapacity')
        return self


class ExportInsightSprintResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightSprintResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightSprintResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightSprintResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightSprintResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightSprintResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightTagRefRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightTagRefResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        name: str = None,
        organization_id: str = None,
        tag_id: str = None,
        target_id: str = None,
        target_type: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.name = name
        self.organization_id = organization_id
        self.tag_id = tag_id
        self.target_id = target_id
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.name is not None:
            result['name'] = self.name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.tag_id is not None:
            result['tagId'] = self.tag_id
        if self.target_id is not None:
            result['targetId'] = self.target_id
        if self.target_type is not None:
            result['targetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('tagId') is not None:
            self.tag_id = m.get('tagId')
        if m.get('targetId') is not None:
            self.target_id = m.get('targetId')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        return self


class ExportInsightTagRefResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightTagRefResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightTagRefResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightTagRefResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightTagRefResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightTagRefResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightWorkTimeRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightWorkTimeResponseBodyResult(TeaModel):
    def __init__(
        self,
        actual_value: float = None,
        description: str = None,
        gmt_create: int = None,
        gmt_end: int = None,
        gmt_modified: int = None,
        gmt_start: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        organization_id: str = None,
        project_id: str = None,
        recorder_id: str = None,
        source: str = None,
        type: str = None,
        uuid: str = None,
        value: int = None,
        workitem_id: str = None,
    ):
        self.actual_value = actual_value
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_end = gmt_end
        self.gmt_modified = gmt_modified
        self.gmt_start = gmt_start
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.organization_id = organization_id
        self.project_id = project_id
        self.recorder_id = recorder_id
        self.source = source
        self.type = type
        self.uuid = uuid
        self.value = value
        self.workitem_id = workitem_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_value is not None:
            result['actualValue'] = self.actual_value
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_end is not None:
            result['gmtEnd'] = self.gmt_end
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.recorder_id is not None:
            result['recorderId'] = self.recorder_id
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.value is not None:
            result['value'] = self.value
        if self.workitem_id is not None:
            result['workitemId'] = self.workitem_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actualValue') is not None:
            self.actual_value = m.get('actualValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtEnd') is not None:
            self.gmt_end = m.get('gmtEnd')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('recorderId') is not None:
            self.recorder_id = m.get('recorderId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('workitemId') is not None:
            self.workitem_id = m.get('workitemId')
        return self


class ExportInsightWorkTimeResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightWorkTimeResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightWorkTimeResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightWorkTimeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightWorkTimeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightWorkTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightWorkitemStatusRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightWorkitemStatusResponseBodyResult(TeaModel):
    def __init__(
        self,
        assigned_to_id: str = None,
        creator_id: str = None,
        expected_work_time: int = None,
        gmt_closed: int = None,
        gmt_create: int = None,
        gmt_due: int = None,
        gmt_modified: int = None,
        gmt_start: int = None,
        gmt_todo: int = None,
        id: int = None,
        is_archived: str = None,
        is_deleted: str = None,
        is_done: str = None,
        organization_id: str = None,
        parent_id: str = None,
        participant_ids: str = None,
        phase: int = None,
        priority: int = None,
        product_id: str = None,
        project_id: str = None,
        serial_number: int = None,
        source: str = None,
        sprint_id: str = None,
        stage: int = None,
        status: str = None,
        status_id: str = None,
        story_point: float = None,
        sub_type: str = None,
        subject: str = None,
        type: int = None,
        version_id: str = None,
        versions: str = None,
        work_time: int = None,
        workitem_id: str = None,
    ):
        self.assigned_to_id = assigned_to_id
        self.creator_id = creator_id
        self.expected_work_time = expected_work_time
        self.gmt_closed = gmt_closed
        self.gmt_create = gmt_create
        self.gmt_due = gmt_due
        self.gmt_modified = gmt_modified
        self.gmt_start = gmt_start
        self.gmt_todo = gmt_todo
        self.id = id
        self.is_archived = is_archived
        self.is_deleted = is_deleted
        self.is_done = is_done
        self.organization_id = organization_id
        self.parent_id = parent_id
        self.participant_ids = participant_ids
        self.phase = phase
        self.priority = priority
        self.product_id = product_id
        self.project_id = project_id
        self.serial_number = serial_number
        self.source = source
        self.sprint_id = sprint_id
        self.stage = stage
        self.status = status
        self.status_id = status_id
        self.story_point = story_point
        self.sub_type = sub_type
        self.subject = subject
        self.type = type
        self.version_id = version_id
        self.versions = versions
        self.work_time = work_time
        self.workitem_id = workitem_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to_id is not None:
            result['assignedToId'] = self.assigned_to_id
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.expected_work_time is not None:
            result['expectedWorkTime'] = self.expected_work_time
        if self.gmt_closed is not None:
            result['gmtClosed'] = self.gmt_closed
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_due is not None:
            result['gmtDue'] = self.gmt_due
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.gmt_todo is not None:
            result['gmtTodo'] = self.gmt_todo
        if self.id is not None:
            result['id'] = self.id
        if self.is_archived is not None:
            result['isArchived'] = self.is_archived
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.is_done is not None:
            result['isDone'] = self.is_done
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.participant_ids is not None:
            result['participantIds'] = self.participant_ids
        if self.phase is not None:
            result['phase'] = self.phase
        if self.priority is not None:
            result['priority'] = self.priority
        if self.product_id is not None:
            result['productId'] = self.product_id
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.source is not None:
            result['source'] = self.source
        if self.sprint_id is not None:
            result['sprintId'] = self.sprint_id
        if self.stage is not None:
            result['stage'] = self.stage
        if self.status is not None:
            result['status'] = self.status
        if self.status_id is not None:
            result['statusId'] = self.status_id
        if self.story_point is not None:
            result['storyPoint'] = self.story_point
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.subject is not None:
            result['subject'] = self.subject
        if self.type is not None:
            result['type'] = self.type
        if self.version_id is not None:
            result['versionId'] = self.version_id
        if self.versions is not None:
            result['versions'] = self.versions
        if self.work_time is not None:
            result['workTime'] = self.work_time
        if self.workitem_id is not None:
            result['workitemId'] = self.workitem_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedToId') is not None:
            self.assigned_to_id = m.get('assignedToId')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('expectedWorkTime') is not None:
            self.expected_work_time = m.get('expectedWorkTime')
        if m.get('gmtClosed') is not None:
            self.gmt_closed = m.get('gmtClosed')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtDue') is not None:
            self.gmt_due = m.get('gmtDue')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('gmtTodo') is not None:
            self.gmt_todo = m.get('gmtTodo')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isArchived') is not None:
            self.is_archived = m.get('isArchived')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('isDone') is not None:
            self.is_done = m.get('isDone')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('participantIds') is not None:
            self.participant_ids = m.get('participantIds')
        if m.get('phase') is not None:
            self.phase = m.get('phase')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('productId') is not None:
            self.product_id = m.get('productId')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sprintId') is not None:
            self.sprint_id = m.get('sprintId')
        if m.get('stage') is not None:
            self.stage = m.get('stage')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusId') is not None:
            self.status_id = m.get('statusId')
        if m.get('storyPoint') is not None:
            self.story_point = m.get('storyPoint')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('versionId') is not None:
            self.version_id = m.get('versionId')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        if m.get('workTime') is not None:
            self.work_time = m.get('workTime')
        if m.get('workitemId') is not None:
            self.workitem_id = m.get('workitemId')
        return self


class ExportInsightWorkitemStatusResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightWorkitemStatusResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightWorkitemStatusResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightWorkitemStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightWorkitemStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightWorkitemStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightWorkitemStatusJoinWorkitemDefectExtraRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult(TeaModel):
    def __init__(
        self,
        assigned_to_id: str = None,
        creator_id: str = None,
        expected_work_time: int = None,
        extra_id: int = None,
        extra_is_deleted: str = None,
        found_phase: int = None,
        gmt_closed: int = None,
        gmt_create: int = None,
        gmt_due: int = None,
        gmt_fixed: str = None,
        gmt_modified: int = None,
        gmt_start: int = None,
        gmt_todo: int = None,
        id: int = None,
        is_archived: str = None,
        is_deleted: str = None,
        is_done: str = None,
        is_stupid: str = None,
        organization_id: str = None,
        parent_id: str = None,
        participant_ids: str = None,
        phase: int = None,
        priority: int = None,
        product_id: str = None,
        project_id: str = None,
        reopen_num: int = None,
        serial_number: int = None,
        serious_level: int = None,
        solution: str = None,
        source: str = None,
        sprint_id: str = None,
        stage: int = None,
        status: str = None,
        status_id: str = None,
        story_point: float = None,
        sub_type: str = None,
        subject: str = None,
        type: int = None,
        verifier_id: str = None,
        version_id: str = None,
        versions: str = None,
        work_time: int = None,
        workitem_id: str = None,
    ):
        self.assigned_to_id = assigned_to_id
        self.creator_id = creator_id
        self.expected_work_time = expected_work_time
        self.extra_id = extra_id
        self.extra_is_deleted = extra_is_deleted
        self.found_phase = found_phase
        self.gmt_closed = gmt_closed
        self.gmt_create = gmt_create
        self.gmt_due = gmt_due
        self.gmt_fixed = gmt_fixed
        self.gmt_modified = gmt_modified
        self.gmt_start = gmt_start
        self.gmt_todo = gmt_todo
        self.id = id
        self.is_archived = is_archived
        self.is_deleted = is_deleted
        self.is_done = is_done
        self.is_stupid = is_stupid
        self.organization_id = organization_id
        self.parent_id = parent_id
        self.participant_ids = participant_ids
        self.phase = phase
        self.priority = priority
        self.product_id = product_id
        self.project_id = project_id
        self.reopen_num = reopen_num
        self.serial_number = serial_number
        self.serious_level = serious_level
        self.solution = solution
        self.source = source
        self.sprint_id = sprint_id
        self.stage = stage
        self.status = status
        self.status_id = status_id
        self.story_point = story_point
        self.sub_type = sub_type
        self.subject = subject
        self.type = type
        self.verifier_id = verifier_id
        self.version_id = version_id
        self.versions = versions
        self.work_time = work_time
        self.workitem_id = workitem_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to_id is not None:
            result['assignedToId'] = self.assigned_to_id
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.expected_work_time is not None:
            result['expectedWorkTime'] = self.expected_work_time
        if self.extra_id is not None:
            result['extraId'] = self.extra_id
        if self.extra_is_deleted is not None:
            result['extraIsDeleted'] = self.extra_is_deleted
        if self.found_phase is not None:
            result['foundPhase'] = self.found_phase
        if self.gmt_closed is not None:
            result['gmtClosed'] = self.gmt_closed
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_due is not None:
            result['gmtDue'] = self.gmt_due
        if self.gmt_fixed is not None:
            result['gmtFixed'] = self.gmt_fixed
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.gmt_todo is not None:
            result['gmtTodo'] = self.gmt_todo
        if self.id is not None:
            result['id'] = self.id
        if self.is_archived is not None:
            result['isArchived'] = self.is_archived
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.is_done is not None:
            result['isDone'] = self.is_done
        if self.is_stupid is not None:
            result['isStupid'] = self.is_stupid
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.participant_ids is not None:
            result['participantIds'] = self.participant_ids
        if self.phase is not None:
            result['phase'] = self.phase
        if self.priority is not None:
            result['priority'] = self.priority
        if self.product_id is not None:
            result['productId'] = self.product_id
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.reopen_num is not None:
            result['reopenNum'] = self.reopen_num
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.serious_level is not None:
            result['seriousLevel'] = self.serious_level
        if self.solution is not None:
            result['solution'] = self.solution
        if self.source is not None:
            result['source'] = self.source
        if self.sprint_id is not None:
            result['sprintId'] = self.sprint_id
        if self.stage is not None:
            result['stage'] = self.stage
        if self.status is not None:
            result['status'] = self.status
        if self.status_id is not None:
            result['statusId'] = self.status_id
        if self.story_point is not None:
            result['storyPoint'] = self.story_point
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.subject is not None:
            result['subject'] = self.subject
        if self.type is not None:
            result['type'] = self.type
        if self.verifier_id is not None:
            result['verifierId'] = self.verifier_id
        if self.version_id is not None:
            result['versionId'] = self.version_id
        if self.versions is not None:
            result['versions'] = self.versions
        if self.work_time is not None:
            result['workTime'] = self.work_time
        if self.workitem_id is not None:
            result['workitemId'] = self.workitem_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedToId') is not None:
            self.assigned_to_id = m.get('assignedToId')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('expectedWorkTime') is not None:
            self.expected_work_time = m.get('expectedWorkTime')
        if m.get('extraId') is not None:
            self.extra_id = m.get('extraId')
        if m.get('extraIsDeleted') is not None:
            self.extra_is_deleted = m.get('extraIsDeleted')
        if m.get('foundPhase') is not None:
            self.found_phase = m.get('foundPhase')
        if m.get('gmtClosed') is not None:
            self.gmt_closed = m.get('gmtClosed')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtDue') is not None:
            self.gmt_due = m.get('gmtDue')
        if m.get('gmtFixed') is not None:
            self.gmt_fixed = m.get('gmtFixed')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('gmtTodo') is not None:
            self.gmt_todo = m.get('gmtTodo')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isArchived') is not None:
            self.is_archived = m.get('isArchived')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('isDone') is not None:
            self.is_done = m.get('isDone')
        if m.get('isStupid') is not None:
            self.is_stupid = m.get('isStupid')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('participantIds') is not None:
            self.participant_ids = m.get('participantIds')
        if m.get('phase') is not None:
            self.phase = m.get('phase')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('productId') is not None:
            self.product_id = m.get('productId')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('reopenNum') is not None:
            self.reopen_num = m.get('reopenNum')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('seriousLevel') is not None:
            self.serious_level = m.get('seriousLevel')
        if m.get('solution') is not None:
            self.solution = m.get('solution')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('sprintId') is not None:
            self.sprint_id = m.get('sprintId')
        if m.get('stage') is not None:
            self.stage = m.get('stage')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusId') is not None:
            self.status_id = m.get('statusId')
        if m.get('storyPoint') is not None:
            self.story_point = m.get('storyPoint')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('verifierId') is not None:
            self.verifier_id = m.get('verifierId')
        if m.get('versionId') is not None:
            self.version_id = m.get('versionId')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        if m.get('workTime') is not None:
            self.work_time = m.get('workTime')
        if m.get('workitemId') is not None:
            self.workitem_id = m.get('workitemId')
        return self


class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightWorkitemStatusJoinWorkitemDefectExtraResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportInsightWorkitemVersionRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportInsightWorkitemVersionResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        gmt_publish: int = None,
        gmt_start: int = None,
        id: int = None,
        identifier: str = None,
        is_deleted: str = None,
        lock_status: int = None,
        name: str = None,
        organization_id: str = None,
        source: str = None,
        status: int = None,
        target_id: str = None,
        target_type: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.gmt_publish = gmt_publish
        self.gmt_start = gmt_start
        self.id = id
        self.identifier = identifier
        self.is_deleted = is_deleted
        self.lock_status = lock_status
        self.name = name
        self.organization_id = organization_id
        self.source = source
        self.status = status
        self.target_id = target_id
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_publish is not None:
            result['gmtPublish'] = self.gmt_publish
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_deleted is not None:
            result['isDeleted'] = self.is_deleted
        if self.lock_status is not None:
            result['lockStatus'] = self.lock_status
        if self.name is not None:
            result['name'] = self.name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.source is not None:
            result['source'] = self.source
        if self.status is not None:
            result['status'] = self.status
        if self.target_id is not None:
            result['targetId'] = self.target_id
        if self.target_type is not None:
            result['targetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtPublish') is not None:
            self.gmt_publish = m.get('gmtPublish')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isDeleted') is not None:
            self.is_deleted = m.get('isDeleted')
        if m.get('lockStatus') is not None:
            self.lock_status = m.get('lockStatus')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('targetId') is not None:
            self.target_id = m.get('targetId')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        return self


class ExportInsightWorkitemVersionResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportInsightWorkitemVersionResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportInsightWorkitemVersionResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportInsightWorkitemVersionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportInsightWorkitemVersionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportInsightWorkitemVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportWorkitemActivityRequest(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        max_results: int = None,
        next_token: str = None,
        start_time: str = None,
    ):
        # This parameter is required.
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.start_time = start_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        return self


class ExportWorkitemActivityResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_event: int = None,
        id: int = None,
        identifier: str = None,
        new_value: str = None,
        old_value: str = None,
        organization_id: str = None,
        project_id: str = None,
        source: str = None,
        type: str = None,
        workitem_id: str = None,
    ):
        self.gmt_event = gmt_event
        self.id = id
        self.identifier = identifier
        self.new_value = new_value
        self.old_value = old_value
        self.organization_id = organization_id
        self.project_id = project_id
        self.source = source
        self.type = type
        self.workitem_id = workitem_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_event is not None:
            result['gmtEvent'] = self.gmt_event
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.new_value is not None:
            result['newValue'] = self.new_value
        if self.old_value is not None:
            result['oldValue'] = self.old_value
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_id is not None:
            result['workitemId'] = self.workitem_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtEvent') is not None:
            self.gmt_event = m.get('gmtEvent')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('newValue') is not None:
            self.new_value = m.get('newValue')
        if m.get('oldValue') is not None:
            self.old_value = m.get('oldValue')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemId') is not None:
            self.workitem_id = m.get('workitemId')
        return self


class ExportWorkitemActivityResponseBody(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        result: List[ExportWorkitemActivityResponseBodyResult] = None,
        total_count: int = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.result = result
        self.total_count = total_count

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ExportWorkitemActivityResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ExportWorkitemActivityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ExportWorkitemActivityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportWorkitemActivityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetApplicationRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetApplicationResponseBody(TeaModel):
    def __init__(
        self,
        app_template_display_name: str = None,
        app_template_name: str = None,
        creator_account_id: str = None,
        description: str = None,
        gmt_create: str = None,
        name: str = None,
        request_id: str = None,
    ):
        self.app_template_display_name = app_template_display_name
        self.app_template_name = app_template_name
        self.creator_account_id = creator_account_id
        self.description = description
        self.gmt_create = gmt_create
        self.name = name
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_template_display_name is not None:
            result['appTemplateDisplayName'] = self.app_template_display_name
        if self.app_template_name is not None:
            result['appTemplateName'] = self.app_template_name
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appTemplateDisplayName') is not None:
            self.app_template_display_name = m.get('appTemplateDisplayName')
        if m.get('appTemplateName') is not None:
            self.app_template_name = m.get('appTemplateName')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class GetApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetBranchInfoRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        branch_name: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.branch_name = branch_name
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetBranchInfoResponseBodyResultCommitAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetBranchInfoResponseBodyResultCommitCommitter(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetBranchInfoResponseBodyResultCommitSignature(TeaModel):
    def __init__(
        self,
        gpg_key_id: str = None,
        verification_status: str = None,
    ):
        self.gpg_key_id = gpg_key_id
        self.verification_status = verification_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gpg_key_id is not None:
            result['gpgKeyId'] = self.gpg_key_id
        if self.verification_status is not None:
            result['verificationStatus'] = self.verification_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gpgKeyId') is not None:
            self.gpg_key_id = m.get('gpgKeyId')
        if m.get('verificationStatus') is not None:
            self.verification_status = m.get('verificationStatus')
        return self


class GetBranchInfoResponseBodyResultCommit(TeaModel):
    def __init__(
        self,
        author: GetBranchInfoResponseBodyResultCommitAuthor = None,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        comments_count: int = None,
        committed_date: str = None,
        committer: GetBranchInfoResponseBodyResultCommitCommitter = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        signature: GetBranchInfoResponseBodyResultCommitSignature = None,
        title: str = None,
    ):
        self.author = author
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.comments_count = comments_count
        self.committed_date = committed_date
        self.committer = committer
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.signature = signature
        self.title = title

    def validate(self):
        if self.author:
            self.author.validate()
        if self.committer:
            self.committer.validate()
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.comments_count is not None:
            result['commentsCount'] = self.comments_count
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer is not None:
            result['committer'] = self.committer.to_map()
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = GetBranchInfoResponseBodyResultCommitAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('commentsCount') is not None:
            self.comments_count = m.get('commentsCount')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committer') is not None:
            temp_model = GetBranchInfoResponseBodyResultCommitCommitter()
            self.committer = temp_model.from_map(m['committer'])
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('signature') is not None:
            temp_model = GetBranchInfoResponseBodyResultCommitSignature()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetBranchInfoResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit: GetBranchInfoResponseBodyResultCommit = None,
        name: str = None,
        protected: str = None,
    ):
        self.commit = commit
        self.name = name
        self.protected = protected

    def validate(self):
        if self.commit:
            self.commit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit is not None:
            result['commit'] = self.commit.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.protected is not None:
            result['protected'] = self.protected
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commit') is not None:
            temp_model = GetBranchInfoResponseBodyResultCommit()
            self.commit = temp_model.from_map(m['commit'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('protected') is not None:
            self.protected = m.get('protected')
        return self


class GetBranchInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetBranchInfoResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetBranchInfoResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetBranchInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetBranchInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetBranchInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCheckRunRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        check_run_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.check_run_id = check_run_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.check_run_id is not None:
            result['checkRunId'] = self.check_run_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('checkRunId') is not None:
            self.check_run_id = m.get('checkRunId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class GetCheckRunResponseBodyResultAnnotations(TeaModel):
    def __init__(
        self,
        annotation_level: str = None,
        end_column: int = None,
        end_line: int = None,
        id: int = None,
        message: str = None,
        path: str = None,
        raw_details: str = None,
        start_column: int = None,
        start_line: int = None,
        title: str = None,
    ):
        self.annotation_level = annotation_level
        self.end_column = end_column
        self.end_line = end_line
        self.id = id
        self.message = message
        self.path = path
        self.raw_details = raw_details
        self.start_column = start_column
        self.start_line = start_line
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation_level is not None:
            result['annotationLevel'] = self.annotation_level
        if self.end_column is not None:
            result['endColumn'] = self.end_column
        if self.end_line is not None:
            result['endLine'] = self.end_line
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.path is not None:
            result['path'] = self.path
        if self.raw_details is not None:
            result['rawDetails'] = self.raw_details
        if self.start_column is not None:
            result['startColumn'] = self.start_column
        if self.start_line is not None:
            result['startLine'] = self.start_line
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotationLevel') is not None:
            self.annotation_level = m.get('annotationLevel')
        if m.get('endColumn') is not None:
            self.end_column = m.get('endColumn')
        if m.get('endLine') is not None:
            self.end_line = m.get('endLine')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('rawDetails') is not None:
            self.raw_details = m.get('rawDetails')
        if m.get('startColumn') is not None:
            self.start_column = m.get('startColumn')
        if m.get('startLine') is not None:
            self.start_line = m.get('startLine')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetCheckRunResponseBodyResultCheckSuite(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class GetCheckRunResponseBodyResultOutputImages(TeaModel):
    def __init__(
        self,
        alt: str = None,
        caption: str = None,
        image_url: str = None,
    ):
        self.alt = alt
        self.caption = caption
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alt is not None:
            result['alt'] = self.alt
        if self.caption is not None:
            result['caption'] = self.caption
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alt') is not None:
            self.alt = m.get('alt')
        if m.get('caption') is not None:
            self.caption = m.get('caption')
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        return self


class GetCheckRunResponseBodyResultOutput(TeaModel):
    def __init__(
        self,
        images: List[GetCheckRunResponseBodyResultOutputImages] = None,
        summary: str = None,
        text: str = None,
        title: str = None,
    ):
        self.images = images
        self.summary = summary
        self.text = text
        self.title = title

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['images'] = []
        if self.images is not None:
            for k in self.images:
                result['images'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary
        if self.text is not None:
            result['text'] = self.text
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('images') is not None:
            for k in m.get('images'):
                temp_model = GetCheckRunResponseBodyResultOutputImages()
                self.images.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetCheckRunResponseBodyResultWriter(TeaModel):
    def __init__(
        self,
        id: str = None,
        logo_url: str = None,
        name: str = None,
        slug: str = None,
        type: str = None,
    ):
        self.id = id
        self.logo_url = logo_url
        self.name = name
        self.slug = slug
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.logo_url is not None:
            result['logoUrl'] = self.logo_url
        if self.name is not None:
            result['name'] = self.name
        if self.slug is not None:
            result['slug'] = self.slug
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('logoUrl') is not None:
            self.logo_url = m.get('logoUrl')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('slug') is not None:
            self.slug = m.get('slug')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetCheckRunResponseBodyResult(TeaModel):
    def __init__(
        self,
        annotations: List[GetCheckRunResponseBodyResultAnnotations] = None,
        check_suite: GetCheckRunResponseBodyResultCheckSuite = None,
        completed_at: str = None,
        conclusion: str = None,
        created_at: str = None,
        details_url: str = None,
        external_id: str = None,
        head_sha: str = None,
        id: int = None,
        name: str = None,
        output: GetCheckRunResponseBodyResultOutput = None,
        started_at: str = None,
        status: str = None,
        updated_at: str = None,
        writer: GetCheckRunResponseBodyResultWriter = None,
    ):
        self.annotations = annotations
        self.check_suite = check_suite
        self.completed_at = completed_at
        self.conclusion = conclusion
        self.created_at = created_at
        self.details_url = details_url
        self.external_id = external_id
        self.head_sha = head_sha
        self.id = id
        self.name = name
        self.output = output
        self.started_at = started_at
        self.status = status
        self.updated_at = updated_at
        self.writer = writer

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.check_suite:
            self.check_suite.validate()
        if self.output:
            self.output.validate()
        if self.writer:
            self.writer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.check_suite is not None:
            result['checkSuite'] = self.check_suite.to_map()
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.conclusion is not None:
            result['conclusion'] = self.conclusion
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.details_url is not None:
            result['detailsUrl'] = self.details_url
        if self.external_id is not None:
            result['externalId'] = self.external_id
        if self.head_sha is not None:
            result['headSha'] = self.head_sha
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.output is not None:
            result['output'] = self.output.to_map()
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.writer is not None:
            result['writer'] = self.writer.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = GetCheckRunResponseBodyResultAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('checkSuite') is not None:
            temp_model = GetCheckRunResponseBodyResultCheckSuite()
            self.check_suite = temp_model.from_map(m['checkSuite'])
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('conclusion') is not None:
            self.conclusion = m.get('conclusion')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('detailsUrl') is not None:
            self.details_url = m.get('detailsUrl')
        if m.get('externalId') is not None:
            self.external_id = m.get('externalId')
        if m.get('headSha') is not None:
            self.head_sha = m.get('headSha')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('output') is not None:
            temp_model = GetCheckRunResponseBodyResultOutput()
            self.output = temp_model.from_map(m['output'])
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('writer') is not None:
            temp_model = GetCheckRunResponseBodyResultWriter()
            self.writer = temp_model.from_map(m['writer'])
        return self


class GetCheckRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetCheckRunResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetCheckRunResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetCheckRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCheckRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCheckRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCodeupOrganizationRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
    ):
        self.access_token = access_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        return self


class GetCodeupOrganizationResponseBodyResult(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        id: int = None,
        namespace_id: int = None,
        organization_id: str = None,
        path: str = None,
        updated_at: str = None,
        user_role: str = None,
    ):
        self.created_at = created_at
        self.id = id
        self.namespace_id = namespace_id
        self.organization_id = organization_id
        self.path = path
        self.updated_at = updated_at
        self.user_role = user_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.path is not None:
            result['path'] = self.path
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.user_role is not None:
            result['userRole'] = self.user_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('userRole') is not None:
            self.user_role = m.get('userRole')
        return self


class GetCodeupOrganizationResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetCodeupOrganizationResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetCodeupOrganizationResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetCodeupOrganizationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCodeupOrganizationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCodeupOrganizationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCompareDetailRequest(TeaModel):
    def __init__(
        self,
        from_: str = None,
        max_diff_byte: int = None,
        max_diff_file: int = None,
        merge_base: bool = None,
        organization_id: str = None,
        to: str = None,
    ):
        # This parameter is required.
        self.from_ = from_
        self.max_diff_byte = max_diff_byte
        self.max_diff_file = max_diff_file
        self.merge_base = merge_base
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.max_diff_byte is not None:
            result['maxDiffByte'] = self.max_diff_byte
        if self.max_diff_file is not None:
            result['maxDiffFile'] = self.max_diff_file
        if self.merge_base is not None:
            result['mergeBase'] = self.merge_base
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('maxDiffByte') is not None:
            self.max_diff_byte = m.get('maxDiffByte')
        if m.get('maxDiffFile') is not None:
            self.max_diff_file = m.get('maxDiffFile')
        if m.get('mergeBase') is not None:
            self.merge_base = m.get('mergeBase')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class GetCompareDetailResponseBodyResultCommitsAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetCompareDetailResponseBodyResultCommitsCommitter(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetCompareDetailResponseBodyResultCommits(TeaModel):
    def __init__(
        self,
        author: GetCompareDetailResponseBodyResultCommitsAuthor = None,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        comments_count: int = None,
        committed_date: str = None,
        committer: GetCompareDetailResponseBodyResultCommitsCommitter = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        title: str = None,
    ):
        self.author = author
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.comments_count = comments_count
        self.committed_date = committed_date
        self.committer = committer
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.title = title

    def validate(self):
        if self.author:
            self.author.validate()
        if self.committer:
            self.committer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.comments_count is not None:
            result['commentsCount'] = self.comments_count
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer is not None:
            result['committer'] = self.committer.to_map()
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = GetCompareDetailResponseBodyResultCommitsAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('commentsCount') is not None:
            self.comments_count = m.get('commentsCount')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committer') is not None:
            temp_model = GetCompareDetailResponseBodyResultCommitsCommitter()
            self.committer = temp_model.from_map(m['committer'])
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetCompareDetailResponseBodyResultDiffs(TeaModel):
    def __init__(
        self,
        a_mode: str = None,
        b_mode: str = None,
        deleted_file: bool = None,
        diff: str = None,
        is_binary: bool = None,
        is_new_lfs: bool = None,
        is_old_lfs: bool = None,
        new_file: bool = None,
        new_id: str = None,
        new_path: str = None,
        old_id: str = None,
        old_path: str = None,
        renamed_file: bool = None,
    ):
        self.a_mode = a_mode
        self.b_mode = b_mode
        self.deleted_file = deleted_file
        self.diff = diff
        self.is_binary = is_binary
        self.is_new_lfs = is_new_lfs
        self.is_old_lfs = is_old_lfs
        self.new_file = new_file
        self.new_id = new_id
        self.new_path = new_path
        self.old_id = old_id
        self.old_path = old_path
        self.renamed_file = renamed_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.a_mode is not None:
            result['aMode'] = self.a_mode
        if self.b_mode is not None:
            result['bMode'] = self.b_mode
        if self.deleted_file is not None:
            result['deletedFile'] = self.deleted_file
        if self.diff is not None:
            result['diff'] = self.diff
        if self.is_binary is not None:
            result['isBinary'] = self.is_binary
        if self.is_new_lfs is not None:
            result['isNewLfs'] = self.is_new_lfs
        if self.is_old_lfs is not None:
            result['isOldLfs'] = self.is_old_lfs
        if self.new_file is not None:
            result['newFile'] = self.new_file
        if self.new_id is not None:
            result['newId'] = self.new_id
        if self.new_path is not None:
            result['newPath'] = self.new_path
        if self.old_id is not None:
            result['oldId'] = self.old_id
        if self.old_path is not None:
            result['oldPath'] = self.old_path
        if self.renamed_file is not None:
            result['renamedFile'] = self.renamed_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aMode') is not None:
            self.a_mode = m.get('aMode')
        if m.get('bMode') is not None:
            self.b_mode = m.get('bMode')
        if m.get('deletedFile') is not None:
            self.deleted_file = m.get('deletedFile')
        if m.get('diff') is not None:
            self.diff = m.get('diff')
        if m.get('isBinary') is not None:
            self.is_binary = m.get('isBinary')
        if m.get('isNewLfs') is not None:
            self.is_new_lfs = m.get('isNewLfs')
        if m.get('isOldLfs') is not None:
            self.is_old_lfs = m.get('isOldLfs')
        if m.get('newFile') is not None:
            self.new_file = m.get('newFile')
        if m.get('newId') is not None:
            self.new_id = m.get('newId')
        if m.get('newPath') is not None:
            self.new_path = m.get('newPath')
        if m.get('oldId') is not None:
            self.old_id = m.get('oldId')
        if m.get('oldPath') is not None:
            self.old_path = m.get('oldPath')
        if m.get('renamedFile') is not None:
            self.renamed_file = m.get('renamedFile')
        return self


class GetCompareDetailResponseBodyResult(TeaModel):
    def __init__(
        self,
        commits: List[GetCompareDetailResponseBodyResultCommits] = None,
        diffs: List[GetCompareDetailResponseBodyResultDiffs] = None,
        messages: List[str] = None,
    ):
        self.commits = commits
        self.diffs = diffs
        self.messages = messages

    def validate(self):
        if self.commits:
            for k in self.commits:
                if k:
                    k.validate()
        if self.diffs:
            for k in self.diffs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['commits'] = []
        if self.commits is not None:
            for k in self.commits:
                result['commits'].append(k.to_map() if k else None)
        result['diffs'] = []
        if self.diffs is not None:
            for k in self.diffs:
                result['diffs'].append(k.to_map() if k else None)
        if self.messages is not None:
            result['messages'] = self.messages
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.commits = []
        if m.get('commits') is not None:
            for k in m.get('commits'):
                temp_model = GetCompareDetailResponseBodyResultCommits()
                self.commits.append(temp_model.from_map(k))
        self.diffs = []
        if m.get('diffs') is not None:
            for k in m.get('diffs'):
                temp_model = GetCompareDetailResponseBodyResultDiffs()
                self.diffs.append(temp_model.from_map(k))
        if m.get('messages') is not None:
            self.messages = m.get('messages')
        return self


class GetCompareDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetCompareDetailResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetCompareDetailResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetCompareDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCompareDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCompareDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomFieldOptionRequest(TeaModel):
    def __init__(
        self,
        space_identifier: str = None,
        space_type: str = None,
        workitem_type_identifier: str = None,
    ):
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.space_type = space_type
        # This parameter is required.
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class GetCustomFieldOptionResponseBodyFileds(TeaModel):
    def __init__(
        self,
        display_value: str = None,
        field_identifier: str = None,
        identifier: str = None,
        level: int = None,
        position: int = None,
        value: str = None,
        value_en: str = None,
    ):
        self.display_value = display_value
        self.field_identifier = field_identifier
        self.identifier = identifier
        self.level = level
        self.position = position
        self.value = value
        self.value_en = value_en

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_value is not None:
            result['displayValue'] = self.display_value
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.level is not None:
            result['level'] = self.level
        if self.position is not None:
            result['position'] = self.position
        if self.value is not None:
            result['value'] = self.value
        if self.value_en is not None:
            result['valueEn'] = self.value_en
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayValue') is not None:
            self.display_value = m.get('displayValue')
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('position') is not None:
            self.position = m.get('position')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('valueEn') is not None:
            self.value_en = m.get('valueEn')
        return self


class GetCustomFieldOptionResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        fileds: List[GetCustomFieldOptionResponseBodyFileds] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.fileds = fileds
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.fileds:
            for k in self.fileds:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        result['fileds'] = []
        if self.fileds is not None:
            for k in self.fileds:
                result['fileds'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        self.fileds = []
        if m.get('fileds') is not None:
            for k in m.get('fileds'):
                temp_model = GetCustomFieldOptionResponseBodyFileds()
                self.fileds.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetCustomFieldOptionResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetCustomFieldOptionResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomFieldOptionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileBlobsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        file_path: str = None,
        from_: int = None,
        organization_id: str = None,
        ref: str = None,
        to: int = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.file_path = file_path
        self.from_ = from_
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.ref = ref
        self.to = to

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.from_ is not None:
            result['from'] = self.from_
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.ref is not None:
            result['ref'] = self.ref
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('ref') is not None:
            self.ref = m.get('ref')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class GetFileBlobsResponseBodyResult(TeaModel):
    def __init__(
        self,
        content: str = None,
        size: int = None,
        total_lines: int = None,
    ):
        self.content = content
        self.size = size
        self.total_lines = total_lines

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.size is not None:
            result['size'] = self.size
        if self.total_lines is not None:
            result['totalLines'] = self.total_lines
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('totalLines') is not None:
            self.total_lines = m.get('totalLines')
        return self


class GetFileBlobsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetFileBlobsResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetFileBlobsResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetFileBlobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileBlobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileBlobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFileLastCommitRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        file_path: str = None,
        organization_id: str = None,
        sha: str = None,
        show_signature: bool = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.file_path = file_path
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.sha = sha
        self.show_signature = show_signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.sha is not None:
            result['sha'] = self.sha
        if self.show_signature is not None:
            result['showSignature'] = self.show_signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('sha') is not None:
            self.sha = m.get('sha')
        if m.get('showSignature') is not None:
            self.show_signature = m.get('showSignature')
        return self


class GetFileLastCommitResponseBodyResultSignature(TeaModel):
    def __init__(
        self,
        gpg_key_id: str = None,
        verification_status: str = None,
    ):
        # GPG密钥ID
        self.gpg_key_id = gpg_key_id
        self.verification_status = verification_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gpg_key_id is not None:
            result['gpgKeyId'] = self.gpg_key_id
        if self.verification_status is not None:
            result['verificationStatus'] = self.verification_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gpgKeyId') is not None:
            self.gpg_key_id = m.get('gpgKeyId')
        if m.get('verificationStatus') is not None:
            self.verification_status = m.get('verificationStatus')
        return self


class GetFileLastCommitResponseBodyResult(TeaModel):
    def __init__(
        self,
        author_date: str = None,
        author_email: str = None,
        author_name: str = None,
        committed_date: str = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        signature: GetFileLastCommitResponseBodyResultSignature = None,
        title: str = None,
    ):
        self.author_date = author_date
        self.author_email = author_email
        self.author_name = author_name
        self.committed_date = committed_date
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.signature = signature
        self.title = title

    def validate(self):
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author_date is not None:
            result['authorDate'] = self.author_date
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authorDate') is not None:
            self.author_date = m.get('authorDate')
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('signature') is not None:
            temp_model = GetFileLastCommitResponseBodyResultSignature()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetFileLastCommitResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetFileLastCommitResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetFileLastCommitResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetFileLastCommitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFileLastCommitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFileLastCommitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList(TeaModel):
    def __init__(
        self,
        color: str = None,
        creator_account_id: str = None,
        id: int = None,
        modifer_account_id: str = None,
        name: str = None,
    ):
        self.color = color
        self.creator_account_id = creator_account_id
        self.id = id
        self.modifer_account_id = modifer_account_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.id is not None:
            result['id'] = self.id
        if self.modifer_account_id is not None:
            result['modiferAccountId'] = self.modifer_account_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modiferAccountId') is not None:
            self.modifer_account_id = m.get('modiferAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetFlowTagGroupResponseBodyFlowTagGroup(TeaModel):
    def __init__(
        self,
        creator_account_id: str = None,
        flow_tag_list: List[GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList] = None,
        id: int = None,
        modifer_account_id: str = None,
        name: str = None,
    ):
        self.creator_account_id = creator_account_id
        self.flow_tag_list = flow_tag_list
        self.id = id
        self.modifer_account_id = modifer_account_id
        self.name = name

    def validate(self):
        if self.flow_tag_list:
            for k in self.flow_tag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        result['flowTagList'] = []
        if self.flow_tag_list is not None:
            for k in self.flow_tag_list:
                result['flowTagList'].append(k.to_map() if k else None)
        if self.id is not None:
            result['id'] = self.id
        if self.modifer_account_id is not None:
            result['modiferAccountId'] = self.modifer_account_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        self.flow_tag_list = []
        if m.get('flowTagList') is not None:
            for k in m.get('flowTagList'):
                temp_model = GetFlowTagGroupResponseBodyFlowTagGroupFlowTagList()
                self.flow_tag_list.append(temp_model.from_map(k))
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modiferAccountId') is not None:
            self.modifer_account_id = m.get('modiferAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetFlowTagGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        flow_tag_group: GetFlowTagGroupResponseBodyFlowTagGroup = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.flow_tag_group = flow_tag_group
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.flow_tag_group:
            self.flow_tag_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.flow_tag_group is not None:
            result['flowTagGroup'] = self.flow_tag_group.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('flowTagGroup') is not None:
            temp_model = GetFlowTagGroupResponseBodyFlowTagGroup()
            self.flow_tag_group = temp_model.from_map(m['flowTagGroup'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetFlowTagGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetFlowTagGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetFlowTagGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGroupByPathRequest(TeaModel):
    def __init__(
        self,
        identity: str = None,
        organization_id: str = None,
    ):
        # This parameter is required.
        self.identity = identity
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identity is not None:
            result['identity'] = self.identity
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetGroupByPathResponseBodyResult(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        owner_id: str = None,
        parent_id: str = None,
        path: str = None,
        path_with_namespace: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.description = description
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class GetGroupByPathResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetGroupByPathResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetGroupByPathResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetGroupByPathResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetGroupByPathResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetGroupByPathResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetGroupDetailRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        group_id: int = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.group_id = group_id
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetGroupDetailResponseBodyResult(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        owner_id: int = None,
        parent_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        type: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.description = description
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.type = type
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.type is not None:
            result['type'] = self.type
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class GetGroupDetailResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetGroupDetailResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetGroupDetailResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetGroupDetailResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetGroupDetailResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetGroupDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetHostGroupResponseBodyHostGroupHostInfos(TeaModel):
    def __init__(
        self,
        aliyun_region_id: str = None,
        create_time: int = None,
        creator_account_id: str = None,
        instance_name: str = None,
        ip: str = None,
        machine_sn: str = None,
        modifier_account_id: str = None,
        object_type: str = None,
        update_time: int = None,
    ):
        self.aliyun_region_id = aliyun_region_id
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.instance_name = instance_name
        self.ip = ip
        self.machine_sn = machine_sn
        self.modifier_account_id = modifier_account_id
        self.object_type = object_type
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_region_id is not None:
            result['aliyunRegionId'] = self.aliyun_region_id
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.instance_name is not None:
            result['instanceName'] = self.instance_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.machine_sn is not None:
            result['machineSn'] = self.machine_sn
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.object_type is not None:
            result['objectType'] = self.object_type
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunRegionId') is not None:
            self.aliyun_region_id = m.get('aliyunRegionId')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('instanceName') is not None:
            self.instance_name = m.get('instanceName')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('machineSn') is not None:
            self.machine_sn = m.get('machineSn')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('objectType') is not None:
            self.object_type = m.get('objectType')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetHostGroupResponseBodyHostGroup(TeaModel):
    def __init__(
        self,
        aliyun_region: str = None,
        create_time: int = None,
        creator_account_id: str = None,
        description: str = None,
        ecs_label_key: str = None,
        ecs_label_value: str = None,
        ecs_type: str = None,
        host_infos: List[GetHostGroupResponseBodyHostGroupHostInfos] = None,
        host_num: int = None,
        id: int = None,
        modifier_account_id: str = None,
        name: str = None,
        service_connection_id: int = None,
        type: str = None,
        upate_time: int = None,
    ):
        self.aliyun_region = aliyun_region
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.description = description
        self.ecs_label_key = ecs_label_key
        self.ecs_label_value = ecs_label_value
        self.ecs_type = ecs_type
        self.host_infos = host_infos
        self.host_num = host_num
        self.id = id
        self.modifier_account_id = modifier_account_id
        self.name = name
        self.service_connection_id = service_connection_id
        self.type = type
        self.upate_time = upate_time

    def validate(self):
        if self.host_infos:
            for k in self.host_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_region is not None:
            result['aliyunRegion'] = self.aliyun_region
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.description is not None:
            result['description'] = self.description
        if self.ecs_label_key is not None:
            result['ecsLabelKey'] = self.ecs_label_key
        if self.ecs_label_value is not None:
            result['ecsLabelValue'] = self.ecs_label_value
        if self.ecs_type is not None:
            result['ecsType'] = self.ecs_type
        result['hostInfos'] = []
        if self.host_infos is not None:
            for k in self.host_infos:
                result['hostInfos'].append(k.to_map() if k else None)
        if self.host_num is not None:
            result['hostNum'] = self.host_num
        if self.id is not None:
            result['id'] = self.id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.name is not None:
            result['name'] = self.name
        if self.service_connection_id is not None:
            result['serviceConnectionId'] = self.service_connection_id
        if self.type is not None:
            result['type'] = self.type
        if self.upate_time is not None:
            result['upateTIme'] = self.upate_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunRegion') is not None:
            self.aliyun_region = m.get('aliyunRegion')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('ecsLabelKey') is not None:
            self.ecs_label_key = m.get('ecsLabelKey')
        if m.get('ecsLabelValue') is not None:
            self.ecs_label_value = m.get('ecsLabelValue')
        if m.get('ecsType') is not None:
            self.ecs_type = m.get('ecsType')
        self.host_infos = []
        if m.get('hostInfos') is not None:
            for k in m.get('hostInfos'):
                temp_model = GetHostGroupResponseBodyHostGroupHostInfos()
                self.host_infos.append(temp_model.from_map(k))
        if m.get('hostNum') is not None:
            self.host_num = m.get('hostNum')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('serviceConnectionId') is not None:
            self.service_connection_id = m.get('serviceConnectionId')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('upateTIme') is not None:
            self.upate_time = m.get('upateTIme')
        return self


class GetHostGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        host_group: GetHostGroupResponseBodyHostGroup = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.host_group = host_group
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.host_group:
            self.host_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.host_group is not None:
            result['hostGroup'] = self.host_group.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('hostGroup') is not None:
            temp_model = GetHostGroupResponseBodyHostGroup()
            self.host_group = temp_model.from_map(m['hostGroup'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetHostGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetHostGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetHostGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetMergeRequestResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetMergeRequestResponseBodyResultReviewers(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        has_commented: bool = None,
        has_reviewed: bool = None,
        id: int = None,
        name: str = None,
        review_opinion_status: str = None,
        review_time: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.has_commented = has_commented
        self.has_reviewed = has_reviewed
        self.id = id
        self.name = name
        self.review_opinion_status = review_opinion_status
        self.review_time = review_time
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.has_commented is not None:
            result['hasCommented'] = self.has_commented
        if self.has_reviewed is not None:
            result['hasReviewed'] = self.has_reviewed
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.review_opinion_status is not None:
            result['reviewOpinionStatus'] = self.review_opinion_status
        if self.review_time is not None:
            result['reviewTime'] = self.review_time
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('hasCommented') is not None:
            self.has_commented = m.get('hasCommented')
        if m.get('hasReviewed') is not None:
            self.has_reviewed = m.get('hasReviewed')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('reviewOpinionStatus') is not None:
            self.review_opinion_status = m.get('reviewOpinionStatus')
        if m.get('reviewTime') is not None:
            self.review_time = m.get('reviewTime')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetMergeRequestResponseBodyResultSubscribers(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetMergeRequestResponseBodyResultTodoListRequirementCheckItems(TeaModel):
    def __init__(
        self,
        item_type: str = None,
        pass_: bool = None,
    ):
        self.item_type = item_type
        self.pass_ = pass_

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.item_type is not None:
            result['itemType'] = self.item_type
        if self.pass_ is not None:
            result['pass'] = self.pass_
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('itemType') is not None:
            self.item_type = m.get('itemType')
        if m.get('pass') is not None:
            self.pass_ = m.get('pass')
        return self


class GetMergeRequestResponseBodyResultTodoList(TeaModel):
    def __init__(
        self,
        requirement_check_items: List[GetMergeRequestResponseBodyResultTodoListRequirementCheckItems] = None,
    ):
        self.requirement_check_items = requirement_check_items

    def validate(self):
        if self.requirement_check_items:
            for k in self.requirement_check_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['requirementCheckItems'] = []
        if self.requirement_check_items is not None:
            for k in self.requirement_check_items:
                result['requirementCheckItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.requirement_check_items = []
        if m.get('requirementCheckItems') is not None:
            for k in m.get('requirementCheckItems'):
                temp_model = GetMergeRequestResponseBodyResultTodoListRequirementCheckItems()
                self.requirement_check_items.append(temp_model.from_map(k))
        return self


class GetMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        ahead: int = None,
        all_requirements_pass: bool = None,
        author: GetMergeRequestResponseBodyResultAuthor = None,
        behind: int = None,
        create_from: str = None,
        create_time: str = None,
        description: str = None,
        detail_url: str = None,
        local_id: int = None,
        merged_revision: str = None,
        mr_biz_id: str = None,
        mr_type: str = None,
        project_id: int = None,
        reviewers: List[GetMergeRequestResponseBodyResultReviewers] = None,
        source_branch: str = None,
        source_project_id: int = None,
        status: str = None,
        subscribers: List[GetMergeRequestResponseBodyResultSubscribers] = None,
        support_merge_fast_forward_only: bool = None,
        target_branch: str = None,
        target_project_id: int = None,
        target_project_name_with_namespace: str = None,
        target_project_path_with_namespace: str = None,
        title: str = None,
        todo_list: GetMergeRequestResponseBodyResultTodoList = None,
        update_time: str = None,
        web_url: str = None,
    ):
        self.ahead = ahead
        self.all_requirements_pass = all_requirements_pass
        self.author = author
        self.behind = behind
        self.create_from = create_from
        self.create_time = create_time
        self.description = description
        self.detail_url = detail_url
        self.local_id = local_id
        self.merged_revision = merged_revision
        self.mr_biz_id = mr_biz_id
        self.mr_type = mr_type
        self.project_id = project_id
        self.reviewers = reviewers
        self.source_branch = source_branch
        self.source_project_id = source_project_id
        self.status = status
        self.subscribers = subscribers
        self.support_merge_fast_forward_only = support_merge_fast_forward_only
        self.target_branch = target_branch
        self.target_project_id = target_project_id
        self.target_project_name_with_namespace = target_project_name_with_namespace
        self.target_project_path_with_namespace = target_project_path_with_namespace
        self.title = title
        self.todo_list = todo_list
        self.update_time = update_time
        self.web_url = web_url

    def validate(self):
        if self.author:
            self.author.validate()
        if self.reviewers:
            for k in self.reviewers:
                if k:
                    k.validate()
        if self.subscribers:
            for k in self.subscribers:
                if k:
                    k.validate()
        if self.todo_list:
            self.todo_list.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ahead is not None:
            result['ahead'] = self.ahead
        if self.all_requirements_pass is not None:
            result['allRequirementsPass'] = self.all_requirements_pass
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.behind is not None:
            result['behind'] = self.behind
        if self.create_from is not None:
            result['createFrom'] = self.create_from
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.merged_revision is not None:
            result['mergedRevision'] = self.merged_revision
        if self.mr_biz_id is not None:
            result['mrBizId'] = self.mr_biz_id
        if self.mr_type is not None:
            result['mrType'] = self.mr_type
        if self.project_id is not None:
            result['projectId'] = self.project_id
        result['reviewers'] = []
        if self.reviewers is not None:
            for k in self.reviewers:
                result['reviewers'].append(k.to_map() if k else None)
        if self.source_branch is not None:
            result['sourceBranch'] = self.source_branch
        if self.source_project_id is not None:
            result['sourceProjectId'] = self.source_project_id
        if self.status is not None:
            result['status'] = self.status
        result['subscribers'] = []
        if self.subscribers is not None:
            for k in self.subscribers:
                result['subscribers'].append(k.to_map() if k else None)
        if self.support_merge_fast_forward_only is not None:
            result['supportMergeFastForwardOnly'] = self.support_merge_fast_forward_only
        if self.target_branch is not None:
            result['targetBranch'] = self.target_branch
        if self.target_project_id is not None:
            result['targetProjectId'] = self.target_project_id
        if self.target_project_name_with_namespace is not None:
            result['targetProjectNameWithNamespace'] = self.target_project_name_with_namespace
        if self.target_project_path_with_namespace is not None:
            result['targetProjectPathWithNamespace'] = self.target_project_path_with_namespace
        if self.title is not None:
            result['title'] = self.title
        if self.todo_list is not None:
            result['todoList'] = self.todo_list.to_map()
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ahead') is not None:
            self.ahead = m.get('ahead')
        if m.get('allRequirementsPass') is not None:
            self.all_requirements_pass = m.get('allRequirementsPass')
        if m.get('author') is not None:
            temp_model = GetMergeRequestResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('behind') is not None:
            self.behind = m.get('behind')
        if m.get('createFrom') is not None:
            self.create_from = m.get('createFrom')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            self.detail_url = m.get('detailUrl')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('mergedRevision') is not None:
            self.merged_revision = m.get('mergedRevision')
        if m.get('mrBizId') is not None:
            self.mr_biz_id = m.get('mrBizId')
        if m.get('mrType') is not None:
            self.mr_type = m.get('mrType')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        self.reviewers = []
        if m.get('reviewers') is not None:
            for k in m.get('reviewers'):
                temp_model = GetMergeRequestResponseBodyResultReviewers()
                self.reviewers.append(temp_model.from_map(k))
        if m.get('sourceBranch') is not None:
            self.source_branch = m.get('sourceBranch')
        if m.get('sourceProjectId') is not None:
            self.source_project_id = m.get('sourceProjectId')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.subscribers = []
        if m.get('subscribers') is not None:
            for k in m.get('subscribers'):
                temp_model = GetMergeRequestResponseBodyResultSubscribers()
                self.subscribers.append(temp_model.from_map(k))
        if m.get('supportMergeFastForwardOnly') is not None:
            self.support_merge_fast_forward_only = m.get('supportMergeFastForwardOnly')
        if m.get('targetBranch') is not None:
            self.target_branch = m.get('targetBranch')
        if m.get('targetProjectId') is not None:
            self.target_project_id = m.get('targetProjectId')
        if m.get('targetProjectNameWithNamespace') is not None:
            self.target_project_name_with_namespace = m.get('targetProjectNameWithNamespace')
        if m.get('targetProjectPathWithNamespace') is not None:
            self.target_project_path_with_namespace = m.get('targetProjectPathWithNamespace')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('todoList') is not None:
            temp_model = GetMergeRequestResponseBodyResultTodoList()
            self.todo_list = temp_model.from_map(m['todoList'])
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class GetMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMergeRequestChangeTreeRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        from_patch_set_biz_id: str = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
        to_patch_set_biz_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.from_patch_set_biz_id = from_patch_set_biz_id
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity
        # This parameter is required.
        self.to_patch_set_biz_id = to_patch_set_biz_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.from_patch_set_biz_id is not None:
            result['fromPatchSetBizId'] = self.from_patch_set_biz_id
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        if self.to_patch_set_biz_id is not None:
            result['toPatchSetBizId'] = self.to_patch_set_biz_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('fromPatchSetBizId') is not None:
            self.from_patch_set_biz_id = m.get('fromPatchSetBizId')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        if m.get('toPatchSetBizId') is not None:
            self.to_patch_set_biz_id = m.get('toPatchSetBizId')
        return self


class GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos(TeaModel):
    def __init__(
        self,
        add_lines: int = None,
        binary_file: bool = None,
        del_lines: int = None,
        deleted_file: bool = None,
        new_file: bool = None,
        new_path: str = None,
        old_path: str = None,
        renamed_file: bool = None,
    ):
        self.add_lines = add_lines
        self.binary_file = binary_file
        self.del_lines = del_lines
        self.deleted_file = deleted_file
        self.new_file = new_file
        self.new_path = new_path
        self.old_path = old_path
        self.renamed_file = renamed_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_lines is not None:
            result['addLines'] = self.add_lines
        if self.binary_file is not None:
            result['binaryFile'] = self.binary_file
        if self.del_lines is not None:
            result['delLines'] = self.del_lines
        if self.deleted_file is not None:
            result['deletedFile'] = self.deleted_file
        if self.new_file is not None:
            result['newFile'] = self.new_file
        if self.new_path is not None:
            result['newPath'] = self.new_path
        if self.old_path is not None:
            result['oldPath'] = self.old_path
        if self.renamed_file is not None:
            result['renamedFile'] = self.renamed_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addLines') is not None:
            self.add_lines = m.get('addLines')
        if m.get('binaryFile') is not None:
            self.binary_file = m.get('binaryFile')
        if m.get('delLines') is not None:
            self.del_lines = m.get('delLines')
        if m.get('deletedFile') is not None:
            self.deleted_file = m.get('deletedFile')
        if m.get('newFile') is not None:
            self.new_file = m.get('newFile')
        if m.get('newPath') is not None:
            self.new_path = m.get('newPath')
        if m.get('oldPath') is not None:
            self.old_path = m.get('oldPath')
        if m.get('renamedFile') is not None:
            self.renamed_file = m.get('renamedFile')
        return self


class GetMergeRequestChangeTreeResponseBodyResult(TeaModel):
    def __init__(
        self,
        changed_files_count: int = None,
        changed_files_infos: List[GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos] = None,
        total_add_lines: int = None,
        total_del_lines: int = None,
    ):
        self.changed_files_count = changed_files_count
        self.changed_files_infos = changed_files_infos
        self.total_add_lines = total_add_lines
        self.total_del_lines = total_del_lines

    def validate(self):
        if self.changed_files_infos:
            for k in self.changed_files_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.changed_files_count is not None:
            result['changedFilesCount'] = self.changed_files_count
        result['changedFilesInfos'] = []
        if self.changed_files_infos is not None:
            for k in self.changed_files_infos:
                result['changedFilesInfos'].append(k.to_map() if k else None)
        if self.total_add_lines is not None:
            result['totalAddLines'] = self.total_add_lines
        if self.total_del_lines is not None:
            result['totalDelLines'] = self.total_del_lines
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('changedFilesCount') is not None:
            self.changed_files_count = m.get('changedFilesCount')
        self.changed_files_infos = []
        if m.get('changedFilesInfos') is not None:
            for k in m.get('changedFilesInfos'):
                temp_model = GetMergeRequestChangeTreeResponseBodyResultChangedFilesInfos()
                self.changed_files_infos.append(temp_model.from_map(k))
        if m.get('totalAddLines') is not None:
            self.total_add_lines = m.get('totalAddLines')
        if m.get('totalDelLines') is not None:
            self.total_del_lines = m.get('totalDelLines')
        return self


class GetMergeRequestChangeTreeResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetMergeRequestChangeTreeResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetMergeRequestChangeTreeResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetMergeRequestChangeTreeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetMergeRequestChangeTreeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMergeRequestChangeTreeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOrganizationMemberResponseBodyMemberIdentities(TeaModel):
    def __init__(
        self,
        extern_uid: str = None,
        provider: str = None,
    ):
        self.extern_uid = extern_uid
        self.provider = provider

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extern_uid is not None:
            result['externUid'] = self.extern_uid
        if self.provider is not None:
            result['provider'] = self.provider
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('externUid') is not None:
            self.extern_uid = m.get('externUid')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        return self


class GetOrganizationMemberResponseBodyMember(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        birthday: int = None,
        dept_lists: List[str] = None,
        email: str = None,
        hired_date: int = None,
        identities: GetOrganizationMemberResponseBodyMemberIdentities = None,
        job_number: str = None,
        join_time: int = None,
        last_visit_time: int = None,
        mobile: str = None,
        organization_member_name: str = None,
        organization_role_id: str = None,
        organization_role_name: str = None,
        state: str = None,
    ):
        self.account_id = account_id
        self.birthday = birthday
        self.dept_lists = dept_lists
        self.email = email
        self.hired_date = hired_date
        self.identities = identities
        self.job_number = job_number
        self.join_time = join_time
        self.last_visit_time = last_visit_time
        self.mobile = mobile
        self.organization_member_name = organization_member_name
        self.organization_role_id = organization_role_id
        self.organization_role_name = organization_role_name
        self.state = state

    def validate(self):
        if self.identities:
            self.identities.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.birthday is not None:
            result['birthday'] = self.birthday
        if self.dept_lists is not None:
            result['deptLists'] = self.dept_lists
        if self.email is not None:
            result['email'] = self.email
        if self.hired_date is not None:
            result['hiredDate'] = self.hired_date
        if self.identities is not None:
            result['identities'] = self.identities.to_map()
        if self.job_number is not None:
            result['jobNumber'] = self.job_number
        if self.join_time is not None:
            result['joinTime'] = self.join_time
        if self.last_visit_time is not None:
            result['lastVisitTime'] = self.last_visit_time
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.organization_member_name is not None:
            result['organizationMemberName'] = self.organization_member_name
        if self.organization_role_id is not None:
            result['organizationRoleId'] = self.organization_role_id
        if self.organization_role_name is not None:
            result['organizationRoleName'] = self.organization_role_name
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('birthday') is not None:
            self.birthday = m.get('birthday')
        if m.get('deptLists') is not None:
            self.dept_lists = m.get('deptLists')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('hiredDate') is not None:
            self.hired_date = m.get('hiredDate')
        if m.get('identities') is not None:
            temp_model = GetOrganizationMemberResponseBodyMemberIdentities()
            self.identities = temp_model.from_map(m['identities'])
        if m.get('jobNumber') is not None:
            self.job_number = m.get('jobNumber')
        if m.get('joinTime') is not None:
            self.join_time = m.get('joinTime')
        if m.get('lastVisitTime') is not None:
            self.last_visit_time = m.get('lastVisitTime')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('organizationMemberName') is not None:
            self.organization_member_name = m.get('organizationMemberName')
        if m.get('organizationRoleId') is not None:
            self.organization_role_id = m.get('organizationRoleId')
        if m.get('organizationRoleName') is not None:
            self.organization_role_name = m.get('organizationRoleName')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class GetOrganizationMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        member: GetOrganizationMemberResponseBodyMember = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.member = member
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.member:
            self.member.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.member is not None:
            result['member'] = self.member.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('member') is not None:
            temp_model = GetOrganizationMemberResponseBodyMember()
            self.member = temp_model.from_map(m['member'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetOrganizationMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetOrganizationMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOrganizationMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineResponseBodyPipelinePipelineConfigSourcesData(TeaModel):
    def __init__(
        self,
        branch: str = None,
        clone_depth: int = None,
        credential_id: int = None,
        credential_label: str = None,
        credential_type: str = None,
        events: List[str] = None,
        is_branch_mode: bool = None,
        is_clone_depth: bool = None,
        is_submodule: bool = None,
        is_trigger: bool = None,
        label: str = None,
        namespace: str = None,
        repo: str = None,
        service_connection_id: int = None,
        trigger_filter: str = None,
        webhook: str = None,
    ):
        self.branch = branch
        self.clone_depth = clone_depth
        # Credential Id
        self.credential_id = credential_id
        # Credential Label
        self.credential_label = credential_label
        # Credential Type
        self.credential_type = credential_type
        self.events = events
        self.is_branch_mode = is_branch_mode
        self.is_clone_depth = is_clone_depth
        self.is_submodule = is_submodule
        self.is_trigger = is_trigger
        self.label = label
        self.namespace = namespace
        self.repo = repo
        self.service_connection_id = service_connection_id
        self.trigger_filter = trigger_filter
        self.webhook = webhook

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch is not None:
            result['branch'] = self.branch
        if self.clone_depth is not None:
            result['cloneDepth'] = self.clone_depth
        if self.credential_id is not None:
            result['credentialId'] = self.credential_id
        if self.credential_label is not None:
            result['credentialLabel'] = self.credential_label
        if self.credential_type is not None:
            result['credentialType'] = self.credential_type
        if self.events is not None:
            result['events'] = self.events
        if self.is_branch_mode is not None:
            result['isBranchMode'] = self.is_branch_mode
        if self.is_clone_depth is not None:
            result['isCloneDepth'] = self.is_clone_depth
        if self.is_submodule is not None:
            result['isSubmodule'] = self.is_submodule
        if self.is_trigger is not None:
            result['isTrigger'] = self.is_trigger
        if self.label is not None:
            result['label'] = self.label
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.repo is not None:
            result['repo'] = self.repo
        if self.service_connection_id is not None:
            result['serviceConnectionId'] = self.service_connection_id
        if self.trigger_filter is not None:
            result['triggerFilter'] = self.trigger_filter
        if self.webhook is not None:
            result['webhook'] = self.webhook
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('cloneDepth') is not None:
            self.clone_depth = m.get('cloneDepth')
        if m.get('credentialId') is not None:
            self.credential_id = m.get('credentialId')
        if m.get('credentialLabel') is not None:
            self.credential_label = m.get('credentialLabel')
        if m.get('credentialType') is not None:
            self.credential_type = m.get('credentialType')
        if m.get('events') is not None:
            self.events = m.get('events')
        if m.get('isBranchMode') is not None:
            self.is_branch_mode = m.get('isBranchMode')
        if m.get('isCloneDepth') is not None:
            self.is_clone_depth = m.get('isCloneDepth')
        if m.get('isSubmodule') is not None:
            self.is_submodule = m.get('isSubmodule')
        if m.get('isTrigger') is not None:
            self.is_trigger = m.get('isTrigger')
        if m.get('label') is not None:
            self.label = m.get('label')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('repo') is not None:
            self.repo = m.get('repo')
        if m.get('serviceConnectionId') is not None:
            self.service_connection_id = m.get('serviceConnectionId')
        if m.get('triggerFilter') is not None:
            self.trigger_filter = m.get('triggerFilter')
        if m.get('webhook') is not None:
            self.webhook = m.get('webhook')
        return self


class GetPipelineResponseBodyPipelinePipelineConfigSources(TeaModel):
    def __init__(
        self,
        data: GetPipelineResponseBodyPipelinePipelineConfigSourcesData = None,
        sign: str = None,
        type: str = None,
    ):
        self.data = data
        self.sign = sign
        self.type = type

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.sign is not None:
            result['sign'] = self.sign
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            temp_model = GetPipelineResponseBodyPipelinePipelineConfigSourcesData()
            self.data = temp_model.from_map(m['data'])
        if m.get('sign') is not None:
            self.sign = m.get('sign')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetPipelineResponseBodyPipelinePipelineConfig(TeaModel):
    def __init__(
        self,
        flow: str = None,
        settings: str = None,
        sources: List[GetPipelineResponseBodyPipelinePipelineConfigSources] = None,
    ):
        self.flow = flow
        self.settings = settings
        self.sources = sources

    def validate(self):
        if self.sources:
            for k in self.sources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.flow is not None:
            result['flow'] = self.flow
        if self.settings is not None:
            result['settings'] = self.settings
        result['sources'] = []
        if self.sources is not None:
            for k in self.sources:
                result['sources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('flow') is not None:
            self.flow = m.get('flow')
        if m.get('settings') is not None:
            self.settings = m.get('settings')
        self.sources = []
        if m.get('sources') is not None:
            for k in m.get('sources'):
                temp_model = GetPipelineResponseBodyPipelinePipelineConfigSources()
                self.sources.append(temp_model.from_map(k))
        return self


class GetPipelineResponseBodyPipelineTagList(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetPipelineResponseBodyPipeline(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_account_id: str = None,
        env_id: int = None,
        env_name: str = None,
        group_id: int = None,
        modifier_account_id: str = None,
        name: str = None,
        pipeline_config: GetPipelineResponseBodyPipelinePipelineConfig = None,
        tag_list: List[GetPipelineResponseBodyPipelineTagList] = None,
        update_time: int = None,
    ):
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.env_id = env_id
        self.env_name = env_name
        self.group_id = group_id
        self.modifier_account_id = modifier_account_id
        self.name = name
        self.pipeline_config = pipeline_config
        self.tag_list = tag_list
        self.update_time = update_time

    def validate(self):
        if self.pipeline_config:
            self.pipeline_config.validate()
        if self.tag_list:
            for k in self.tag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.env_id is not None:
            result['envId'] = self.env_id
        if self.env_name is not None:
            result['envName'] = self.env_name
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.name is not None:
            result['name'] = self.name
        if self.pipeline_config is not None:
            result['pipelineConfig'] = self.pipeline_config.to_map()
        result['tagList'] = []
        if self.tag_list is not None:
            for k in self.tag_list:
                result['tagList'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('envId') is not None:
            self.env_id = m.get('envId')
        if m.get('envName') is not None:
            self.env_name = m.get('envName')
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pipelineConfig') is not None:
            temp_model = GetPipelineResponseBodyPipelinePipelineConfig()
            self.pipeline_config = temp_model.from_map(m['pipelineConfig'])
        self.tag_list = []
        if m.get('tagList') is not None:
            for k in m.get('tagList'):
                temp_model = GetPipelineResponseBodyPipelineTagList()
                self.tag_list.append(temp_model.from_map(k))
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetPipelineResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipeline: GetPipelineResponseBodyPipeline = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipeline = pipeline
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.pipeline is not None:
            result['pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('pipeline') is not None:
            temp_model = GetPipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['pipeline'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetPipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineArtifactUrlRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
        file_path: str = None,
    ):
        # This parameter is required.
        self.file_name = file_name
        # This parameter is required.
        self.file_path = file_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.file_path is not None:
            result['filePath'] = self.file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        return self


class GetPipelineArtifactUrlResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.file_url = file_url
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.file_url is not None:
            result['fileUrl'] = self.file_url
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('fileUrl') is not None:
            self.file_url = m.get('fileUrl')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetPipelineArtifactUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineArtifactUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineArtifactUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineEmasArtifactUrlRequest(TeaModel):
    def __init__(
        self,
        service_connection_id: int = None,
    ):
        # This parameter is required.
        self.service_connection_id = service_connection_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_connection_id is not None:
            result['serviceConnectionId'] = self.service_connection_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('serviceConnectionId') is not None:
            self.service_connection_id = m.get('serviceConnectionId')
        return self


class GetPipelineEmasArtifactUrlResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        file_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.file_url = file_url
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.file_url is not None:
            result['fileUrl'] = self.file_url
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('fileUrl') is not None:
            self.file_url = m.get('fileUrl')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetPipelineEmasArtifactUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineEmasArtifactUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineEmasArtifactUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineGroupResponseBodyPipelineGroup(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        name: str = None,
    ):
        self.create_time = create_time
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetPipelineGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipeline_group: GetPipelineGroupResponseBodyPipelineGroup = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipeline_group = pipeline_group
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.pipeline_group:
            self.pipeline_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.pipeline_group is not None:
            result['pipelineGroup'] = self.pipeline_group.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('pipelineGroup') is not None:
            temp_model = GetPipelineGroupResponseBodyPipelineGroup()
            self.pipeline_group = temp_model.from_map(m['pipelineGroup'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetPipelineGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineRunResponseBodyPipelineRunSourcesData(TeaModel):
    def __init__(
        self,
        branch: str = None,
        commint: str = None,
        repo: str = None,
    ):
        self.branch = branch
        self.commint = commint
        self.repo = repo

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch is not None:
            result['branch'] = self.branch
        if self.commint is not None:
            result['commint'] = self.commint
        if self.repo is not None:
            result['repo'] = self.repo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('commint') is not None:
            self.commint = m.get('commint')
        if m.get('repo') is not None:
            self.repo = m.get('repo')
        return self


class GetPipelineRunResponseBodyPipelineRunSources(TeaModel):
    def __init__(
        self,
        data: GetPipelineRunResponseBodyPipelineRunSourcesData = None,
        sign: str = None,
        type: str = None,
    ):
        self.data = data
        self.sign = sign
        self.type = type

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.sign is not None:
            result['sign'] = self.sign
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            temp_model = GetPipelineRunResponseBodyPipelineRunSourcesData()
            self.data = temp_model.from_map(m['data'])
        if m.get('sign') is not None:
            self.sign = m.get('sign')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions(TeaModel):
    def __init__(
        self,
        disable: bool = None,
        params: Dict[str, Any] = None,
        type: str = None,
    ):
        self.disable = disable
        self.params = params
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable is not None:
            result['disable'] = self.disable
        if self.params is not None:
            result['params'] = self.params
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable') is not None:
            self.disable = m.get('disable')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs(TeaModel):
    def __init__(
        self,
        actions: List[GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions] = None,
        end_time: int = None,
        id: int = None,
        name: str = None,
        params: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.actions = actions
        self.end_time = end_time
        self.id = id
        self.name = name
        self.params = params
        self.start_time = start_time
        self.status = status

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.params is not None:
            result['params'] = self.params
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GetPipelineRunResponseBodyPipelineRunStagesStageInfo(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        jobs: List[GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs] = None,
        name: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.end_time = end_time
        self.jobs = jobs
        self.name = name
        self.start_time = start_time
        self.status = status

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        result['jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['jobs'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        self.jobs = []
        if m.get('jobs') is not None:
            for k in m.get('jobs'):
                temp_model = GetPipelineRunResponseBodyPipelineRunStagesStageInfoJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GetPipelineRunResponseBodyPipelineRunStages(TeaModel):
    def __init__(
        self,
        name: str = None,
        stage_info: GetPipelineRunResponseBodyPipelineRunStagesStageInfo = None,
    ):
        self.name = name
        self.stage_info = stage_info

    def validate(self):
        if self.stage_info:
            self.stage_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.stage_info is not None:
            result['stageInfo'] = self.stage_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stageInfo') is not None:
            temp_model = GetPipelineRunResponseBodyPipelineRunStagesStageInfo()
            self.stage_info = temp_model.from_map(m['stageInfo'])
        return self


class GetPipelineRunResponseBodyPipelineRun(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_account_id: str = None,
        modifier_account_id: str = None,
        pipeline_id: int = None,
        pipeline_run_id: int = None,
        sources: List[GetPipelineRunResponseBodyPipelineRunSources] = None,
        stage_group: List[List[str]] = None,
        stages: List[GetPipelineRunResponseBodyPipelineRunStages] = None,
        status: str = None,
        trigger_mode: int = None,
        update_time: int = None,
    ):
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.modifier_account_id = modifier_account_id
        self.pipeline_id = pipeline_id
        self.pipeline_run_id = pipeline_run_id
        self.sources = sources
        self.stage_group = stage_group
        self.stages = stages
        self.status = status
        self.trigger_mode = trigger_mode
        self.update_time = update_time

    def validate(self):
        if self.sources:
            for k in self.sources:
                if k:
                    k.validate()
        if self.stages:
            for k in self.stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_run_id is not None:
            result['pipelineRunId'] = self.pipeline_run_id
        result['sources'] = []
        if self.sources is not None:
            for k in self.sources:
                result['sources'].append(k.to_map() if k else None)
        if self.stage_group is not None:
            result['stageGroup'] = self.stage_group
        result['stages'] = []
        if self.stages is not None:
            for k in self.stages:
                result['stages'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.trigger_mode is not None:
            result['triggerMode'] = self.trigger_mode
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineRunId') is not None:
            self.pipeline_run_id = m.get('pipelineRunId')
        self.sources = []
        if m.get('sources') is not None:
            for k in m.get('sources'):
                temp_model = GetPipelineRunResponseBodyPipelineRunSources()
                self.sources.append(temp_model.from_map(k))
        if m.get('stageGroup') is not None:
            self.stage_group = m.get('stageGroup')
        self.stages = []
        if m.get('stages') is not None:
            for k in m.get('stages'):
                temp_model = GetPipelineRunResponseBodyPipelineRunStages()
                self.stages.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('triggerMode') is not None:
            self.trigger_mode = m.get('triggerMode')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetPipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipeline_run: GetPipelineRunResponseBodyPipelineRun = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipeline_run = pipeline_run
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.pipeline_run:
            self.pipeline_run.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.pipeline_run is not None:
            result['pipelineRun'] = self.pipeline_run.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('pipelineRun') is not None:
            temp_model = GetPipelineRunResponseBodyPipelineRun()
            self.pipeline_run = temp_model.from_map(m['pipelineRun'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetPipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineScanReportUrlRequest(TeaModel):
    def __init__(
        self,
        report_path: str = None,
    ):
        # This parameter is required.
        self.report_path = report_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.report_path is not None:
            result['reportPath'] = self.report_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('reportPath') is not None:
            self.report_path = m.get('reportPath')
        return self


class GetPipelineScanReportUrlResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        report_url: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.report_url = report_url
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.report_url is not None:
            result['reportUrl'] = self.report_url
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('reportUrl') is not None:
            self.report_url = m.get('reportUrl')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetPipelineScanReportUrlResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetPipelineScanReportUrlResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineScanReportUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectInfoResponseBodyProject(TeaModel):
    def __init__(
        self,
        category: str = None,
        category_identifier: str = None,
        creator: str = None,
        custom_code: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        icon: str = None,
        icon_big: str = None,
        icon_group: str = None,
        icon_small: str = None,
        id: str = None,
        identifier: str = None,
        identifier_path: str = None,
        logical_status: str = None,
        modifier: str = None,
        name: str = None,
        organization_identifier: str = None,
        parent_identifier: str = None,
        scope: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        sub_type: str = None,
        type_identifier: str = None,
    ):
        self.category = category
        self.category_identifier = category_identifier
        self.creator = creator
        self.custom_code = custom_code
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.icon = icon
        self.icon_big = icon_big
        self.icon_group = icon_group
        self.icon_small = icon_small
        self.id = id
        self.identifier = identifier
        self.identifier_path = identifier_path
        self.logical_status = logical_status
        self.modifier = modifier
        self.name = name
        self.organization_identifier = organization_identifier
        self.parent_identifier = parent_identifier
        self.scope = scope
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.sub_type = sub_type
        self.type_identifier = type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.custom_code is not None:
            result['customCode'] = self.custom_code
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.icon is not None:
            result['icon'] = self.icon
        if self.icon_big is not None:
            result['iconBig'] = self.icon_big
        if self.icon_group is not None:
            result['iconGroup'] = self.icon_group
        if self.icon_small is not None:
            result['iconSmall'] = self.icon_small
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.identifier_path is not None:
            result['identifierPath'] = self.identifier_path
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.organization_identifier is not None:
            result['organizationIdentifier'] = self.organization_identifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.scope is not None:
            result['scope'] = self.scope
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.type_identifier is not None:
            result['typeIdentifier'] = self.type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('customCode') is not None:
            self.custom_code = m.get('customCode')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('iconBig') is not None:
            self.icon_big = m.get('iconBig')
        if m.get('iconGroup') is not None:
            self.icon_group = m.get('iconGroup')
        if m.get('iconSmall') is not None:
            self.icon_small = m.get('iconSmall')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('identifierPath') is not None:
            self.identifier_path = m.get('identifierPath')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationIdentifier') is not None:
            self.organization_identifier = m.get('organizationIdentifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('typeIdentifier') is not None:
            self.type_identifier = m.get('typeIdentifier')
        return self


class GetProjectInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        project: GetProjectInfoResponseBodyProject = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.project = project
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.project is not None:
            result['project'] = self.project.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('project') is not None:
            temp_model = GetProjectInfoResponseBodyProject()
            self.project = temp_model.from_map(m['project'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetProjectInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetProjectMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetProjectMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetProjectMemberResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetProjectMemberResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetReleaseStagePipelineRunRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData(TeaModel):
    def __init__(
        self,
        branch: str = None,
        commit: str = None,
        repo: str = None,
    ):
        self.branch = branch
        self.commit = commit
        self.repo = repo

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch is not None:
            result['branch'] = self.branch
        if self.commit is not None:
            result['commit'] = self.commit
        if self.repo is not None:
            result['repo'] = self.repo
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('commit') is not None:
            self.commit = m.get('commit')
        if m.get('repo') is not None:
            self.repo = m.get('repo')
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRunSources(TeaModel):
    def __init__(
        self,
        data: GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData = None,
        sign: str = None,
        type: str = None,
    ):
        self.data = data
        self.sign = sign
        self.type = type

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.sign is not None:
            result['sign'] = self.sign
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRunSourcesData()
            self.data = temp_model.from_map(m['data'])
        if m.get('sign') is not None:
            self.sign = m.get('sign')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions(TeaModel):
    def __init__(
        self,
        disable: bool = None,
        params: Any = None,
        type: str = None,
    ):
        self.disable = disable
        self.params = params
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable is not None:
            result['disable'] = self.disable
        if self.params is not None:
            result['params'] = self.params
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable') is not None:
            self.disable = m.get('disable')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs(TeaModel):
    def __init__(
        self,
        actions: List[GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions] = None,
        end_time: int = None,
        id: int = None,
        name: str = None,
        params: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.actions = actions
        self.end_time = end_time
        self.id = id
        self.name = name
        self.params = params
        self.start_time = start_time
        self.status = status

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.params is not None:
            result['params'] = self.params
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobsActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        jobs: List[GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs] = None,
        name: str = None,
        start_time: int = None,
        status: str = None,
    ):
        self.end_time = end_time
        self.jobs = jobs
        self.name = name
        self.start_time = start_time
        self.status = status

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        result['jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['jobs'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        self.jobs = []
        if m.get('jobs') is not None:
            for k in m.get('jobs'):
                temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfoJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRunStages(TeaModel):
    def __init__(
        self,
        name: str = None,
        stage_info: GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo = None,
    ):
        self.name = name
        self.stage_info = stage_info

    def validate(self):
        if self.stage_info:
            self.stage_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.stage_info is not None:
            result['stageInfo'] = self.stage_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stageInfo') is not None:
            temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRunStagesStageInfo()
            self.stage_info = temp_model.from_map(m['stageInfo'])
        return self


class GetReleaseStagePipelineRunResponseBodyPipelineRun(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_account_id: str = None,
        modifier_account_id: str = None,
        pipeline_id: int = None,
        pipeline_run_id: int = None,
        sources: List[GetReleaseStagePipelineRunResponseBodyPipelineRunSources] = None,
        stage_group: List[List[str]] = None,
        stages: List[GetReleaseStagePipelineRunResponseBodyPipelineRunStages] = None,
        status: str = None,
        trigger_mode: int = None,
        update_time: int = None,
    ):
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.modifier_account_id = modifier_account_id
        self.pipeline_id = pipeline_id
        self.pipeline_run_id = pipeline_run_id
        self.sources = sources
        self.stage_group = stage_group
        self.stages = stages
        self.status = status
        self.trigger_mode = trigger_mode
        self.update_time = update_time

    def validate(self):
        if self.sources:
            for k in self.sources:
                if k:
                    k.validate()
        if self.stages:
            for k in self.stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_run_id is not None:
            result['pipelineRunId'] = self.pipeline_run_id
        result['sources'] = []
        if self.sources is not None:
            for k in self.sources:
                result['sources'].append(k.to_map() if k else None)
        if self.stage_group is not None:
            result['stageGroup'] = self.stage_group
        result['stages'] = []
        if self.stages is not None:
            for k in self.stages:
                result['stages'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.trigger_mode is not None:
            result['triggerMode'] = self.trigger_mode
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineRunId') is not None:
            self.pipeline_run_id = m.get('pipelineRunId')
        self.sources = []
        if m.get('sources') is not None:
            for k in m.get('sources'):
                temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRunSources()
                self.sources.append(temp_model.from_map(k))
        if m.get('stageGroup') is not None:
            self.stage_group = m.get('stageGroup')
        self.stages = []
        if m.get('stages') is not None:
            for k in m.get('stages'):
                temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRunStages()
                self.stages.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('triggerMode') is not None:
            self.trigger_mode = m.get('triggerMode')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetReleaseStagePipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        pipeline_run: GetReleaseStagePipelineRunResponseBodyPipelineRun = None,
    ):
        self.pipeline_run = pipeline_run

    def validate(self):
        if self.pipeline_run:
            self.pipeline_run.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_run is not None:
            result['pipelineRun'] = self.pipeline_run.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pipelineRun') is not None:
            temp_model = GetReleaseStagePipelineRunResponseBodyPipelineRun()
            self.pipeline_run = temp_model.from_map(m['pipelineRun'])
        return self


class GetReleaseStagePipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetReleaseStagePipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetReleaseStagePipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRepositoryRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        identity: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.identity = identity
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.identity is not None:
            result['identity'] = self.identity
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetRepositoryResponseBodyRepositoryNamespace(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        created_at: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        owner_id: int = None,
        path: str = None,
        updated_at: str = None,
        visibility_level: int = None,
    ):
        self.avatar = avatar
        self.created_at = created_at
        self.description = description
        # id
        self.id = id
        self.name = name
        self.owner_id = owner_id
        self.path = path
        self.updated_at = updated_at
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.path is not None:
            result['path'] = self.path
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class GetRepositoryResponseBodyRepository(TeaModel):
    def __init__(
        self,
        archive: bool = None,
        avatar_url: str = None,
        created_at: str = None,
        creator_id: int = None,
        default_branch: str = None,
        demo_project_status: bool = None,
        description: str = None,
        http_url_to_repository: str = None,
        id: int = None,
        last_activity_at: str = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace: GetRepositoryResponseBodyRepositoryNamespace = None,
        path: str = None,
        path_with_namespace: str = None,
        ssh_url_to_repository: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.archive = archive
        self.avatar_url = avatar_url
        self.created_at = created_at
        self.creator_id = creator_id
        self.default_branch = default_branch
        self.demo_project_status = demo_project_status
        self.description = description
        self.http_url_to_repository = http_url_to_repository
        self.id = id
        self.last_activity_at = last_activity_at
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace = namespace
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.ssh_url_to_repository = ssh_url_to_repository
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        if self.namespace:
            self.namespace.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archive is not None:
            result['archive'] = self.archive
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.default_branch is not None:
            result['defaultBranch'] = self.default_branch
        if self.demo_project_status is not None:
            result['demoProjectStatus'] = self.demo_project_status
        if self.description is not None:
            result['description'] = self.description
        if self.http_url_to_repository is not None:
            result['httpUrlToRepository'] = self.http_url_to_repository
        if self.id is not None:
            result['id'] = self.id
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace is not None:
            result['namespace'] = self.namespace.to_map()
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.ssh_url_to_repository is not None:
            result['sshUrlToRepository'] = self.ssh_url_to_repository
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('archive') is not None:
            self.archive = m.get('archive')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('defaultBranch') is not None:
            self.default_branch = m.get('defaultBranch')
        if m.get('demoProjectStatus') is not None:
            self.demo_project_status = m.get('demoProjectStatus')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('httpUrlToRepository') is not None:
            self.http_url_to_repository = m.get('httpUrlToRepository')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespace') is not None:
            temp_model = GetRepositoryResponseBodyRepositoryNamespace()
            self.namespace = temp_model.from_map(m['namespace'])
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('sshUrlToRepository') is not None:
            self.ssh_url_to_repository = m.get('sshUrlToRepository')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class GetRepositoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        repository: GetRepositoryResponseBodyRepository = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.repository = repository
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.repository:
            self.repository.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.repository is not None:
            result['repository'] = self.repository.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('repository') is not None:
            temp_model = GetRepositoryResponseBodyRepository()
            self.repository = temp_model.from_map(m['repository'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetRepositoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRepositoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRepositoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRepositoryCommitRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        show_signature: bool = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.show_signature = show_signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.show_signature is not None:
            result['showSignature'] = self.show_signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('showSignature') is not None:
            self.show_signature = m.get('showSignature')
        return self


class GetRepositoryCommitResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
        website_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username
        self.website_url = website_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.website_url is not None:
            result['websiteUrl'] = self.website_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('websiteUrl') is not None:
            self.website_url = m.get('websiteUrl')
        return self


class GetRepositoryCommitResponseBodyResultCommitter(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
        website_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username
        self.website_url = website_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.website_url is not None:
            result['websiteUrl'] = self.website_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('websiteUrl') is not None:
            self.website_url = m.get('websiteUrl')
        return self


class GetRepositoryCommitResponseBodyResultSignature(TeaModel):
    def __init__(
        self,
        gpg_key_id: str = None,
        verification_status: str = None,
    ):
        self.gpg_key_id = gpg_key_id
        self.verification_status = verification_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gpg_key_id is not None:
            result['gpgKeyId'] = self.gpg_key_id
        if self.verification_status is not None:
            result['verificationStatus'] = self.verification_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gpgKeyId') is not None:
            self.gpg_key_id = m.get('gpgKeyId')
        if m.get('verificationStatus') is not None:
            self.verification_status = m.get('verificationStatus')
        return self


class GetRepositoryCommitResponseBodyResult(TeaModel):
    def __init__(
        self,
        author: GetRepositoryCommitResponseBodyResultAuthor = None,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        comments_count: int = None,
        committed_date: str = None,
        committer: GetRepositoryCommitResponseBodyResultCommitter = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        signature: GetRepositoryCommitResponseBodyResultSignature = None,
        title: str = None,
    ):
        self.author = author
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.comments_count = comments_count
        self.committed_date = committed_date
        self.committer = committer
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.signature = signature
        self.title = title

    def validate(self):
        if self.author:
            self.author.validate()
        if self.committer:
            self.committer.validate()
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.comments_count is not None:
            result['commentsCount'] = self.comments_count
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer is not None:
            result['committer'] = self.committer.to_map()
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = GetRepositoryCommitResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('commentsCount') is not None:
            self.comments_count = m.get('commentsCount')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committer') is not None:
            temp_model = GetRepositoryCommitResponseBodyResultCommitter()
            self.committer = temp_model.from_map(m['committer'])
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('signature') is not None:
            temp_model = GetRepositoryCommitResponseBodyResultSignature()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetRepositoryCommitResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetRepositoryCommitResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetRepositoryCommitResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetRepositoryCommitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRepositoryCommitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRepositoryCommitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetRepositoryTagRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        tag_name: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.tag_name = tag_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.tag_name is not None:
            result['tagName'] = self.tag_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('tagName') is not None:
            self.tag_name = m.get('tagName')
        return self


class GetRepositoryTagResponseBodyResultCommitSignature(TeaModel):
    def __init__(
        self,
        gpg_key_id: str = None,
        verification_status: str = None,
    ):
        self.gpg_key_id = gpg_key_id
        self.verification_status = verification_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gpg_key_id is not None:
            result['gpgKeyId'] = self.gpg_key_id
        if self.verification_status is not None:
            result['verificationStatus'] = self.verification_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gpgKeyId') is not None:
            self.gpg_key_id = m.get('gpgKeyId')
        if m.get('verificationStatus') is not None:
            self.verification_status = m.get('verificationStatus')
        return self


class GetRepositoryTagResponseBodyResultCommit(TeaModel):
    def __init__(
        self,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        committed_date: str = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        signature: GetRepositoryTagResponseBodyResultCommitSignature = None,
        title: str = None,
    ):
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.committed_date = committed_date
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.signature = signature
        self.title = title

    def validate(self):
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('signature') is not None:
            temp_model = GetRepositoryTagResponseBodyResultCommitSignature()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetRepositoryTagResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit: GetRepositoryTagResponseBodyResultCommit = None,
        id: str = None,
        message: str = None,
        name: str = None,
    ):
        self.commit = commit
        self.id = id
        self.message = message
        self.name = name

    def validate(self):
        if self.commit:
            self.commit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit is not None:
            result['commit'] = self.commit.to_map()
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commit') is not None:
            temp_model = GetRepositoryTagResponseBodyResultCommit()
            self.commit = temp_model.from_map(m['commit'])
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetRepositoryTagResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetRepositoryTagResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetRepositoryTagResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetRepositoryTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetRepositoryTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetRepositoryTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSearchCodePreviewRequest(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        is_dsl: bool = None,
        keyword: str = None,
        organization_id: str = None,
    ):
        # This parameter is required.
        self.doc_id = doc_id
        self.is_dsl = is_dsl
        # This parameter is required.
        self.keyword = keyword
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['docId'] = self.doc_id
        if self.is_dsl is not None:
            result['isDsl'] = self.is_dsl
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('docId') is not None:
            self.doc_id = m.get('docId')
        if m.get('isDsl') is not None:
            self.is_dsl = m.get('isDsl')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetSearchCodePreviewResponseBodyResultHighlightTextMap(TeaModel):
    def __init__(
        self,
        clob: str = None,
        file_name: str = None,
        organization_id: str = None,
    ):
        self.clob = clob
        self.file_name = file_name
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clob is not None:
            result['clob'] = self.clob
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clob') is not None:
            self.clob = m.get('clob')
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetSearchCodePreviewResponseBodyResultSource(TeaModel):
    def __init__(
        self,
        branch: str = None,
        checkin_date: str = None,
        file_name: str = None,
        file_path: str = None,
        language: str = None,
        organization_id: str = None,
        repo_path: str = None,
    ):
        self.branch = branch
        self.checkin_date = checkin_date
        self.file_name = file_name
        self.file_path = file_path
        self.language = language
        self.organization_id = organization_id
        self.repo_path = repo_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch is not None:
            result['branch'] = self.branch
        if self.checkin_date is not None:
            result['checkinDate'] = self.checkin_date
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.language is not None:
            result['language'] = self.language
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('checkinDate') is not None:
            self.checkin_date = m.get('checkinDate')
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repoPath') is not None:
            self.repo_path = m.get('repoPath')
        return self


class GetSearchCodePreviewResponseBodyResult(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        highlight_text_map: GetSearchCodePreviewResponseBodyResultHighlightTextMap = None,
        source: GetSearchCodePreviewResponseBodyResultSource = None,
    ):
        self.doc_id = doc_id
        self.highlight_text_map = highlight_text_map
        self.source = source

    def validate(self):
        if self.highlight_text_map:
            self.highlight_text_map.validate()
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['docId'] = self.doc_id
        if self.highlight_text_map is not None:
            result['highlightTextMap'] = self.highlight_text_map.to_map()
        if self.source is not None:
            result['source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('docId') is not None:
            self.doc_id = m.get('docId')
        if m.get('highlightTextMap') is not None:
            temp_model = GetSearchCodePreviewResponseBodyResultHighlightTextMap()
            self.highlight_text_map = temp_model.from_map(m['highlightTextMap'])
        if m.get('source') is not None:
            temp_model = GetSearchCodePreviewResponseBodyResultSource()
            self.source = temp_model.from_map(m['source'])
        return self


class GetSearchCodePreviewResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetSearchCodePreviewResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetSearchCodePreviewResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetSearchCodePreviewResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSearchCodePreviewResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSearchCodePreviewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSprintInfoResponseBodySprint(TeaModel):
    def __init__(
        self,
        creator: str = None,
        description: str = None,
        end_date: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        owners: List[str] = None,
        scope: str = None,
        space_identifier: str = None,
        start_date: int = None,
        status: str = None,
    ):
        self.creator = creator
        self.description = description
        self.end_date = end_date
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.owners = owners
        self.scope = scope
        self.space_identifier = space_identifier
        self.start_date = start_date
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.owners is not None:
            result['owners'] = self.owners
        if self.scope is not None:
            result['scope'] = self.scope
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('owners') is not None:
            self.owners = m.get('owners')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class GetSprintInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        sprint: GetSprintInfoResponseBodySprint = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.sprint = sprint
        self.success = success

    def validate(self):
        if self.sprint:
            self.sprint.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.sprint is not None:
            result['sprint'] = self.sprint.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sprint') is not None:
            temp_model = GetSprintInfoResponseBodySprint()
            self.sprint = temp_model.from_map(m['sprint'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetSprintInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetSprintInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSprintInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTestResultListRequest(TeaModel):
    def __init__(
        self,
        conditions: str = None,
        directory_identifier: str = None,
    ):
        self.conditions = conditions
        # This parameter is required.
        self.directory_identifier = directory_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conditions is not None:
            result['conditions'] = self.conditions
        if self.directory_identifier is not None:
            result['directoryIdentifier'] = self.directory_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('conditions') is not None:
            self.conditions = m.get('conditions')
        if m.get('directoryIdentifier') is not None:
            self.directory_identifier = m.get('directoryIdentifier')
        return self


class GetTestResultListResponseBodyTestResultAssignedTo(TeaModel):
    def __init__(
        self,
        assigned_to_identtifier: str = None,
        name: str = None,
    ):
        self.assigned_to_identtifier = assigned_to_identtifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to_identtifier is not None:
            result['assignedToIdenttifier'] = self.assigned_to_identtifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedToIdenttifier') is not None:
            self.assigned_to_identtifier = m.get('assignedToIdenttifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetTestResultListResponseBodyTestResultCustomFields(TeaModel):
    def __init__(
        self,
        field_class_name: str = None,
        field_format: str = None,
        field_identifier: str = None,
        value: str = None,
    ):
        self.field_class_name = field_class_name
        self.field_format = field_format
        self.field_identifier = field_identifier
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_class_name is not None:
            result['fieldClassName'] = self.field_class_name
        if self.field_format is not None:
            result['fieldFormat'] = self.field_format
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldClassName') is not None:
            self.field_class_name = m.get('fieldClassName')
        if m.get('fieldFormat') is not None:
            self.field_format = m.get('fieldFormat')
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetTestResultListResponseBodyTestResultTestResultExecutor(TeaModel):
    def __init__(
        self,
        executor_identifier: str = None,
        name: str = None,
    ):
        self.executor_identifier = executor_identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.executor_identifier is not None:
            result['executorIdentifier'] = self.executor_identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('executorIdentifier') is not None:
            self.executor_identifier = m.get('executorIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetTestResultListResponseBodyTestResult(TeaModel):
    def __init__(
        self,
        assigned_to: GetTestResultListResponseBodyTestResultAssignedTo = None,
        bug_count: int = None,
        category_identifier: str = None,
        custom_fields: List[GetTestResultListResponseBodyTestResultCustomFields] = None,
        gmt_create: int = None,
        space_identifier: str = None,
        subject: str = None,
        test_result_executor: GetTestResultListResponseBodyTestResultTestResultExecutor = None,
        test_result_gmt_create: int = None,
        test_result_identifier: str = None,
        test_result_status: str = None,
        testcase_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.bug_count = bug_count
        self.category_identifier = category_identifier
        self.custom_fields = custom_fields
        self.gmt_create = gmt_create
        self.space_identifier = space_identifier
        self.subject = subject
        self.test_result_executor = test_result_executor
        self.test_result_gmt_create = test_result_gmt_create
        self.test_result_identifier = test_result_identifier
        self.test_result_status = test_result_status
        self.testcase_identifier = testcase_identifier

    def validate(self):
        if self.assigned_to:
            self.assigned_to.validate()
        if self.custom_fields:
            for k in self.custom_fields:
                if k:
                    k.validate()
        if self.test_result_executor:
            self.test_result_executor.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to.to_map()
        if self.bug_count is not None:
            result['bugCount'] = self.bug_count
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        result['customFields'] = []
        if self.custom_fields is not None:
            for k in self.custom_fields:
                result['customFields'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.test_result_executor is not None:
            result['testResultExecutor'] = self.test_result_executor.to_map()
        if self.test_result_gmt_create is not None:
            result['testResultGmtCreate'] = self.test_result_gmt_create
        if self.test_result_identifier is not None:
            result['testResultIdentifier'] = self.test_result_identifier
        if self.test_result_status is not None:
            result['testResultStatus'] = self.test_result_status
        if self.testcase_identifier is not None:
            result['testcaseIdentifier'] = self.testcase_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            temp_model = GetTestResultListResponseBodyTestResultAssignedTo()
            self.assigned_to = temp_model.from_map(m['assignedTo'])
        if m.get('bugCount') is not None:
            self.bug_count = m.get('bugCount')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        self.custom_fields = []
        if m.get('customFields') is not None:
            for k in m.get('customFields'):
                temp_model = GetTestResultListResponseBodyTestResultCustomFields()
                self.custom_fields.append(temp_model.from_map(k))
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('testResultExecutor') is not None:
            temp_model = GetTestResultListResponseBodyTestResultTestResultExecutor()
            self.test_result_executor = temp_model.from_map(m['testResultExecutor'])
        if m.get('testResultGmtCreate') is not None:
            self.test_result_gmt_create = m.get('testResultGmtCreate')
        if m.get('testResultIdentifier') is not None:
            self.test_result_identifier = m.get('testResultIdentifier')
        if m.get('testResultStatus') is not None:
            self.test_result_status = m.get('testResultStatus')
        if m.get('testcaseIdentifier') is not None:
            self.testcase_identifier = m.get('testcaseIdentifier')
        return self


class GetTestResultListResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        test_result: List[GetTestResultListResponseBodyTestResult] = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success
        self.test_result = test_result

    def validate(self):
        if self.test_result:
            for k in self.test_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['testResult'] = []
        if self.test_result is not None:
            for k in self.test_result:
                result['testResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.test_result = []
        if m.get('testResult') is not None:
            for k in m.get('testResult'):
                temp_model = GetTestResultListResponseBodyTestResult()
                self.test_result.append(temp_model.from_map(k))
        return self


class GetTestResultListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTestResultListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTestResultListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTestcaseListRequest(TeaModel):
    def __init__(
        self,
        conditions: str = None,
        directory_identifier: str = None,
        max_result: str = None,
        next_token: str = None,
        space_identifier: str = None,
    ):
        self.conditions = conditions
        self.directory_identifier = directory_identifier
        self.max_result = max_result
        self.next_token = next_token
        # This parameter is required.
        self.space_identifier = space_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.conditions is not None:
            result['conditions'] = self.conditions
        if self.directory_identifier is not None:
            result['directoryIdentifier'] = self.directory_identifier
        if self.max_result is not None:
            result['maxResult'] = self.max_result
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('conditions') is not None:
            self.conditions = m.get('conditions')
        if m.get('directoryIdentifier') is not None:
            self.directory_identifier = m.get('directoryIdentifier')
        if m.get('maxResult') is not None:
            self.max_result = m.get('maxResult')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        return self


class GetTestcaseListResponseBodyTestcaseAssignedTo(TeaModel):
    def __init__(
        self,
        assigned_to_identtifier: str = None,
        name: str = None,
    ):
        self.assigned_to_identtifier = assigned_to_identtifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to_identtifier is not None:
            result['assignedToIdenttifier'] = self.assigned_to_identtifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedToIdenttifier') is not None:
            self.assigned_to_identtifier = m.get('assignedToIdenttifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetTestcaseListResponseBodyTestcaseCustomFields(TeaModel):
    def __init__(
        self,
        field_class_name: str = None,
        field_format: str = None,
        field_identifier: str = None,
        value: str = None,
    ):
        self.field_class_name = field_class_name
        self.field_format = field_format
        self.field_identifier = field_identifier
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_class_name is not None:
            result['fieldClassName'] = self.field_class_name
        if self.field_format is not None:
            result['fieldFormat'] = self.field_format
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldClassName') is not None:
            self.field_class_name = m.get('fieldClassName')
        if m.get('fieldFormat') is not None:
            self.field_format = m.get('fieldFormat')
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetTestcaseListResponseBodyTestcaseSpace(TeaModel):
    def __init__(
        self,
        space_identifier: str = None,
        type: str = None,
    ):
        self.space_identifier = space_identifier
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetTestcaseListResponseBodyTestcaseTags(TeaModel):
    def __init__(
        self,
        name: str = None,
        tag_identifier: str = None,
    ):
        self.name = name
        self.tag_identifier = tag_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.tag_identifier is not None:
            result['tagIdentifier'] = self.tag_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tagIdentifier') is not None:
            self.tag_identifier = m.get('tagIdentifier')
        return self


class GetTestcaseListResponseBodyTestcase(TeaModel):
    def __init__(
        self,
        assigned_to: GetTestcaseListResponseBodyTestcaseAssignedTo = None,
        category_identifier: str = None,
        custom_fields: List[GetTestcaseListResponseBodyTestcaseCustomFields] = None,
        gmt_create: int = None,
        identifier: str = None,
        space: GetTestcaseListResponseBodyTestcaseSpace = None,
        subject: str = None,
        tags: List[GetTestcaseListResponseBodyTestcaseTags] = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.custom_fields = custom_fields
        self.gmt_create = gmt_create
        self.identifier = identifier
        self.space = space
        self.subject = subject
        self.tags = tags

    def validate(self):
        if self.assigned_to:
            self.assigned_to.validate()
        if self.custom_fields:
            for k in self.custom_fields:
                if k:
                    k.validate()
        if self.space:
            self.space.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to.to_map()
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        result['customFields'] = []
        if self.custom_fields is not None:
            for k in self.custom_fields:
                result['customFields'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.space is not None:
            result['space'] = self.space.to_map()
        if self.subject is not None:
            result['subject'] = self.subject
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            temp_model = GetTestcaseListResponseBodyTestcaseAssignedTo()
            self.assigned_to = temp_model.from_map(m['assignedTo'])
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        self.custom_fields = []
        if m.get('customFields') is not None:
            for k in m.get('customFields'):
                temp_model = GetTestcaseListResponseBodyTestcaseCustomFields()
                self.custom_fields.append(temp_model.from_map(k))
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('space') is not None:
            temp_model = GetTestcaseListResponseBodyTestcaseSpace()
            self.space = temp_model.from_map(m['space'])
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = GetTestcaseListResponseBodyTestcaseTags()
                self.tags.append(temp_model.from_map(k))
        return self


class GetTestcaseListResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        testcase: List[GetTestcaseListResponseBodyTestcase] = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.testcase = testcase
        self.total_count = total_count

    def validate(self):
        if self.testcase:
            for k in self.testcase:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['testcase'] = []
        if self.testcase is not None:
            for k in self.testcase:
                result['testcase'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.testcase = []
        if m.get('testcase') is not None:
            for k in m.get('testcase'):
                temp_model = GetTestcaseListResponseBodyTestcase()
                self.testcase.append(temp_model.from_map(k))
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class GetTestcaseListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetTestcaseListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTestcaseListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUserInfoRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class GetUserInfoResponseBodyResult(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class GetUserInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: GetUserInfoResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = GetUserInfoResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetUserInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetUserInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUserInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVMDeployOrderResponseBodyDeployOrderActions(TeaModel):
    def __init__(
        self,
        disable: bool = None,
        params: Any = None,
        type: str = None,
    ):
        self.disable = disable
        self.params = params
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable is not None:
            result['disable'] = self.disable
        if self.params is not None:
            result['params'] = self.params
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable') is not None:
            self.disable = m.get('disable')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions(TeaModel):
    def __init__(
        self,
        disable: bool = None,
        params: Any = None,
        type: str = None,
    ):
        self.disable = disable
        self.params = params
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disable is not None:
            result['disable'] = self.disable
        if self.params is not None:
            result['params'] = self.params
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('disable') is not None:
            self.disable = m.get('disable')
        if m.get('params') is not None:
            self.params = m.get('params')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines(TeaModel):
    def __init__(
        self,
        actions: List[GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions] = None,
        batch_num: int = None,
        client_status: str = None,
        create_time: int = None,
        ip: str = None,
        machine_sn: str = None,
        status: str = None,
        update_time: int = None,
    ):
        self.actions = actions
        self.batch_num = batch_num
        self.client_status = client_status
        self.create_time = create_time
        self.ip = ip
        self.machine_sn = machine_sn
        self.status = status
        self.update_time = update_time

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.batch_num is not None:
            result['batchNum'] = self.batch_num
        if self.client_status is not None:
            result['clientStatus'] = self.client_status
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.ip is not None:
            result['ip'] = self.ip
        if self.machine_sn is not None:
            result['machineSn'] = self.machine_sn
        if self.status is not None:
            result['status'] = self.status
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachinesActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('batchNum') is not None:
            self.batch_num = m.get('batchNum')
        if m.get('clientStatus') is not None:
            self.client_status = m.get('clientStatus')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('machineSn') is not None:
            self.machine_sn = m.get('machineSn')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo(TeaModel):
    def __init__(
        self,
        batch_num: int = None,
        deploy_machines: List[GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines] = None,
        host_group_id: int = None,
    ):
        self.batch_num = batch_num
        self.deploy_machines = deploy_machines
        self.host_group_id = host_group_id

    def validate(self):
        if self.deploy_machines:
            for k in self.deploy_machines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_num is not None:
            result['batchNum'] = self.batch_num
        result['deployMachines'] = []
        if self.deploy_machines is not None:
            for k in self.deploy_machines:
                result['deployMachines'].append(k.to_map() if k else None)
        if self.host_group_id is not None:
            result['hostGroupId'] = self.host_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batchNum') is not None:
            self.batch_num = m.get('batchNum')
        self.deploy_machines = []
        if m.get('deployMachines') is not None:
            for k in m.get('deployMachines'):
                temp_model = GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfoDeployMachines()
                self.deploy_machines.append(temp_model.from_map(k))
        if m.get('hostGroupId') is not None:
            self.host_group_id = m.get('hostGroupId')
        return self


class GetVMDeployOrderResponseBodyDeployOrder(TeaModel):
    def __init__(
        self,
        actions: List[GetVMDeployOrderResponseBodyDeployOrderActions] = None,
        create_time: int = None,
        creator: str = None,
        current_batch: int = None,
        deploy_machine_info: GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo = None,
        deploy_order_id: str = None,
        exception_code: str = None,
        status: str = None,
        total_batch: int = None,
        update_time: int = None,
    ):
        self.actions = actions
        self.create_time = create_time
        self.creator = creator
        self.current_batch = current_batch
        self.deploy_machine_info = deploy_machine_info
        self.deploy_order_id = deploy_order_id
        self.exception_code = exception_code
        self.status = status
        self.total_batch = total_batch
        self.update_time = update_time

    def validate(self):
        if self.actions:
            for k in self.actions:
                if k:
                    k.validate()
        if self.deploy_machine_info:
            self.deploy_machine_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['actions'] = []
        if self.actions is not None:
            for k in self.actions:
                result['actions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator is not None:
            result['creator'] = self.creator
        if self.current_batch is not None:
            result['currentBatch'] = self.current_batch
        if self.deploy_machine_info is not None:
            result['deployMachineInfo'] = self.deploy_machine_info.to_map()
        if self.deploy_order_id is not None:
            result['deployOrderId'] = self.deploy_order_id
        if self.exception_code is not None:
            result['exceptionCode'] = self.exception_code
        if self.status is not None:
            result['status'] = self.status
        if self.total_batch is not None:
            result['totalBatch'] = self.total_batch
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.actions = []
        if m.get('actions') is not None:
            for k in m.get('actions'):
                temp_model = GetVMDeployOrderResponseBodyDeployOrderActions()
                self.actions.append(temp_model.from_map(k))
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('currentBatch') is not None:
            self.current_batch = m.get('currentBatch')
        if m.get('deployMachineInfo') is not None:
            temp_model = GetVMDeployOrderResponseBodyDeployOrderDeployMachineInfo()
            self.deploy_machine_info = temp_model.from_map(m['deployMachineInfo'])
        if m.get('deployOrderId') is not None:
            self.deploy_order_id = m.get('deployOrderId')
        if m.get('exceptionCode') is not None:
            self.exception_code = m.get('exceptionCode')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('totalBatch') is not None:
            self.total_batch = m.get('totalBatch')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class GetVMDeployOrderResponseBody(TeaModel):
    def __init__(
        self,
        deploy_order: GetVMDeployOrderResponseBodyDeployOrder = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.deploy_order = deploy_order
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.deploy_order:
            self.deploy_order.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_order is not None:
            result['deployOrder'] = self.deploy_order.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deployOrder') is not None:
            temp_model = GetVMDeployOrderResponseBodyDeployOrder()
            self.deploy_order = temp_model.from_map(m['deployOrder'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetVMDeployOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVMDeployOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVMDeployOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetVariableGroupResponseBodyVariableGroupRelatedPipelines(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetVariableGroupResponseBodyVariableGroupVariables(TeaModel):
    def __init__(
        self,
        is_encrypted: bool = None,
        name: str = None,
        value: str = None,
    ):
        self.is_encrypted = is_encrypted
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_encrypted is not None:
            result['isEncrypted'] = self.is_encrypted
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isEncrypted') is not None:
            self.is_encrypted = m.get('isEncrypted')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class GetVariableGroupResponseBodyVariableGroup(TeaModel):
    def __init__(
        self,
        ccreator_account_id: str = None,
        create_time: int = None,
        description: str = None,
        id: int = None,
        modifier_account_id: str = None,
        name: str = None,
        related_pipelines: List[GetVariableGroupResponseBodyVariableGroupRelatedPipelines] = None,
        update_time: int = None,
        variables: List[GetVariableGroupResponseBodyVariableGroupVariables] = None,
    ):
        self.ccreator_account_id = ccreator_account_id
        self.create_time = create_time
        self.description = description
        self.id = id
        self.modifier_account_id = modifier_account_id
        self.name = name
        self.related_pipelines = related_pipelines
        self.update_time = update_time
        self.variables = variables

    def validate(self):
        if self.related_pipelines:
            for k in self.related_pipelines:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ccreator_account_id is not None:
            result['ccreatorAccountId'] = self.ccreator_account_id
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.name is not None:
            result['name'] = self.name
        result['relatedPipelines'] = []
        if self.related_pipelines is not None:
            for k in self.related_pipelines:
                result['relatedPipelines'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        result['variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ccreatorAccountId') is not None:
            self.ccreator_account_id = m.get('ccreatorAccountId')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.related_pipelines = []
        if m.get('relatedPipelines') is not None:
            for k in m.get('relatedPipelines'):
                temp_model = GetVariableGroupResponseBodyVariableGroupRelatedPipelines()
                self.related_pipelines.append(temp_model.from_map(k))
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        self.variables = []
        if m.get('variables') is not None:
            for k in m.get('variables'):
                temp_model = GetVariableGroupResponseBodyVariableGroupVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class GetVariableGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        variable_group: GetVariableGroupResponseBodyVariableGroup = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.variable_group = variable_group

    def validate(self):
        if self.variable_group:
            self.variable_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.variable_group is not None:
            result['variableGroup'] = self.variable_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('variableGroup') is not None:
            temp_model = GetVariableGroupResponseBodyVariableGroup()
            self.variable_group = temp_model.from_map(m['variableGroup'])
        return self


class GetVariableGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetVariableGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetVariableGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkItemActivityResponseBodyActivitiesNewValue(TeaModel):
    def __init__(
        self,
        display_value: str = None,
        plain_value: str = None,
        resource_type: str = None,
    ):
        self.display_value = display_value
        self.plain_value = plain_value
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_value is not None:
            result['displayValue'] = self.display_value
        if self.plain_value is not None:
            result['plainValue'] = self.plain_value
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayValue') is not None:
            self.display_value = m.get('displayValue')
        if m.get('plainValue') is not None:
            self.plain_value = m.get('plainValue')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        return self


class GetWorkItemActivityResponseBodyActivitiesOldValue(TeaModel):
    def __init__(
        self,
        display_value: str = None,
        plain_value: str = None,
        resource_type: str = None,
    ):
        self.display_value = display_value
        self.plain_value = plain_value
        self.resource_type = resource_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_value is not None:
            result['displayValue'] = self.display_value
        if self.plain_value is not None:
            result['plainValue'] = self.plain_value
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayValue') is not None:
            self.display_value = m.get('displayValue')
        if m.get('plainValue') is not None:
            self.plain_value = m.get('plainValue')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        return self


class GetWorkItemActivityResponseBodyActivitiesProperty(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        property_identifier: str = None,
        property_name: str = None,
        property_type: str = None,
    ):
        self.display_name = display_name
        self.property_identifier = property_identifier
        self.property_name = property_name
        self.property_type = property_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.property_identifier is not None:
            result['propertyIdentifier'] = self.property_identifier
        if self.property_name is not None:
            result['propertyName'] = self.property_name
        if self.property_type is not None:
            result['propertyType'] = self.property_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('propertyIdentifier') is not None:
            self.property_identifier = m.get('propertyIdentifier')
        if m.get('propertyName') is not None:
            self.property_name = m.get('propertyName')
        if m.get('propertyType') is not None:
            self.property_type = m.get('propertyType')
        return self


class GetWorkItemActivityResponseBodyActivities(TeaModel):
    def __init__(
        self,
        action_type: str = None,
        event_id: int = None,
        event_time: int = None,
        event_type: str = None,
        new_value: List[GetWorkItemActivityResponseBodyActivitiesNewValue] = None,
        old_value: List[GetWorkItemActivityResponseBodyActivitiesOldValue] = None,
        operator: str = None,
        parent_event_id: int = None,
        property: GetWorkItemActivityResponseBodyActivitiesProperty = None,
        resource_identifier: str = None,
    ):
        self.action_type = action_type
        self.event_id = event_id
        self.event_time = event_time
        self.event_type = event_type
        self.new_value = new_value
        self.old_value = old_value
        self.operator = operator
        self.parent_event_id = parent_event_id
        self.property = property
        self.resource_identifier = resource_identifier

    def validate(self):
        if self.new_value:
            for k in self.new_value:
                if k:
                    k.validate()
        if self.old_value:
            for k in self.old_value:
                if k:
                    k.validate()
        if self.property:
            self.property.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['actionType'] = self.action_type
        if self.event_id is not None:
            result['eventId'] = self.event_id
        if self.event_time is not None:
            result['eventTime'] = self.event_time
        if self.event_type is not None:
            result['eventType'] = self.event_type
        result['newValue'] = []
        if self.new_value is not None:
            for k in self.new_value:
                result['newValue'].append(k.to_map() if k else None)
        result['oldValue'] = []
        if self.old_value is not None:
            for k in self.old_value:
                result['oldValue'].append(k.to_map() if k else None)
        if self.operator is not None:
            result['operator'] = self.operator
        if self.parent_event_id is not None:
            result['parentEventId'] = self.parent_event_id
        if self.property is not None:
            result['property'] = self.property.to_map()
        if self.resource_identifier is not None:
            result['resourceIdentifier'] = self.resource_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actionType') is not None:
            self.action_type = m.get('actionType')
        if m.get('eventId') is not None:
            self.event_id = m.get('eventId')
        if m.get('eventTime') is not None:
            self.event_time = m.get('eventTime')
        if m.get('eventType') is not None:
            self.event_type = m.get('eventType')
        self.new_value = []
        if m.get('newValue') is not None:
            for k in m.get('newValue'):
                temp_model = GetWorkItemActivityResponseBodyActivitiesNewValue()
                self.new_value.append(temp_model.from_map(k))
        self.old_value = []
        if m.get('oldValue') is not None:
            for k in m.get('oldValue'):
                temp_model = GetWorkItemActivityResponseBodyActivitiesOldValue()
                self.old_value.append(temp_model.from_map(k))
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('parentEventId') is not None:
            self.parent_event_id = m.get('parentEventId')
        if m.get('property') is not None:
            temp_model = GetWorkItemActivityResponseBodyActivitiesProperty()
            self.property = temp_model.from_map(m['property'])
        if m.get('resourceIdentifier') is not None:
            self.resource_identifier = m.get('resourceIdentifier')
        return self


class GetWorkItemActivityResponseBody(TeaModel):
    def __init__(
        self,
        activities: List[GetWorkItemActivityResponseBodyActivities] = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.activities = activities
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.activities:
            for k in self.activities:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['activities'] = []
        if self.activities is not None:
            for k in self.activities:
                result['activities'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.activities = []
        if m.get('activities') is not None:
            for k in m.get('activities'):
                temp_model = GetWorkItemActivityResponseBodyActivities()
                self.activities.append(temp_model.from_map(k))
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetWorkItemActivityResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkItemActivityResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkItemActivityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList(TeaModel):
    def __init__(
        self,
        display_value: str = None,
        identifier: str = None,
        level: int = None,
        value: str = None,
        value_en: str = None,
    ):
        self.display_value = display_value
        self.identifier = identifier
        self.level = level
        self.value = value
        self.value_en = value_en

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_value is not None:
            result['displayValue'] = self.display_value
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.level is not None:
            result['level'] = self.level
        if self.value is not None:
            result['value'] = self.value
        if self.value_en is not None:
            result['valueEn'] = self.value_en
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayValue') is not None:
            self.display_value = m.get('displayValue')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('valueEn') is not None:
            self.value_en = m.get('valueEn')
        return self


class GetWorkItemInfoResponseBodyWorkitemCustomFields(TeaModel):
    def __init__(
        self,
        field_class_name: str = None,
        field_format: str = None,
        field_identifier: str = None,
        level: int = None,
        object_value: str = None,
        position: int = None,
        value: str = None,
        value_list: List[GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList] = None,
        workitem_identifier: str = None,
    ):
        self.field_class_name = field_class_name
        self.field_format = field_format
        self.field_identifier = field_identifier
        self.level = level
        self.object_value = object_value
        self.position = position
        self.value = value
        self.value_list = value_list
        self.workitem_identifier = workitem_identifier

    def validate(self):
        if self.value_list:
            for k in self.value_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_class_name is not None:
            result['fieldClassName'] = self.field_class_name
        if self.field_format is not None:
            result['fieldFormat'] = self.field_format
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.level is not None:
            result['level'] = self.level
        if self.object_value is not None:
            result['objectValue'] = self.object_value
        if self.position is not None:
            result['position'] = self.position
        if self.value is not None:
            result['value'] = self.value
        result['valueList'] = []
        if self.value_list is not None:
            for k in self.value_list:
                result['valueList'].append(k.to_map() if k else None)
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldClassName') is not None:
            self.field_class_name = m.get('fieldClassName')
        if m.get('fieldFormat') is not None:
            self.field_format = m.get('fieldFormat')
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('objectValue') is not None:
            self.object_value = m.get('objectValue')
        if m.get('position') is not None:
            self.position = m.get('position')
        if m.get('value') is not None:
            self.value = m.get('value')
        self.value_list = []
        if m.get('valueList') is not None:
            for k in m.get('valueList'):
                temp_model = GetWorkItemInfoResponseBodyWorkitemCustomFieldsValueList()
                self.value_list.append(temp_model.from_map(k))
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class GetWorkItemInfoResponseBodyWorkitemTagDetails(TeaModel):
    def __init__(
        self,
        color: str = None,
        identifier: str = None,
        name: str = None,
    ):
        self.color = color
        self.identifier = identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetWorkItemInfoResponseBodyWorkitemVersions(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        name: str = None,
    ):
        self.identifier = identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetWorkItemInfoResponseBodyWorkitem(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category_identifier: str = None,
        creator: str = None,
        custom_fields: List[GetWorkItemInfoResponseBodyWorkitemCustomFields] = None,
        document: str = None,
        document_format: str = None,
        finish_time: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        logical_status: str = None,
        modifier: str = None,
        parent_identifier: str = None,
        participant: List[str] = None,
        serial_number: str = None,
        space_identifier: str = None,
        space_name: str = None,
        space_type: str = None,
        sprint: List[str] = None,
        status: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        subject: str = None,
        tag: List[str] = None,
        tag_details: List[GetWorkItemInfoResponseBodyWorkitemTagDetails] = None,
        tracker: List[str] = None,
        update_status_at: int = None,
        verifier: List[str] = None,
        versions: List[GetWorkItemInfoResponseBodyWorkitemVersions] = None,
        workitem_type_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.custom_fields = custom_fields
        self.document = document
        self.document_format = document_format
        self.finish_time = finish_time
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.logical_status = logical_status
        self.modifier = modifier
        self.parent_identifier = parent_identifier
        self.participant = participant
        self.serial_number = serial_number
        self.space_identifier = space_identifier
        self.space_name = space_name
        self.space_type = space_type
        self.sprint = sprint
        self.status = status
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.subject = subject
        self.tag = tag
        self.tag_details = tag_details
        self.tracker = tracker
        self.update_status_at = update_status_at
        self.verifier = verifier
        self.versions = versions
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        if self.custom_fields:
            for k in self.custom_fields:
                if k:
                    k.validate()
        if self.tag_details:
            for k in self.tag_details:
                if k:
                    k.validate()
        if self.versions:
            for k in self.versions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        result['customFields'] = []
        if self.custom_fields is not None:
            for k in self.custom_fields:
                result['customFields'].append(k.to_map() if k else None)
        if self.document is not None:
            result['document'] = self.document
        if self.document_format is not None:
            result['documentFormat'] = self.document_format
        if self.finish_time is not None:
            result['finishTime'] = self.finish_time
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.participant is not None:
            result['participant'] = self.participant
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_name is not None:
            result['spaceName'] = self.space_name
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.sprint is not None:
            result['sprint'] = self.sprint
        if self.status is not None:
            result['status'] = self.status
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.tag is not None:
            result['tag'] = self.tag
        result['tagDetails'] = []
        if self.tag_details is not None:
            for k in self.tag_details:
                result['tagDetails'].append(k.to_map() if k else None)
        if self.tracker is not None:
            result['tracker'] = self.tracker
        if self.update_status_at is not None:
            result['updateStatusAt'] = self.update_status_at
        if self.verifier is not None:
            result['verifier'] = self.verifier
        result['versions'] = []
        if self.versions is not None:
            for k in self.versions:
                result['versions'].append(k.to_map() if k else None)
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        self.custom_fields = []
        if m.get('customFields') is not None:
            for k in m.get('customFields'):
                temp_model = GetWorkItemInfoResponseBodyWorkitemCustomFields()
                self.custom_fields.append(temp_model.from_map(k))
        if m.get('document') is not None:
            self.document = m.get('document')
        if m.get('documentFormat') is not None:
            self.document_format = m.get('documentFormat')
        if m.get('finishTime') is not None:
            self.finish_time = m.get('finishTime')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('participant') is not None:
            self.participant = m.get('participant')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceName') is not None:
            self.space_name = m.get('spaceName')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('sprint') is not None:
            self.sprint = m.get('sprint')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('tag') is not None:
            self.tag = m.get('tag')
        self.tag_details = []
        if m.get('tagDetails') is not None:
            for k in m.get('tagDetails'):
                temp_model = GetWorkItemInfoResponseBodyWorkitemTagDetails()
                self.tag_details.append(temp_model.from_map(k))
        if m.get('tracker') is not None:
            self.tracker = m.get('tracker')
        if m.get('updateStatusAt') is not None:
            self.update_status_at = m.get('updateStatusAt')
        if m.get('verifier') is not None:
            self.verifier = m.get('verifier')
        self.versions = []
        if m.get('versions') is not None:
            for k in m.get('versions'):
                temp_model = GetWorkItemInfoResponseBodyWorkitemVersions()
                self.versions.append(temp_model.from_map(k))
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class GetWorkItemInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workitem: GetWorkItemInfoResponseBodyWorkitem = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workitem = workitem

    def validate(self):
        if self.workitem:
            self.workitem.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workitem is not None:
            result['workitem'] = self.workitem.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workitem') is not None:
            temp_model = GetWorkItemInfoResponseBodyWorkitem()
            self.workitem = temp_model.from_map(m['workitem'])
        return self


class GetWorkItemInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkItemInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkItemInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkItemWorkFlowInfoRequest(TeaModel):
    def __init__(
        self,
        configuration_id: str = None,
    ):
        self.configuration_id = configuration_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configuration_id is not None:
            result['configurationId'] = self.configuration_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('configurationId') is not None:
            self.configuration_id = m.get('configurationId')
        return self


class GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses(TeaModel):
    def __init__(
        self,
        creator: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        resource_type: str = None,
        source: str = None,
        workflow_stage_identifier: str = None,
        workflow_stage_name: str = None,
    ):
        self.creator = creator
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.resource_type = resource_type
        self.source = source
        self.workflow_stage_identifier = workflow_stage_identifier
        self.workflow_stage_name = workflow_stage_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.source is not None:
            result['source'] = self.source
        if self.workflow_stage_identifier is not None:
            result['workflowStageIdentifier'] = self.workflow_stage_identifier
        if self.workflow_stage_name is not None:
            result['workflowStageName'] = self.workflow_stage_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('workflowStageIdentifier') is not None:
            self.workflow_stage_identifier = m.get('workflowStageIdentifier')
        if m.get('workflowStageName') is not None:
            self.workflow_stage_name = m.get('workflowStageName')
        return self


class GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        next_workflow_status_identifier: str = None,
        workflow_identifier: str = None,
        workflow_status_identifier: str = None,
    ):
        self.id = id
        self.name = name
        self.next_workflow_status_identifier = next_workflow_status_identifier
        self.workflow_identifier = workflow_identifier
        self.workflow_status_identifier = workflow_status_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.next_workflow_status_identifier is not None:
            result['nextWorkflowStatusIdentifier'] = self.next_workflow_status_identifier
        if self.workflow_identifier is not None:
            result['workflowIdentifier'] = self.workflow_identifier
        if self.workflow_status_identifier is not None:
            result['workflowStatusIdentifier'] = self.workflow_status_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextWorkflowStatusIdentifier') is not None:
            self.next_workflow_status_identifier = m.get('nextWorkflowStatusIdentifier')
        if m.get('workflowIdentifier') is not None:
            self.workflow_identifier = m.get('workflowIdentifier')
        if m.get('workflowStatusIdentifier') is not None:
            self.workflow_status_identifier = m.get('workflowStatusIdentifier')
        return self


class GetWorkItemWorkFlowInfoResponseBodyWorkflow(TeaModel):
    def __init__(
        self,
        creator: str = None,
        default_status_identifier: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        owner_space_identifier: str = None,
        owner_space_type: str = None,
        resource_type: str = None,
        source: str = None,
        status_order: str = None,
        statuses: List[GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses] = None,
        workflow_actions: List[GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions] = None,
    ):
        self.creator = creator
        self.default_status_identifier = default_status_identifier
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.owner_space_identifier = owner_space_identifier
        self.owner_space_type = owner_space_type
        self.resource_type = resource_type
        self.source = source
        self.status_order = status_order
        self.statuses = statuses
        self.workflow_actions = workflow_actions

    def validate(self):
        if self.statuses:
            for k in self.statuses:
                if k:
                    k.validate()
        if self.workflow_actions:
            for k in self.workflow_actions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_status_identifier is not None:
            result['defaultStatusIdentifier'] = self.default_status_identifier
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.owner_space_identifier is not None:
            result['ownerSpaceIdentifier'] = self.owner_space_identifier
        if self.owner_space_type is not None:
            result['ownerSpaceType'] = self.owner_space_type
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.source is not None:
            result['source'] = self.source
        if self.status_order is not None:
            result['statusOrder'] = self.status_order
        result['statuses'] = []
        if self.statuses is not None:
            for k in self.statuses:
                result['statuses'].append(k.to_map() if k else None)
        result['workflowActions'] = []
        if self.workflow_actions is not None:
            for k in self.workflow_actions:
                result['workflowActions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('defaultStatusIdentifier') is not None:
            self.default_status_identifier = m.get('defaultStatusIdentifier')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerSpaceIdentifier') is not None:
            self.owner_space_identifier = m.get('ownerSpaceIdentifier')
        if m.get('ownerSpaceType') is not None:
            self.owner_space_type = m.get('ownerSpaceType')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('statusOrder') is not None:
            self.status_order = m.get('statusOrder')
        self.statuses = []
        if m.get('statuses') is not None:
            for k in m.get('statuses'):
                temp_model = GetWorkItemWorkFlowInfoResponseBodyWorkflowStatuses()
                self.statuses.append(temp_model.from_map(k))
        self.workflow_actions = []
        if m.get('workflowActions') is not None:
            for k in m.get('workflowActions'):
                temp_model = GetWorkItemWorkFlowInfoResponseBodyWorkflowWorkflowActions()
                self.workflow_actions.append(temp_model.from_map(k))
        return self


class GetWorkItemWorkFlowInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workflow: GetWorkItemWorkFlowInfoResponseBodyWorkflow = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workflow = workflow

    def validate(self):
        if self.workflow:
            self.workflow.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workflow is not None:
            result['workflow'] = self.workflow.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workflow') is not None:
            temp_model = GetWorkItemWorkFlowInfoResponseBodyWorkflow()
            self.workflow = temp_model.from_map(m['workflow'])
        return self


class GetWorkItemWorkFlowInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkItemWorkFlowInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkItemWorkFlowInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkitemAttachmentCreatemetaRequest(TeaModel):
    def __init__(
        self,
        file_name: str = None,
    ):
        # This parameter is required.
        self.file_name = file_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['fileName'] = self.file_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        return self


class GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo(TeaModel):
    def __init__(
        self,
        accessid: str = None,
        dir: str = None,
        host: str = None,
        policy: str = None,
        signature: str = None,
    ):
        self.accessid = accessid
        self.dir = dir
        self.host = host
        self.policy = policy
        self.signature = signature

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accessid is not None:
            result['accessid'] = self.accessid
        if self.dir is not None:
            result['dir'] = self.dir
        if self.host is not None:
            result['host'] = self.host
        if self.policy is not None:
            result['policy'] = self.policy
        if self.signature is not None:
            result['signature'] = self.signature
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessid') is not None:
            self.accessid = m.get('accessid')
        if m.get('dir') is not None:
            self.dir = m.get('dir')
        if m.get('host') is not None:
            self.host = m.get('host')
        if m.get('policy') is not None:
            self.policy = m.get('policy')
        if m.get('signature') is not None:
            self.signature = m.get('signature')
        return self


class GetWorkitemAttachmentCreatemetaResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: str = None,
        upload_info: GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.upload_info = upload_info

    def validate(self):
        if self.upload_info:
            self.upload_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.upload_info is not None:
            result['uploadInfo'] = self.upload_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('uploadInfo') is not None:
            temp_model = GetWorkitemAttachmentCreatemetaResponseBodyUploadInfo()
            self.upload_info = temp_model.from_map(m['uploadInfo'])
        return self


class GetWorkitemAttachmentCreatemetaResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkitemAttachmentCreatemetaResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkitemAttachmentCreatemetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkitemCommentListResponseBodyCommentListUser(TeaModel):
    def __init__(
        self,
        account: str = None,
        avatar: str = None,
        identifier: str = None,
        nick_name: str = None,
        real_name: str = None,
    ):
        self.account = account
        self.avatar = avatar
        self.identifier = identifier
        self.nick_name = nick_name
        self.real_name = real_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['account'] = self.account
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.real_name is not None:
            result['realName'] = self.real_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('realName') is not None:
            self.real_name = m.get('realName')
        return self


class GetWorkitemCommentListResponseBodyCommentList(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: int = None,
        format_type: str = None,
        id: int = None,
        is_top: bool = None,
        modified_time: int = None,
        parent_id: int = None,
        target_identifier: str = None,
        target_type: str = None,
        top_time: int = None,
        user: GetWorkitemCommentListResponseBodyCommentListUser = None,
    ):
        self.content = content
        self.create_time = create_time
        self.format_type = format_type
        self.id = id
        self.is_top = is_top
        self.modified_time = modified_time
        self.parent_id = parent_id
        self.target_identifier = target_identifier
        self.target_type = target_type
        self.top_time = top_time
        self.user = user

    def validate(self):
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.format_type is not None:
            result['formatType'] = self.format_type
        if self.id is not None:
            result['id'] = self.id
        if self.is_top is not None:
            result['isTop'] = self.is_top
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.target_identifier is not None:
            result['targetIdentifier'] = self.target_identifier
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.top_time is not None:
            result['topTime'] = self.top_time
        if self.user is not None:
            result['user'] = self.user.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('formatType') is not None:
            self.format_type = m.get('formatType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isTop') is not None:
            self.is_top = m.get('isTop')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('targetIdentifier') is not None:
            self.target_identifier = m.get('targetIdentifier')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('topTime') is not None:
            self.top_time = m.get('topTime')
        if m.get('user') is not None:
            temp_model = GetWorkitemCommentListResponseBodyCommentListUser()
            self.user = temp_model.from_map(m['user'])
        return self


class GetWorkitemCommentListResponseBody(TeaModel):
    def __init__(
        self,
        comment_list: List[GetWorkitemCommentListResponseBodyCommentList] = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.comment_list = comment_list
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.comment_list:
            for k in self.comment_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['commentList'] = []
        if self.comment_list is not None:
            for k in self.comment_list:
                result['commentList'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.comment_list = []
        if m.get('commentList') is not None:
            for k in m.get('commentList'):
                temp_model = GetWorkitemCommentListResponseBodyCommentList()
                self.comment_list.append(temp_model.from_map(k))
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetWorkitemCommentListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkitemCommentListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkitemCommentListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkitemFileResponseBodyWorkitemFile(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        size: int = None,
        suffix: str = None,
        url: str = None,
    ):
        self.id = id
        self.name = name
        self.size = size
        self.suffix = suffix
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.size is not None:
            result['size'] = self.size
        if self.suffix is not None:
            result['suffix'] = self.suffix
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('suffix') is not None:
            self.suffix = m.get('suffix')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class GetWorkitemFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
        workitem_file: GetWorkitemFileResponseBodyWorkitemFile = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.workitem_file = workitem_file

    def validate(self):
        if self.workitem_file:
            self.workitem_file.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workitem_file is not None:
            result['workitemFile'] = self.workitem_file.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workitemFile') is not None:
            temp_model = GetWorkitemFileResponseBodyWorkitemFile()
            self.workitem_file = temp_model.from_map(m['workitemFile'])
        return self


class GetWorkitemFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkitemFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkitemFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkitemRelationsRequest(TeaModel):
    def __init__(
        self,
        relation_type: str = None,
    ):
        # This parameter is required.
        self.relation_type = relation_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.relation_type is not None:
            result['relationType'] = self.relation_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('relationType') is not None:
            self.relation_type = m.get('relationType')
        return self


class GetWorkitemRelationsResponseBodyRelationList(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category_identifier: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        identifier: str = None,
        space_identifier: str = None,
        subject: str = None,
        workitem_type_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.space_identifier = space_identifier
        self.subject = subject
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class GetWorkitemRelationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        relation_list: List[GetWorkitemRelationsResponseBodyRelationList] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.relation_list = relation_list
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.relation_list:
            for k in self.relation_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        result['relationList'] = []
        if self.relation_list is not None:
            for k in self.relation_list:
                result['relationList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        self.relation_list = []
        if m.get('relationList') is not None:
            for k in m.get('relationList'):
                temp_model = GetWorkitemRelationsResponseBodyRelationList()
                self.relation_list.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetWorkitemRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkitemRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkitemRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetWorkitemTimeTypeListResponseBodyTimeType(TeaModel):
    def __init__(
        self,
        description: str = None,
        display_name: str = None,
        identifier: str = None,
        name: str = None,
        position: int = None,
    ):
        self.description = description
        self.display_name = display_name
        self.identifier = identifier
        self.name = name
        self.position = position

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.name is not None:
            result['name'] = self.name
        if self.position is not None:
            result['position'] = self.position
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('position') is not None:
            self.position = m.get('position')
        return self


class GetWorkitemTimeTypeListResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
        time_type: List[GetWorkitemTimeTypeListResponseBodyTimeType] = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success
        self.time_type = time_type

    def validate(self):
        if self.time_type:
            for k in self.time_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['timeType'] = []
        if self.time_type is not None:
            for k in self.time_type:
                result['timeType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.time_type = []
        if m.get('timeType') is not None:
            for k in m.get('timeType'):
                temp_model = GetWorkitemTimeTypeListResponseBodyTimeType()
                self.time_type.append(temp_model.from_map(k))
        return self


class GetWorkitemTimeTypeListResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: GetWorkitemTimeTypeListResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetWorkitemTimeTypeListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinPipelineGroupRequest(TeaModel):
    def __init__(
        self,
        group_id: int = None,
        pipeline_ids: str = None,
    ):
        # This parameter is required.
        self.group_id = group_id
        # This parameter is required.
        self.pipeline_ids = pipeline_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.pipeline_ids is not None:
            result['pipelineIds'] = self.pipeline_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('pipelineIds') is not None:
            self.pipeline_ids = m.get('pipelineIds')
        return self


class JoinPipelineGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class JoinPipelineGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: JoinPipelineGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinPipelineGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LinkMergeRequestLabelRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        label_ids: List[str] = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.label_ids = label_ids
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.label_ids is not None:
            result['labelIds'] = self.label_ids
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('labelIds') is not None:
            self.label_ids = m.get('labelIds')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class LinkMergeRequestLabelResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class LinkMergeRequestLabelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: LinkMergeRequestLabelResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = LinkMergeRequestLabelResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class LinkMergeRequestLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LinkMergeRequestLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LinkMergeRequestLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllReleaseWorkflowsRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups(TeaModel):
    def __init__(
        self,
        name: str = None,
        display_name: str = None,
        type: str = None,
    ):
        self.name = name
        self.display_name = display_name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListAllReleaseWorkflowsResponseBodyReleaseStages(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        name: str = None,
        sn: str = None,
        release_workflow_sn: str = None,
        order: str = None,
        variable_groups: List[ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups] = None,
    ):
        self.app_name = app_name
        self.name = name
        self.sn = sn
        self.release_workflow_sn = release_workflow_sn
        self.order = order
        self.variable_groups = variable_groups

    def validate(self):
        if self.variable_groups:
            for k in self.variable_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['appName'] = self.app_name
        if self.name is not None:
            result['name'] = self.name
        if self.sn is not None:
            result['sn'] = self.sn
        if self.release_workflow_sn is not None:
            result['releaseWorkflowSn'] = self.release_workflow_sn
        if self.order is not None:
            result['order'] = self.order
        result['variableGroups'] = []
        if self.variable_groups is not None:
            for k in self.variable_groups:
                result['variableGroups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appName') is not None:
            self.app_name = m.get('appName')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sn') is not None:
            self.sn = m.get('sn')
        if m.get('releaseWorkflowSn') is not None:
            self.release_workflow_sn = m.get('releaseWorkflowSn')
        if m.get('order') is not None:
            self.order = m.get('order')
        self.variable_groups = []
        if m.get('variableGroups') is not None:
            for k in m.get('variableGroups'):
                temp_model = ListAllReleaseWorkflowsResponseBodyReleaseStagesVariableGroups()
                self.variable_groups.append(temp_model.from_map(k))
        return self


class ListAllReleaseWorkflowsResponseBody(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        sn: str = None,
        name: str = None,
        order: str = None,
        release_stages: List[ListAllReleaseWorkflowsResponseBodyReleaseStages] = None,
        note: str = None,
    ):
        self.app_name = app_name
        self.sn = sn
        self.name = name
        self.order = order
        self.release_stages = release_stages
        self.note = note

    def validate(self):
        if self.release_stages:
            for k in self.release_stages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['appName'] = self.app_name
        if self.sn is not None:
            result['sn'] = self.sn
        if self.name is not None:
            result['name'] = self.name
        if self.order is not None:
            result['order'] = self.order
        result['releaseStages'] = []
        if self.release_stages is not None:
            for k in self.release_stages:
                result['releaseStages'].append(k.to_map() if k else None)
        if self.note is not None:
            result['note'] = self.note
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appName') is not None:
            self.app_name = m.get('appName')
        if m.get('sn') is not None:
            self.sn = m.get('sn')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('order') is not None:
            self.order = m.get('order')
        self.release_stages = []
        if m.get('releaseStages') is not None:
            for k in m.get('releaseStages'):
                temp_model = ListAllReleaseWorkflowsResponseBodyReleaseStages()
                self.release_stages.append(temp_model.from_map(k))
        if m.get('note') is not None:
            self.note = m.get('note')
        return self


class ListAllReleaseWorkflowsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: List[ListAllReleaseWorkflowsResponseBody] = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            for k in self.body:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        result['body'] = []
        if self.body is not None:
            for k in self.body:
                result['body'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        self.body = []
        if m.get('body') is not None:
            for k in m.get('body'):
                temp_model = ListAllReleaseWorkflowsResponseBody()
                self.body.append(temp_model.from_map(k))
        return self


class ListAppReleaseStageExecutionIntegratedMetadataRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests(TeaModel):
    def __init__(
        self,
        sn: str = None,
        name: str = None,
        branch_name: str = None,
        commit_id: str = None,
        owner_account_id: str = None,
    ):
        self.sn = sn
        self.name = name
        self.branch_name = branch_name
        self.commit_id = commit_id
        self.owner_account_id = owner_account_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sn is not None:
            result['sn'] = self.sn
        if self.name is not None:
            result['name'] = self.name
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.owner_account_id is not None:
            result['ownerAccountId'] = self.owner_account_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('sn') is not None:
            self.sn = m.get('sn')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('ownerAccountId') is not None:
            self.owner_account_id = m.get('ownerAccountId')
        return self


class ListAppReleaseStageExecutionIntegratedMetadataResponseBody(TeaModel):
    def __init__(
        self,
        release_branch: str = None,
        release_revision: str = None,
        repo_url: str = None,
        repo_type: str = None,
        change_requests: List[ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests] = None,
    ):
        self.release_branch = release_branch
        self.release_revision = release_revision
        self.repo_url = repo_url
        self.repo_type = repo_type
        self.change_requests = change_requests

    def validate(self):
        if self.change_requests:
            for k in self.change_requests:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.release_branch is not None:
            result['releaseBranch'] = self.release_branch
        if self.release_revision is not None:
            result['releaseRevision'] = self.release_revision
        if self.repo_url is not None:
            result['repoUrl'] = self.repo_url
        if self.repo_type is not None:
            result['repoType'] = self.repo_type
        result['changeRequests'] = []
        if self.change_requests is not None:
            for k in self.change_requests:
                result['changeRequests'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('releaseBranch') is not None:
            self.release_branch = m.get('releaseBranch')
        if m.get('releaseRevision') is not None:
            self.release_revision = m.get('releaseRevision')
        if m.get('repoUrl') is not None:
            self.repo_url = m.get('repoUrl')
        if m.get('repoType') is not None:
            self.repo_type = m.get('repoType')
        self.change_requests = []
        if m.get('changeRequests') is not None:
            for k in m.get('changeRequests'):
                temp_model = ListAppReleaseStageExecutionIntegratedMetadataResponseBodyChangeRequests()
                self.change_requests.append(temp_model.from_map(k))
        return self


class ListAppReleaseStageExecutionIntegratedMetadataResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: List[ListAppReleaseStageExecutionIntegratedMetadataResponseBody] = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            for k in self.body:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        result['body'] = []
        if self.body is not None:
            for k in self.body:
                result['body'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        self.body = []
        if m.get('body') is not None:
            for k in m.get('body'):
                temp_model = ListAppReleaseStageExecutionIntegratedMetadataResponseBody()
                self.body.append(temp_model.from_map(k))
        return self


class ListAppReleaseStageExecutionsRequest(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        pagination: str = None,
        per_page: int = None,
        sort: str = None,
    ):
        self.next_token = next_token
        self.order_by = order_by
        self.organization_id = organization_id
        self.page = page
        self.pagination = pagination
        self.per_page = per_page
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.pagination is not None:
            result['pagination'] = self.pagination
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pagination') is not None:
            self.pagination = m.get('pagination')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListAppReleaseStageExecutionsResponseBodyData(TeaModel):
    def __init__(
        self,
        end_time: str = None,
        number: str = None,
        start_time: str = None,
        state: str = None,
        trigger_mode: str = None,
    ):
        self.end_time = end_time
        self.number = number
        self.start_time = start_time
        self.state = state
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.number is not None:
            result['number'] = self.number
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.state is not None:
            result['state'] = self.state
        if self.trigger_mode is not None:
            result['triggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('number') is not None:
            self.number = m.get('number')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('triggerMode') is not None:
            self.trigger_mode = m.get('triggerMode')
        return self


class ListAppReleaseStageExecutionsResponseBody(TeaModel):
    def __init__(
        self,
        current: int = None,
        data: List[ListAppReleaseStageExecutionsResponseBodyData] = None,
        next_token: str = None,
        pages: int = None,
        per_page: int = None,
        total: int = None,
    ):
        self.current = current
        self.data = data
        self.next_token = next_token
        self.pages = pages
        self.per_page = per_page
        self.total = total

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['current'] = self.current
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.pages is not None:
            result['pages'] = self.pages
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current') is not None:
            self.current = m.get('current')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListAppReleaseStageExecutionsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pages') is not None:
            self.pages = m.get('pages')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListAppReleaseStageExecutionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListAppReleaseStageExecutionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAppReleaseStageExecutionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationMembersRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
    ):
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListApplicationMembersResponseBodyRecordsRoleList(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        name: str = None,
    ):
        self.display_name = display_name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListApplicationMembersResponseBodyRecords(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        description: str = None,
        display_name: str = None,
        id: str = None,
        role_list: List[ListApplicationMembersResponseBodyRecordsRoleList] = None,
        type: str = None,
    ):
        self.avatar = avatar
        self.description = description
        self.display_name = display_name
        self.id = id
        self.role_list = role_list
        self.type = type

    def validate(self):
        if self.role_list:
            for k in self.role_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.description is not None:
            result['description'] = self.description
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.id is not None:
            result['id'] = self.id
        result['roleList'] = []
        if self.role_list is not None:
            for k in self.role_list:
                result['roleList'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('id') is not None:
            self.id = m.get('id')
        self.role_list = []
        if m.get('roleList') is not None:
            for k in m.get('roleList'):
                temp_model = ListApplicationMembersResponseBodyRecordsRoleList()
                self.role_list.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListApplicationMembersResponseBody(TeaModel):
    def __init__(
        self,
        current: int = None,
        page_size: int = None,
        pages: int = None,
        records: List[ListApplicationMembersResponseBodyRecords] = None,
        request_id: str = None,
        total: int = None,
    ):
        self.current = current
        self.page_size = page_size
        self.pages = pages
        self.records = records
        self.request_id = request_id
        self.total = total

    def validate(self):
        if self.records:
            for k in self.records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['current'] = self.current
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.pages is not None:
            result['pages'] = self.pages
        result['records'] = []
        if self.records is not None:
            for k in self.records:
                result['records'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current') is not None:
            self.current = m.get('current')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('pages') is not None:
            self.pages = m.get('pages')
        self.records = []
        if m.get('records') is not None:
            for k in m.get('records'):
                temp_model = ListApplicationMembersResponseBodyRecords()
                self.records.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListApplicationMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListApplicationsRequest(TeaModel):
    def __init__(
        self,
        next_token: str = None,
        order_by: str = None,
        organization_id: str = None,
        pagination: str = None,
        per_page: int = None,
        sort: str = None,
    ):
        self.next_token = next_token
        self.order_by = order_by
        self.organization_id = organization_id
        self.pagination = pagination
        self.per_page = per_page
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.pagination is not None:
            result['pagination'] = self.pagination
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('pagination') is not None:
            self.pagination = m.get('pagination')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListApplicationsResponseBodyData(TeaModel):
    def __init__(
        self,
        creator_account_id: str = None,
        description: str = None,
        gmt_create: str = None,
        name: str = None,
    ):
        self.creator_account_id = creator_account_id
        self.description = description
        self.gmt_create = gmt_create
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListApplicationsResponseBody(TeaModel):
    def __init__(
        self,
        data: List[ListApplicationsResponseBodyData] = None,
        next_token: str = None,
        request_id: str = None,
    ):
        self.data = data
        self.next_token = next_token
        self.request_id = request_id

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListApplicationsResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class ListApplicationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListApplicationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListApplicationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListChangeRequestWorkflowExecutionsRequest(TeaModel):
    def __init__(
        self,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        per_page: int = None,
        release_stage_sn: str = None,
        release_workflow_sn: str = None,
        sort: str = None,
    ):
        self.order_by = order_by
        self.organization_id = organization_id
        self.page = page
        self.per_page = per_page
        # This parameter is required.
        self.release_stage_sn = release_stage_sn
        # This parameter is required.
        self.release_workflow_sn = release_workflow_sn
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.release_stage_sn is not None:
            result['releaseStageSn'] = self.release_stage_sn
        if self.release_workflow_sn is not None:
            result['releaseWorkflowSn'] = self.release_workflow_sn
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('releaseStageSn') is not None:
            self.release_stage_sn = m.get('releaseStageSn')
        if m.get('releaseWorkflowSn') is not None:
            self.release_workflow_sn = m.get('releaseWorkflowSn')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListChangeRequestWorkflowExecutionsResponseBody(TeaModel):
    def __init__(
        self,
        current: int = None,
        page_size: int = None,
        pages: int = None,
        records: List[Any] = None,
        total: int = None,
    ):
        self.current = current
        self.page_size = page_size
        self.pages = pages
        self.records = records
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['current'] = self.current
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.pages is not None:
            result['pages'] = self.pages
        if self.records is not None:
            result['records'] = self.records
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current') is not None:
            self.current = m.get('current')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('pages') is not None:
            self.pages = m.get('pages')
        if m.get('records') is not None:
            self.records = m.get('records')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListChangeRequestWorkflowExecutionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListChangeRequestWorkflowExecutionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListChangeRequestWorkflowExecutionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListChangeRequestsRequest(TeaModel):
    def __init__(
        self,
        app_name_list: List[str] = None,
        display_name_keyword: str = None,
        next_token: str = None,
        order_by: str = None,
        organization_id: str = None,
        owner_id_list: List[str] = None,
        page: int = None,
        pagination: str = None,
        per_page: int = None,
        sort: str = None,
        state_list: List[str] = None,
    ):
        self.app_name_list = app_name_list
        self.display_name_keyword = display_name_keyword
        self.next_token = next_token
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.owner_id_list = owner_id_list
        self.page = page
        self.pagination = pagination
        self.per_page = per_page
        self.sort = sort
        self.state_list = state_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name_list is not None:
            result['appNameList'] = self.app_name_list
        if self.display_name_keyword is not None:
            result['displayNameKeyword'] = self.display_name_keyword
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.owner_id_list is not None:
            result['ownerIdList'] = self.owner_id_list
        if self.page is not None:
            result['page'] = self.page
        if self.pagination is not None:
            result['pagination'] = self.pagination
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.sort is not None:
            result['sort'] = self.sort
        if self.state_list is not None:
            result['stateList'] = self.state_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appNameList') is not None:
            self.app_name_list = m.get('appNameList')
        if m.get('displayNameKeyword') is not None:
            self.display_name_keyword = m.get('displayNameKeyword')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('ownerIdList') is not None:
            self.owner_id_list = m.get('ownerIdList')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pagination') is not None:
            self.pagination = m.get('pagination')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('stateList') is not None:
            self.state_list = m.get('stateList')
        return self


class ListChangeRequestsShrinkRequest(TeaModel):
    def __init__(
        self,
        app_name_list_shrink: str = None,
        display_name_keyword: str = None,
        next_token: str = None,
        order_by: str = None,
        organization_id: str = None,
        owner_id_list_shrink: str = None,
        page: int = None,
        pagination: str = None,
        per_page: int = None,
        sort: str = None,
        state_list_shrink: str = None,
    ):
        self.app_name_list_shrink = app_name_list_shrink
        self.display_name_keyword = display_name_keyword
        self.next_token = next_token
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.owner_id_list_shrink = owner_id_list_shrink
        self.page = page
        self.pagination = pagination
        self.per_page = per_page
        self.sort = sort
        self.state_list_shrink = state_list_shrink

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name_list_shrink is not None:
            result['appNameList'] = self.app_name_list_shrink
        if self.display_name_keyword is not None:
            result['displayNameKeyword'] = self.display_name_keyword
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.owner_id_list_shrink is not None:
            result['ownerIdList'] = self.owner_id_list_shrink
        if self.page is not None:
            result['page'] = self.page
        if self.pagination is not None:
            result['pagination'] = self.pagination
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.sort is not None:
            result['sort'] = self.sort
        if self.state_list_shrink is not None:
            result['stateList'] = self.state_list_shrink
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('appNameList') is not None:
            self.app_name_list_shrink = m.get('appNameList')
        if m.get('displayNameKeyword') is not None:
            self.display_name_keyword = m.get('displayNameKeyword')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('ownerIdList') is not None:
            self.owner_id_list_shrink = m.get('ownerIdList')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pagination') is not None:
            self.pagination = m.get('pagination')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('stateList') is not None:
            self.state_list_shrink = m.get('stateList')
        return self


class ListChangeRequestsResponseBody(TeaModel):
    def __init__(
        self,
        current: int = None,
        data: List[Any] = None,
        next_token: str = None,
        pages: int = None,
        per_page: int = None,
        total: int = None,
    ):
        self.current = current
        self.data = data
        self.next_token = next_token
        self.pages = pages
        self.per_page = per_page
        self.total = total

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['current'] = self.current
        if self.data is not None:
            result['data'] = self.data
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.pages is not None:
            result['pages'] = self.pages
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current') is not None:
            self.current = m.get('current')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pages') is not None:
            self.pages = m.get('pages')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListChangeRequestsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListChangeRequestsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListChangeRequestsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCheckRunsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        ref: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        # This parameter is required.
        self.ref = ref
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.ref is not None:
            result['ref'] = self.ref
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('ref') is not None:
            self.ref = m.get('ref')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class ListCheckRunsResponseBodyResultAnnotations(TeaModel):
    def __init__(
        self,
        annotation_level: str = None,
        end_column: int = None,
        end_line: int = None,
        id: int = None,
        message: str = None,
        path: str = None,
        raw_details: str = None,
        start_column: int = None,
        start_line: int = None,
        title: str = None,
    ):
        self.annotation_level = annotation_level
        self.end_column = end_column
        self.end_line = end_line
        self.id = id
        self.message = message
        self.path = path
        self.raw_details = raw_details
        self.start_column = start_column
        self.start_line = start_line
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation_level is not None:
            result['annotationLevel'] = self.annotation_level
        if self.end_column is not None:
            result['endColumn'] = self.end_column
        if self.end_line is not None:
            result['endLine'] = self.end_line
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.path is not None:
            result['path'] = self.path
        if self.raw_details is not None:
            result['rawDetails'] = self.raw_details
        if self.start_column is not None:
            result['startColumn'] = self.start_column
        if self.start_line is not None:
            result['startLine'] = self.start_line
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotationLevel') is not None:
            self.annotation_level = m.get('annotationLevel')
        if m.get('endColumn') is not None:
            self.end_column = m.get('endColumn')
        if m.get('endLine') is not None:
            self.end_line = m.get('endLine')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('rawDetails') is not None:
            self.raw_details = m.get('rawDetails')
        if m.get('startColumn') is not None:
            self.start_column = m.get('startColumn')
        if m.get('startLine') is not None:
            self.start_line = m.get('startLine')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListCheckRunsResponseBodyResultCheckSuite(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class ListCheckRunsResponseBodyResultOutputImages(TeaModel):
    def __init__(
        self,
        alt: str = None,
        caption: str = None,
        image_url: str = None,
    ):
        self.alt = alt
        self.caption = caption
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alt is not None:
            result['alt'] = self.alt
        if self.caption is not None:
            result['caption'] = self.caption
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alt') is not None:
            self.alt = m.get('alt')
        if m.get('caption') is not None:
            self.caption = m.get('caption')
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        return self


class ListCheckRunsResponseBodyResultOutput(TeaModel):
    def __init__(
        self,
        images: List[ListCheckRunsResponseBodyResultOutputImages] = None,
        summary: str = None,
        text: str = None,
        title: str = None,
    ):
        self.images = images
        self.summary = summary
        self.text = text
        self.title = title

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['images'] = []
        if self.images is not None:
            for k in self.images:
                result['images'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary
        if self.text is not None:
            result['text'] = self.text
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('images') is not None:
            for k in m.get('images'):
                temp_model = ListCheckRunsResponseBodyResultOutputImages()
                self.images.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListCheckRunsResponseBodyResultWriter(TeaModel):
    def __init__(
        self,
        id: str = None,
        logo_url: str = None,
        name: str = None,
        slug: str = None,
        type: str = None,
    ):
        self.id = id
        self.logo_url = logo_url
        self.name = name
        self.slug = slug
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.logo_url is not None:
            result['logoUrl'] = self.logo_url
        if self.name is not None:
            result['name'] = self.name
        if self.slug is not None:
            result['slug'] = self.slug
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('logoUrl') is not None:
            self.logo_url = m.get('logoUrl')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('slug') is not None:
            self.slug = m.get('slug')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListCheckRunsResponseBodyResult(TeaModel):
    def __init__(
        self,
        annotations: List[ListCheckRunsResponseBodyResultAnnotations] = None,
        check_suite: ListCheckRunsResponseBodyResultCheckSuite = None,
        completed_at: str = None,
        conclusion: str = None,
        created_at: str = None,
        details_url: str = None,
        external_id: str = None,
        head_sha: str = None,
        id: int = None,
        name: str = None,
        output: ListCheckRunsResponseBodyResultOutput = None,
        started_at: str = None,
        status: str = None,
        updated_at: str = None,
        writer: ListCheckRunsResponseBodyResultWriter = None,
    ):
        self.annotations = annotations
        self.check_suite = check_suite
        self.completed_at = completed_at
        self.conclusion = conclusion
        self.created_at = created_at
        self.details_url = details_url
        self.external_id = external_id
        self.head_sha = head_sha
        self.id = id
        self.name = name
        self.output = output
        self.started_at = started_at
        self.status = status
        self.updated_at = updated_at
        self.writer = writer

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.check_suite:
            self.check_suite.validate()
        if self.output:
            self.output.validate()
        if self.writer:
            self.writer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.check_suite is not None:
            result['checkSuite'] = self.check_suite.to_map()
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.conclusion is not None:
            result['conclusion'] = self.conclusion
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.details_url is not None:
            result['detailsUrl'] = self.details_url
        if self.external_id is not None:
            result['externalId'] = self.external_id
        if self.head_sha is not None:
            result['headSha'] = self.head_sha
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.output is not None:
            result['output'] = self.output.to_map()
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.writer is not None:
            result['writer'] = self.writer.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = ListCheckRunsResponseBodyResultAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('checkSuite') is not None:
            temp_model = ListCheckRunsResponseBodyResultCheckSuite()
            self.check_suite = temp_model.from_map(m['checkSuite'])
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('conclusion') is not None:
            self.conclusion = m.get('conclusion')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('detailsUrl') is not None:
            self.details_url = m.get('detailsUrl')
        if m.get('externalId') is not None:
            self.external_id = m.get('externalId')
        if m.get('headSha') is not None:
            self.head_sha = m.get('headSha')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('output') is not None:
            temp_model = ListCheckRunsResponseBodyResultOutput()
            self.output = temp_model.from_map(m['output'])
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('writer') is not None:
            temp_model = ListCheckRunsResponseBodyResultWriter()
            self.writer = temp_model.from_map(m['writer'])
        return self


class ListCheckRunsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListCheckRunsResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListCheckRunsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListCheckRunsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCheckRunsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCheckRunsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCommitStatusesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        repository_identity: str = None,
        sha: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        # This parameter is required.
        self.repository_identity = repository_identity
        # This parameter is required.
        self.sha = sha

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        if self.sha is not None:
            result['sha'] = self.sha
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        if m.get('sha') is not None:
            self.sha = m.get('sha')
        return self


class ListCommitStatusesResponseBodyResultCreator(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        login: str = None,
        type: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.login = login
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.login is not None:
            result['login'] = self.login
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('login') is not None:
            self.login = m.get('login')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListCommitStatusesResponseBodyResult(TeaModel):
    def __init__(
        self,
        context: str = None,
        creator: ListCommitStatusesResponseBodyResultCreator = None,
        description: str = None,
        id: int = None,
        sha: str = None,
        state: str = None,
        target_url: str = None,
    ):
        self.context = context
        self.creator = creator
        self.description = description
        self.id = id
        self.sha = sha
        self.state = state
        self.target_url = target_url

    def validate(self):
        if self.creator:
            self.creator.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.context is not None:
            result['context'] = self.context
        if self.creator is not None:
            result['creator'] = self.creator.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.sha is not None:
            result['sha'] = self.sha
        if self.state is not None:
            result['state'] = self.state
        if self.target_url is not None:
            result['targetUrl'] = self.target_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('creator') is not None:
            temp_model = ListCommitStatusesResponseBodyResultCreator()
            self.creator = temp_model.from_map(m['creator'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('sha') is not None:
            self.sha = m.get('sha')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('targetUrl') is not None:
            self.target_url = m.get('targetUrl')
        return self


class ListCommitStatusesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListCommitStatusesResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListCommitStatusesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListCommitStatusesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListCommitStatusesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCommitStatusesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFlowTagGroupsResponseBodyFlowTagGroups(TeaModel):
    def __init__(
        self,
        creator_account_id: str = None,
        id: int = None,
        modifer_account_id: str = None,
        name: str = None,
    ):
        self.creator_account_id = creator_account_id
        self.id = id
        self.modifer_account_id = modifer_account_id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.id is not None:
            result['id'] = self.id
        if self.modifer_account_id is not None:
            result['modiferAccountId'] = self.modifer_account_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modiferAccountId') is not None:
            self.modifer_account_id = m.get('modiferAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListFlowTagGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        flow_tag_groups: List[ListFlowTagGroupsResponseBodyFlowTagGroups] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.flow_tag_groups = flow_tag_groups
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.flow_tag_groups:
            for k in self.flow_tag_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['flowTagGroups'] = []
        if self.flow_tag_groups is not None:
            for k in self.flow_tag_groups:
                result['flowTagGroups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.flow_tag_groups = []
        if m.get('flowTagGroups') is not None:
            for k in m.get('flowTagGroups'):
                temp_model = ListFlowTagGroupsResponseBodyFlowTagGroups()
                self.flow_tag_groups.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListFlowTagGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListFlowTagGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFlowTagGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGroupMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListGroupMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        member_type: str = None,
        name: str = None,
        source_id: int = None,
        state: str = None,
        username: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.member_type = member_type
        self.name = name
        self.source_id = source_id
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.name is not None:
            result['name'] = self.name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListGroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListGroupMemberResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListGroupMemberResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListGroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListGroupRepositoriesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        search: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.search = search

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.search is not None:
            result['search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('search') is not None:
            self.search = m.get('search')
        return self


class ListGroupRepositoriesResponseBodyResult(TeaModel):
    def __init__(
        self,
        archived: bool = None,
        commit_count: int = None,
        created_at: str = None,
        creator_id: int = None,
        description: str = None,
        http_url: str = None,
        id: int = None,
        import_url: str = None,
        is_stared: bool = None,
        issues_enabled: bool = None,
        last_activity_at: str = None,
        merge_requests_enabled: bool = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace_id: bool = None,
        path: str = None,
        path_with_namespace: str = None,
        private_flag: bool = None,
        snippets_enabled: bool = None,
        ssh_url: str = None,
        star_count: int = None,
        updated_at: str = None,
        visibility_level: int = None,
        web_url: str = None,
        wiki_enabled: bool = None,
    ):
        self.archived = archived
        self.commit_count = commit_count
        self.created_at = created_at
        self.creator_id = creator_id
        self.description = description
        self.http_url = http_url
        self.id = id
        self.import_url = import_url
        self.is_stared = is_stared
        self.issues_enabled = issues_enabled
        self.last_activity_at = last_activity_at
        self.merge_requests_enabled = merge_requests_enabled
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace_id = namespace_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.private_flag = private_flag
        self.snippets_enabled = snippets_enabled
        self.ssh_url = ssh_url
        self.star_count = star_count
        self.updated_at = updated_at
        self.visibility_level = visibility_level
        self.web_url = web_url
        self.wiki_enabled = wiki_enabled

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archived is not None:
            result['archived'] = self.archived
        if self.commit_count is not None:
            result['commitCount'] = self.commit_count
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.description is not None:
            result['description'] = self.description
        if self.http_url is not None:
            result['httpUrl'] = self.http_url
        if self.id is not None:
            result['id'] = self.id
        if self.import_url is not None:
            result['importUrl'] = self.import_url
        if self.is_stared is not None:
            result['isStared'] = self.is_stared
        if self.issues_enabled is not None:
            result['issuesEnabled'] = self.issues_enabled
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.merge_requests_enabled is not None:
            result['mergeRequestsEnabled'] = self.merge_requests_enabled
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.private_flag is not None:
            result['privateFlag'] = self.private_flag
        if self.snippets_enabled is not None:
            result['snippetsEnabled'] = self.snippets_enabled
        if self.ssh_url is not None:
            result['sshUrl'] = self.ssh_url
        if self.star_count is not None:
            result['starCount'] = self.star_count
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        if self.wiki_enabled is not None:
            result['wikiEnabled'] = self.wiki_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('archived') is not None:
            self.archived = m.get('archived')
        if m.get('commitCount') is not None:
            self.commit_count = m.get('commitCount')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('httpUrl') is not None:
            self.http_url = m.get('httpUrl')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('importUrl') is not None:
            self.import_url = m.get('importUrl')
        if m.get('isStared') is not None:
            self.is_stared = m.get('isStared')
        if m.get('issuesEnabled') is not None:
            self.issues_enabled = m.get('issuesEnabled')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('mergeRequestsEnabled') is not None:
            self.merge_requests_enabled = m.get('mergeRequestsEnabled')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('privateFlag') is not None:
            self.private_flag = m.get('privateFlag')
        if m.get('snippetsEnabled') is not None:
            self.snippets_enabled = m.get('snippetsEnabled')
        if m.get('sshUrl') is not None:
            self.ssh_url = m.get('sshUrl')
        if m.get('starCount') is not None:
            self.star_count = m.get('starCount')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        if m.get('wikiEnabled') is not None:
            self.wiki_enabled = m.get('wikiEnabled')
        return self


class ListGroupRepositoriesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListGroupRepositoriesResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListGroupRepositoriesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListGroupRepositoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListGroupRepositoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListGroupRepositoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListHostGroupsRequest(TeaModel):
    def __init__(
        self,
        create_end_time: int = None,
        create_start_time: int = None,
        creator_account_ids: str = None,
        ids: str = None,
        max_results: int = None,
        name: str = None,
        next_token: str = None,
        page_order: str = None,
        page_sort: str = None,
    ):
        self.create_end_time = create_end_time
        self.create_start_time = create_start_time
        self.creator_account_ids = creator_account_ids
        self.ids = ids
        self.max_results = max_results
        self.name = name
        self.next_token = next_token
        self.page_order = page_order
        self.page_sort = page_sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_end_time is not None:
            result['createEndTime'] = self.create_end_time
        if self.create_start_time is not None:
            result['createStartTime'] = self.create_start_time
        if self.creator_account_ids is not None:
            result['creatorAccountIds'] = self.creator_account_ids
        if self.ids is not None:
            result['ids'] = self.ids
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.name is not None:
            result['name'] = self.name
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_order is not None:
            result['pageOrder'] = self.page_order
        if self.page_sort is not None:
            result['pageSort'] = self.page_sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createEndTime') is not None:
            self.create_end_time = m.get('createEndTime')
        if m.get('createStartTime') is not None:
            self.create_start_time = m.get('createStartTime')
        if m.get('creatorAccountIds') is not None:
            self.creator_account_ids = m.get('creatorAccountIds')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageOrder') is not None:
            self.page_order = m.get('pageOrder')
        if m.get('pageSort') is not None:
            self.page_sort = m.get('pageSort')
        return self


class ListHostGroupsResponseBodyHostGroups(TeaModel):
    def __init__(
        self,
        aliyun_region: str = None,
        create_time: int = None,
        creator_account_id: str = None,
        description: str = None,
        ecs_label_key: str = None,
        ecs_label_value: str = None,
        ecs_type: str = None,
        host_num: int = None,
        id: int = None,
        modifier_account_id: str = None,
        name: str = None,
        service_connection_id: int = None,
        type: str = None,
        update_time: int = None,
    ):
        self.aliyun_region = aliyun_region
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.description = description
        self.ecs_label_key = ecs_label_key
        self.ecs_label_value = ecs_label_value
        self.ecs_type = ecs_type
        self.host_num = host_num
        # 323232
        self.id = id
        self.modifier_account_id = modifier_account_id
        self.name = name
        self.service_connection_id = service_connection_id
        self.type = type
        self.update_time = update_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_region is not None:
            result['aliyunRegion'] = self.aliyun_region
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.description is not None:
            result['description'] = self.description
        if self.ecs_label_key is not None:
            result['ecsLabelKey'] = self.ecs_label_key
        if self.ecs_label_value is not None:
            result['ecsLabelValue'] = self.ecs_label_value
        if self.ecs_type is not None:
            result['ecsType'] = self.ecs_type
        if self.host_num is not None:
            result['hostNum'] = self.host_num
        if self.id is not None:
            result['id'] = self.id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.name is not None:
            result['name'] = self.name
        if self.service_connection_id is not None:
            result['serviceConnectionId'] = self.service_connection_id
        if self.type is not None:
            result['type'] = self.type
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunRegion') is not None:
            self.aliyun_region = m.get('aliyunRegion')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('ecsLabelKey') is not None:
            self.ecs_label_key = m.get('ecsLabelKey')
        if m.get('ecsLabelValue') is not None:
            self.ecs_label_value = m.get('ecsLabelValue')
        if m.get('ecsType') is not None:
            self.ecs_type = m.get('ecsType')
        if m.get('hostNum') is not None:
            self.host_num = m.get('hostNum')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('serviceConnectionId') is not None:
            self.service_connection_id = m.get('serviceConnectionId')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        return self


class ListHostGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        host_groups: List[ListHostGroupsResponseBodyHostGroups] = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.host_groups = host_groups
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.host_groups:
            for k in self.host_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['hostGroups'] = []
        if self.host_groups is not None:
            for k in self.host_groups:
                result['hostGroups'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.host_groups = []
        if m.get('hostGroups') is not None:
            for k in m.get('hostGroups'):
                temp_model = ListHostGroupsResponseBodyHostGroups()
                self.host_groups.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListHostGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListHostGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListHostGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListJoinedOrganizationsResponseBodyOrganizations(TeaModel):
    def __init__(
        self,
        id: str = None,
        is_org_admin: bool = None,
        name: str = None,
    ):
        self.id = id
        self.is_org_admin = is_org_admin
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_org_admin is not None:
            result['isOrgAdmin'] = self.is_org_admin
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isOrgAdmin') is not None:
            self.is_org_admin = m.get('isOrgAdmin')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListJoinedOrganizationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        organizations: List[ListJoinedOrganizationsResponseBodyOrganizations] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.organizations = organizations
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.organizations:
            for k in self.organizations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['organizations'] = []
        if self.organizations is not None:
            for k in self.organizations:
                result['organizations'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.organizations = []
        if m.get('organizations') is not None:
            for k in m.get('organizations'):
                temp_model = ListJoinedOrganizationsResponseBodyOrganizations()
                self.organizations.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListJoinedOrganizationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListJoinedOrganizationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListJoinedOrganizationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMergeRequestCommentsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        comment_type: str = None,
        file_path: str = None,
        patch_set_biz_ids: List[str] = None,
        resolved: bool = None,
        state: str = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        self.comment_type = comment_type
        self.file_path = file_path
        self.patch_set_biz_ids = patch_set_biz_ids
        self.resolved = resolved
        self.state = state
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.comment_type is not None:
            result['commentType'] = self.comment_type
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.patch_set_biz_ids is not None:
            result['patchSetBizIds'] = self.patch_set_biz_ids
        if self.resolved is not None:
            result['resolved'] = self.resolved
        if self.state is not None:
            result['state'] = self.state
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('commentType') is not None:
            self.comment_type = m.get('commentType')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('patchSetBizIds') is not None:
            self.patch_set_biz_ids = m.get('patchSetBizIds')
        if m.get('resolved') is not None:
            self.resolved = m.get('resolved')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class ListMergeRequestCommentsResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        created_at: str = None,
        patch_set_biz_id: str = None,
        patch_set_name: str = None,
        patch_set_no: str = None,
        related_merge_item_type: str = None,
        short_id: str = None,
    ):
        self.commit_id = commit_id
        self.created_at = created_at
        self.patch_set_biz_id = patch_set_biz_id
        self.patch_set_name = patch_set_name
        self.patch_set_no = patch_set_no
        self.related_merge_item_type = related_merge_item_type
        self.short_id = short_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.patch_set_biz_id is not None:
            result['patchSetBizId'] = self.patch_set_biz_id
        if self.patch_set_name is not None:
            result['patchSetName'] = self.patch_set_name
        if self.patch_set_no is not None:
            result['patchSetNo'] = self.patch_set_no
        if self.related_merge_item_type is not None:
            result['relatedMergeItemType'] = self.related_merge_item_type
        if self.short_id is not None:
            result['shortId'] = self.short_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('patchSetBizId') is not None:
            self.patch_set_biz_id = m.get('patchSetBizId')
        if m.get('patchSetName') is not None:
            self.patch_set_name = m.get('patchSetName')
        if m.get('patchSetNo') is not None:
            self.patch_set_no = m.get('patchSetNo')
        if m.get('relatedMergeItemType') is not None:
            self.related_merge_item_type = m.get('relatedMergeItemType')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        return self


class ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments(TeaModel):
    def __init__(
        self,
        author: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor = None,
        comment_biz_id: str = None,
        comment_time: str = None,
        comment_type: str = None,
        content: str = None,
        deleted: bool = None,
        file_path: str = None,
        last_edit_time: str = None,
        line_number: str = None,
        parent_comment_biz_id: str = None,
        related_patch_set: ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet = None,
        resolved: bool = None,
        root_comment_biz_id: str = None,
        state: str = None,
    ):
        self.author = author
        self.comment_biz_id = comment_biz_id
        self.comment_time = comment_time
        self.comment_type = comment_type
        self.content = content
        self.deleted = deleted
        self.file_path = file_path
        self.last_edit_time = last_edit_time
        self.line_number = line_number
        self.parent_comment_biz_id = parent_comment_biz_id
        self.related_patch_set = related_patch_set
        self.resolved = resolved
        self.root_comment_biz_id = root_comment_biz_id
        self.state = state

    def validate(self):
        if self.author:
            self.author.validate()
        if self.related_patch_set:
            self.related_patch_set.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.comment_biz_id is not None:
            result['commentBizId'] = self.comment_biz_id
        if self.comment_time is not None:
            result['commentTime'] = self.comment_time
        if self.comment_type is not None:
            result['commentType'] = self.comment_type
        if self.content is not None:
            result['content'] = self.content
        if self.deleted is not None:
            result['deleted'] = self.deleted
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.last_edit_time is not None:
            result['lastEditTime'] = self.last_edit_time
        if self.line_number is not None:
            result['lineNumber'] = self.line_number
        if self.parent_comment_biz_id is not None:
            result['parentCommentBizId'] = self.parent_comment_biz_id
        if self.related_patch_set is not None:
            result['relatedPatchSet'] = self.related_patch_set.to_map()
        if self.resolved is not None:
            result['resolved'] = self.resolved
        if self.root_comment_biz_id is not None:
            result['rootCommentBizId'] = self.root_comment_biz_id
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('commentBizId') is not None:
            self.comment_biz_id = m.get('commentBizId')
        if m.get('commentTime') is not None:
            self.comment_time = m.get('commentTime')
        if m.get('commentType') is not None:
            self.comment_type = m.get('commentType')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('deleted') is not None:
            self.deleted = m.get('deleted')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('lastEditTime') is not None:
            self.last_edit_time = m.get('lastEditTime')
        if m.get('lineNumber') is not None:
            self.line_number = m.get('lineNumber')
        if m.get('parentCommentBizId') is not None:
            self.parent_comment_biz_id = m.get('parentCommentBizId')
        if m.get('relatedPatchSet') is not None:
            temp_model = ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildCommentsRelatedPatchSet()
            self.related_patch_set = temp_model.from_map(m['relatedPatchSet'])
        if m.get('resolved') is not None:
            self.resolved = m.get('resolved')
        if m.get('rootCommentBizId') is not None:
            self.root_comment_biz_id = m.get('rootCommentBizId')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        created_at: str = None,
        patch_set_biz_id: str = None,
        patch_set_name: str = None,
        patch_set_no: str = None,
        related_merge_item_type: str = None,
        short_id: str = None,
    ):
        self.commit_id = commit_id
        self.created_at = created_at
        self.patch_set_biz_id = patch_set_biz_id
        self.patch_set_name = patch_set_name
        self.patch_set_no = patch_set_no
        self.related_merge_item_type = related_merge_item_type
        self.short_id = short_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.patch_set_biz_id is not None:
            result['patchSetBizId'] = self.patch_set_biz_id
        if self.patch_set_name is not None:
            result['patchSetName'] = self.patch_set_name
        if self.patch_set_no is not None:
            result['patchSetNo'] = self.patch_set_no
        if self.related_merge_item_type is not None:
            result['relatedMergeItemType'] = self.related_merge_item_type
        if self.short_id is not None:
            result['shortId'] = self.short_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('patchSetBizId') is not None:
            self.patch_set_biz_id = m.get('patchSetBizId')
        if m.get('patchSetName') is not None:
            self.patch_set_name = m.get('patchSetName')
        if m.get('patchSetNo') is not None:
            self.patch_set_no = m.get('patchSetNo')
        if m.get('relatedMergeItemType') is not None:
            self.related_merge_item_type = m.get('relatedMergeItemType')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        return self


class ListMergeRequestCommentsResponseBodyResultChildComments(TeaModel):
    def __init__(
        self,
        author: ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor = None,
        comment_biz_id: str = None,
        comment_time: str = None,
        comment_type: str = None,
        content: str = None,
        deleted: bool = None,
        file_path: str = None,
        final_child_comments: List[ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments] = None,
        last_edit_time: str = None,
        line_number: str = None,
        parent_comment_biz_id: str = None,
        related_patch_set: ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet = None,
        resolved: bool = None,
        root_comment_biz_id: str = None,
        state: str = None,
    ):
        self.author = author
        self.comment_biz_id = comment_biz_id
        self.comment_time = comment_time
        self.comment_type = comment_type
        self.content = content
        self.deleted = deleted
        self.file_path = file_path
        self.final_child_comments = final_child_comments
        self.last_edit_time = last_edit_time
        self.line_number = line_number
        self.parent_comment_biz_id = parent_comment_biz_id
        self.related_patch_set = related_patch_set
        self.resolved = resolved
        self.root_comment_biz_id = root_comment_biz_id
        self.state = state

    def validate(self):
        if self.author:
            self.author.validate()
        if self.final_child_comments:
            for k in self.final_child_comments:
                if k:
                    k.validate()
        if self.related_patch_set:
            self.related_patch_set.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.comment_biz_id is not None:
            result['commentBizId'] = self.comment_biz_id
        if self.comment_time is not None:
            result['commentTime'] = self.comment_time
        if self.comment_type is not None:
            result['commentType'] = self.comment_type
        if self.content is not None:
            result['content'] = self.content
        if self.deleted is not None:
            result['deleted'] = self.deleted
        if self.file_path is not None:
            result['filePath'] = self.file_path
        result['finalChildComments'] = []
        if self.final_child_comments is not None:
            for k in self.final_child_comments:
                result['finalChildComments'].append(k.to_map() if k else None)
        if self.last_edit_time is not None:
            result['lastEditTime'] = self.last_edit_time
        if self.line_number is not None:
            result['lineNumber'] = self.line_number
        if self.parent_comment_biz_id is not None:
            result['parentCommentBizId'] = self.parent_comment_biz_id
        if self.related_patch_set is not None:
            result['relatedPatchSet'] = self.related_patch_set.to_map()
        if self.resolved is not None:
            result['resolved'] = self.resolved
        if self.root_comment_biz_id is not None:
            result['rootCommentBizId'] = self.root_comment_biz_id
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = ListMergeRequestCommentsResponseBodyResultChildCommentsAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('commentBizId') is not None:
            self.comment_biz_id = m.get('commentBizId')
        if m.get('commentTime') is not None:
            self.comment_time = m.get('commentTime')
        if m.get('commentType') is not None:
            self.comment_type = m.get('commentType')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('deleted') is not None:
            self.deleted = m.get('deleted')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        self.final_child_comments = []
        if m.get('finalChildComments') is not None:
            for k in m.get('finalChildComments'):
                temp_model = ListMergeRequestCommentsResponseBodyResultChildCommentsFinalChildComments()
                self.final_child_comments.append(temp_model.from_map(k))
        if m.get('lastEditTime') is not None:
            self.last_edit_time = m.get('lastEditTime')
        if m.get('lineNumber') is not None:
            self.line_number = m.get('lineNumber')
        if m.get('parentCommentBizId') is not None:
            self.parent_comment_biz_id = m.get('parentCommentBizId')
        if m.get('relatedPatchSet') is not None:
            temp_model = ListMergeRequestCommentsResponseBodyResultChildCommentsRelatedPatchSet()
            self.related_patch_set = temp_model.from_map(m['relatedPatchSet'])
        if m.get('resolved') is not None:
            self.resolved = m.get('resolved')
        if m.get('rootCommentBizId') is not None:
            self.root_comment_biz_id = m.get('rootCommentBizId')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class ListMergeRequestCommentsResponseBodyResultRelatedPatchSet(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        created_at: str = None,
        patch_set_biz_id: str = None,
        patch_set_name: str = None,
        patch_set_no: str = None,
        related_merge_item_type: str = None,
        short_id: str = None,
    ):
        self.commit_id = commit_id
        self.created_at = created_at
        self.patch_set_biz_id = patch_set_biz_id
        self.patch_set_name = patch_set_name
        self.patch_set_no = patch_set_no
        self.related_merge_item_type = related_merge_item_type
        self.short_id = short_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.patch_set_biz_id is not None:
            result['patchSetBizId'] = self.patch_set_biz_id
        if self.patch_set_name is not None:
            result['patchSetName'] = self.patch_set_name
        if self.patch_set_no is not None:
            result['patchSetNo'] = self.patch_set_no
        if self.related_merge_item_type is not None:
            result['relatedMergeItemType'] = self.related_merge_item_type
        if self.short_id is not None:
            result['shortId'] = self.short_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('patchSetBizId') is not None:
            self.patch_set_biz_id = m.get('patchSetBizId')
        if m.get('patchSetName') is not None:
            self.patch_set_name = m.get('patchSetName')
        if m.get('patchSetNo') is not None:
            self.patch_set_no = m.get('patchSetNo')
        if m.get('relatedMergeItemType') is not None:
            self.related_merge_item_type = m.get('relatedMergeItemType')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        return self


class ListMergeRequestCommentsResponseBodyResult(TeaModel):
    def __init__(
        self,
        author: ListMergeRequestCommentsResponseBodyResultAuthor = None,
        child_comments: List[ListMergeRequestCommentsResponseBodyResultChildComments] = None,
        comment_biz_id: str = None,
        comment_time: str = None,
        comment_type: str = None,
        content: str = None,
        deleted: bool = None,
        file_path: str = None,
        last_edit_time: str = None,
        line_number: str = None,
        parent_comment_biz_id: str = None,
        related_patch_set: ListMergeRequestCommentsResponseBodyResultRelatedPatchSet = None,
        resolved: bool = None,
        root_comment_biz_id: str = None,
        state: str = None,
    ):
        self.author = author
        self.child_comments = child_comments
        self.comment_biz_id = comment_biz_id
        self.comment_time = comment_time
        self.comment_type = comment_type
        self.content = content
        self.deleted = deleted
        self.file_path = file_path
        self.last_edit_time = last_edit_time
        self.line_number = line_number
        self.parent_comment_biz_id = parent_comment_biz_id
        self.related_patch_set = related_patch_set
        self.resolved = resolved
        self.root_comment_biz_id = root_comment_biz_id
        self.state = state

    def validate(self):
        if self.author:
            self.author.validate()
        if self.child_comments:
            for k in self.child_comments:
                if k:
                    k.validate()
        if self.related_patch_set:
            self.related_patch_set.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        result['childComments'] = []
        if self.child_comments is not None:
            for k in self.child_comments:
                result['childComments'].append(k.to_map() if k else None)
        if self.comment_biz_id is not None:
            result['commentBizId'] = self.comment_biz_id
        if self.comment_time is not None:
            result['commentTime'] = self.comment_time
        if self.comment_type is not None:
            result['commentType'] = self.comment_type
        if self.content is not None:
            result['content'] = self.content
        if self.deleted is not None:
            result['deleted'] = self.deleted
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.last_edit_time is not None:
            result['lastEditTime'] = self.last_edit_time
        if self.line_number is not None:
            result['lineNumber'] = self.line_number
        if self.parent_comment_biz_id is not None:
            result['parentCommentBizId'] = self.parent_comment_biz_id
        if self.related_patch_set is not None:
            result['relatedPatchSet'] = self.related_patch_set.to_map()
        if self.resolved is not None:
            result['resolved'] = self.resolved
        if self.root_comment_biz_id is not None:
            result['rootCommentBizId'] = self.root_comment_biz_id
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = ListMergeRequestCommentsResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        self.child_comments = []
        if m.get('childComments') is not None:
            for k in m.get('childComments'):
                temp_model = ListMergeRequestCommentsResponseBodyResultChildComments()
                self.child_comments.append(temp_model.from_map(k))
        if m.get('commentBizId') is not None:
            self.comment_biz_id = m.get('commentBizId')
        if m.get('commentTime') is not None:
            self.comment_time = m.get('commentTime')
        if m.get('commentType') is not None:
            self.comment_type = m.get('commentType')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('deleted') is not None:
            self.deleted = m.get('deleted')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('lastEditTime') is not None:
            self.last_edit_time = m.get('lastEditTime')
        if m.get('lineNumber') is not None:
            self.line_number = m.get('lineNumber')
        if m.get('parentCommentBizId') is not None:
            self.parent_comment_biz_id = m.get('parentCommentBizId')
        if m.get('relatedPatchSet') is not None:
            temp_model = ListMergeRequestCommentsResponseBodyResultRelatedPatchSet()
            self.related_patch_set = temp_model.from_map(m['relatedPatchSet'])
        if m.get('resolved') is not None:
            self.resolved = m.get('resolved')
        if m.get('rootCommentBizId') is not None:
            self.root_comment_biz_id = m.get('rootCommentBizId')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class ListMergeRequestCommentsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListMergeRequestCommentsResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListMergeRequestCommentsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListMergeRequestCommentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMergeRequestCommentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMergeRequestCommentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMergeRequestFilesReadsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        from_patch_set_biz_id: str = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
        to_patch_set_biz_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.from_patch_set_biz_id = from_patch_set_biz_id
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity
        # This parameter is required.
        self.to_patch_set_biz_id = to_patch_set_biz_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.from_patch_set_biz_id is not None:
            result['fromPatchSetBizId'] = self.from_patch_set_biz_id
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        if self.to_patch_set_biz_id is not None:
            result['toPatchSetBizId'] = self.to_patch_set_biz_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('fromPatchSetBizId') is not None:
            self.from_patch_set_biz_id = m.get('fromPatchSetBizId')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        if m.get('toPatchSetBizId') is not None:
            self.to_patch_set_biz_id = m.get('toPatchSetBizId')
        return self


class ListMergeRequestFilesReadsResponseBodyResultReadUsers(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        avatar_url: str = None,
        email: str = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.avatar_url = avatar_url
        self.email = email
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestFilesReadsResponseBodyResult(TeaModel):
    def __init__(
        self,
        deleted_file: str = None,
        new_file: bool = None,
        new_file_path: str = None,
        old_file_path: str = None,
        read_users: List[ListMergeRequestFilesReadsResponseBodyResultReadUsers] = None,
        renamed_file: str = None,
    ):
        self.deleted_file = deleted_file
        self.new_file = new_file
        self.new_file_path = new_file_path
        self.old_file_path = old_file_path
        self.read_users = read_users
        self.renamed_file = renamed_file

    def validate(self):
        if self.read_users:
            for k in self.read_users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deleted_file is not None:
            result['deletedFile'] = self.deleted_file
        if self.new_file is not None:
            result['newFile'] = self.new_file
        if self.new_file_path is not None:
            result['newFilePath'] = self.new_file_path
        if self.old_file_path is not None:
            result['oldFilePath'] = self.old_file_path
        result['readUsers'] = []
        if self.read_users is not None:
            for k in self.read_users:
                result['readUsers'].append(k.to_map() if k else None)
        if self.renamed_file is not None:
            result['renamedFile'] = self.renamed_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deletedFile') is not None:
            self.deleted_file = m.get('deletedFile')
        if m.get('newFile') is not None:
            self.new_file = m.get('newFile')
        if m.get('newFilePath') is not None:
            self.new_file_path = m.get('newFilePath')
        if m.get('oldFilePath') is not None:
            self.old_file_path = m.get('oldFilePath')
        self.read_users = []
        if m.get('readUsers') is not None:
            for k in m.get('readUsers'):
                temp_model = ListMergeRequestFilesReadsResponseBodyResultReadUsers()
                self.read_users.append(temp_model.from_map(k))
        if m.get('renamedFile') is not None:
            self.renamed_file = m.get('renamedFile')
        return self


class ListMergeRequestFilesReadsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListMergeRequestFilesReadsResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListMergeRequestFilesReadsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListMergeRequestFilesReadsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMergeRequestFilesReadsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMergeRequestFilesReadsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMergeRequestLabelsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class ListMergeRequestLabelsResponseBodyResult(TeaModel):
    def __init__(
        self,
        color: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
    ):
        self.color = color
        self.description = description
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListMergeRequestLabelsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListMergeRequestLabelsResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListMergeRequestLabelsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListMergeRequestLabelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMergeRequestLabelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMergeRequestLabelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMergeRequestPatchSetsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        local_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.local_id = local_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class ListMergeRequestPatchSetsResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        created_at: str = None,
        patch_set_biz_id: str = None,
        patch_set_name: str = None,
        patch_set_no: int = None,
        related_merge_item_type: str = None,
        short_commit_id: str = None,
    ):
        self.commit_id = commit_id
        self.created_at = created_at
        self.patch_set_biz_id = patch_set_biz_id
        self.patch_set_name = patch_set_name
        self.patch_set_no = patch_set_no
        self.related_merge_item_type = related_merge_item_type
        self.short_commit_id = short_commit_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.patch_set_biz_id is not None:
            result['patchSetBizId'] = self.patch_set_biz_id
        if self.patch_set_name is not None:
            result['patchSetName'] = self.patch_set_name
        if self.patch_set_no is not None:
            result['patchSetNo'] = self.patch_set_no
        if self.related_merge_item_type is not None:
            result['relatedMergeItemType'] = self.related_merge_item_type
        if self.short_commit_id is not None:
            result['shortCommitId'] = self.short_commit_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('patchSetBizId') is not None:
            self.patch_set_biz_id = m.get('patchSetBizId')
        if m.get('patchSetName') is not None:
            self.patch_set_name = m.get('patchSetName')
        if m.get('patchSetNo') is not None:
            self.patch_set_no = m.get('patchSetNo')
        if m.get('relatedMergeItemType') is not None:
            self.related_merge_item_type = m.get('relatedMergeItemType')
        if m.get('shortCommitId') is not None:
            self.short_commit_id = m.get('shortCommitId')
        return self


class ListMergeRequestPatchSetsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListMergeRequestPatchSetsResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListMergeRequestPatchSetsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListMergeRequestPatchSetsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMergeRequestPatchSetsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMergeRequestPatchSetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMergeRequestsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        author_ids: str = None,
        created_after: str = None,
        created_before: str = None,
        filter: str = None,
        group_ids: str = None,
        label_ids: str = None,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        project_ids: str = None,
        reviewer_ids: str = None,
        search: str = None,
        sort: str = None,
        state: str = None,
    ):
        self.access_token = access_token
        self.author_ids = author_ids
        self.created_after = created_after
        self.created_before = created_before
        self.filter = filter
        self.group_ids = group_ids
        self.label_ids = label_ids
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.project_ids = project_ids
        self.reviewer_ids = reviewer_ids
        self.search = search
        self.sort = sort
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.author_ids is not None:
            result['authorIds'] = self.author_ids
        if self.created_after is not None:
            result['createdAfter'] = self.created_after
        if self.created_before is not None:
            result['createdBefore'] = self.created_before
        if self.filter is not None:
            result['filter'] = self.filter
        if self.group_ids is not None:
            result['groupIds'] = self.group_ids
        if self.label_ids is not None:
            result['labelIds'] = self.label_ids
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.project_ids is not None:
            result['projectIds'] = self.project_ids
        if self.reviewer_ids is not None:
            result['reviewerIds'] = self.reviewer_ids
        if self.search is not None:
            result['search'] = self.search
        if self.sort is not None:
            result['sort'] = self.sort
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('authorIds') is not None:
            self.author_ids = m.get('authorIds')
        if m.get('createdAfter') is not None:
            self.created_after = m.get('createdAfter')
        if m.get('createdBefore') is not None:
            self.created_before = m.get('createdBefore')
        if m.get('filter') is not None:
            self.filter = m.get('filter')
        if m.get('groupIds') is not None:
            self.group_ids = m.get('groupIds')
        if m.get('labelIds') is not None:
            self.label_ids = m.get('labelIds')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('projectIds') is not None:
            self.project_ids = m.get('projectIds')
        if m.get('reviewerIds') is not None:
            self.reviewer_ids = m.get('reviewerIds')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class ListMergeRequestsResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestsResponseBodyResultLabels(TeaModel):
    def __init__(
        self,
        color: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
    ):
        self.color = color
        self.description = description
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListMergeRequestsResponseBodyResultReviewers(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        has_commented: bool = None,
        has_reviewed: bool = None,
        id: int = None,
        name: str = None,
        review_opinion_status: str = None,
        review_time: str = None,
        state: str = None,
        status: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.has_commented = has_commented
        self.has_reviewed = has_reviewed
        self.id = id
        self.name = name
        self.review_opinion_status = review_opinion_status
        self.review_time = review_time
        self.state = state
        self.status = status
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.has_commented is not None:
            result['hasCommented'] = self.has_commented
        if self.has_reviewed is not None:
            result['hasReviewed'] = self.has_reviewed
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.review_opinion_status is not None:
            result['reviewOpinionStatus'] = self.review_opinion_status
        if self.review_time is not None:
            result['reviewTime'] = self.review_time
        if self.state is not None:
            result['state'] = self.state
        if self.status is not None:
            result['status'] = self.status
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('hasCommented') is not None:
            self.has_commented = m.get('hasCommented')
        if m.get('hasReviewed') is not None:
            self.has_reviewed = m.get('hasReviewed')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('reviewOpinionStatus') is not None:
            self.review_opinion_status = m.get('reviewOpinionStatus')
        if m.get('reviewTime') is not None:
            self.review_time = m.get('reviewTime')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestsResponseBodyResultSubscribers(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListMergeRequestsResponseBodyResult(TeaModel):
    def __init__(
        self,
        author: ListMergeRequestsResponseBodyResultAuthor = None,
        created_at: str = None,
        creation_method: str = None,
        description: str = None,
        detail_url: str = None,
        id: int = None,
        iid: int = None,
        labels: List[ListMergeRequestsResponseBodyResultLabels] = None,
        local_id: int = None,
        merged_revision: str = None,
        mr_biz_id: str = None,
        name_with_namespace: str = None,
        new_merge_request_identifier: bool = None,
        new_version_state: str = None,
        project_id: int = None,
        reviewers: List[ListMergeRequestsResponseBodyResultReviewers] = None,
        source_branch: str = None,
        source_project_id: int = None,
        source_type: str = None,
        ssh_url: str = None,
        state: str = None,
        subscribers: List[ListMergeRequestsResponseBodyResultSubscribers] = None,
        support_merge_ffonly: bool = None,
        target_branch: str = None,
        target_project_id: int = None,
        target_type: str = None,
        title: str = None,
        updated_at: str = None,
        web_url: str = None,
        work_in_progress: bool = None,
    ):
        self.author = author
        self.created_at = created_at
        self.creation_method = creation_method
        self.description = description
        self.detail_url = detail_url
        self.id = id
        self.iid = iid
        self.labels = labels
        self.local_id = local_id
        self.merged_revision = merged_revision
        self.mr_biz_id = mr_biz_id
        self.name_with_namespace = name_with_namespace
        self.new_merge_request_identifier = new_merge_request_identifier
        self.new_version_state = new_version_state
        self.project_id = project_id
        self.reviewers = reviewers
        self.source_branch = source_branch
        self.source_project_id = source_project_id
        self.source_type = source_type
        self.ssh_url = ssh_url
        self.state = state
        self.subscribers = subscribers
        self.support_merge_ffonly = support_merge_ffonly
        self.target_branch = target_branch
        self.target_project_id = target_project_id
        self.target_type = target_type
        self.title = title
        self.updated_at = updated_at
        self.web_url = web_url
        self.work_in_progress = work_in_progress

    def validate(self):
        if self.author:
            self.author.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.reviewers:
            for k in self.reviewers:
                if k:
                    k.validate()
        if self.subscribers:
            for k in self.subscribers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creation_method is not None:
            result['creationMethod'] = self.creation_method
        if self.description is not None:
            result['description'] = self.description
        if self.detail_url is not None:
            result['detailUrl'] = self.detail_url
        if self.id is not None:
            result['id'] = self.id
        if self.iid is not None:
            result['iid'] = self.iid
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.merged_revision is not None:
            result['mergedRevision'] = self.merged_revision
        if self.mr_biz_id is not None:
            result['mrBizId'] = self.mr_biz_id
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.new_merge_request_identifier is not None:
            result['newMergeRequestIdentifier'] = self.new_merge_request_identifier
        if self.new_version_state is not None:
            result['newVersionState'] = self.new_version_state
        if self.project_id is not None:
            result['projectId'] = self.project_id
        result['reviewers'] = []
        if self.reviewers is not None:
            for k in self.reviewers:
                result['reviewers'].append(k.to_map() if k else None)
        if self.source_branch is not None:
            result['sourceBranch'] = self.source_branch
        if self.source_project_id is not None:
            result['sourceProjectId'] = self.source_project_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.ssh_url is not None:
            result['sshUrl'] = self.ssh_url
        if self.state is not None:
            result['state'] = self.state
        result['subscribers'] = []
        if self.subscribers is not None:
            for k in self.subscribers:
                result['subscribers'].append(k.to_map() if k else None)
        if self.support_merge_ffonly is not None:
            result['supportMergeFFOnly'] = self.support_merge_ffonly
        if self.target_branch is not None:
            result['targetBranch'] = self.target_branch
        if self.target_project_id is not None:
            result['targetProjectId'] = self.target_project_id
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.title is not None:
            result['title'] = self.title
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        if self.work_in_progress is not None:
            result['workInProgress'] = self.work_in_progress
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = ListMergeRequestsResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creationMethod') is not None:
            self.creation_method = m.get('creationMethod')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('detailUrl') is not None:
            self.detail_url = m.get('detailUrl')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('iid') is not None:
            self.iid = m.get('iid')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = ListMergeRequestsResponseBodyResultLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('mergedRevision') is not None:
            self.merged_revision = m.get('mergedRevision')
        if m.get('mrBizId') is not None:
            self.mr_biz_id = m.get('mrBizId')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('newMergeRequestIdentifier') is not None:
            self.new_merge_request_identifier = m.get('newMergeRequestIdentifier')
        if m.get('newVersionState') is not None:
            self.new_version_state = m.get('newVersionState')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        self.reviewers = []
        if m.get('reviewers') is not None:
            for k in m.get('reviewers'):
                temp_model = ListMergeRequestsResponseBodyResultReviewers()
                self.reviewers.append(temp_model.from_map(k))
        if m.get('sourceBranch') is not None:
            self.source_branch = m.get('sourceBranch')
        if m.get('sourceProjectId') is not None:
            self.source_project_id = m.get('sourceProjectId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('sshUrl') is not None:
            self.ssh_url = m.get('sshUrl')
        if m.get('state') is not None:
            self.state = m.get('state')
        self.subscribers = []
        if m.get('subscribers') is not None:
            for k in m.get('subscribers'):
                temp_model = ListMergeRequestsResponseBodyResultSubscribers()
                self.subscribers.append(temp_model.from_map(k))
        if m.get('supportMergeFFOnly') is not None:
            self.support_merge_ffonly = m.get('supportMergeFFOnly')
        if m.get('targetBranch') is not None:
            self.target_branch = m.get('targetBranch')
        if m.get('targetProjectId') is not None:
            self.target_project_id = m.get('targetProjectId')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        if m.get('workInProgress') is not None:
            self.work_in_progress = m.get('workInProgress')
        return self


class ListMergeRequestsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListMergeRequestsResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        # Id of the request
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListMergeRequestsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListMergeRequestsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListMergeRequestsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMergeRequestsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOrganizationMembersRequest(TeaModel):
    def __init__(
        self,
        contains_extern_info: bool = None,
        extern_uid: str = None,
        join_time_from: int = None,
        join_time_to: int = None,
        max_results: int = None,
        next_token: str = None,
        organization_member_name: str = None,
        provider: str = None,
        state: str = None,
    ):
        # 返回信息中是否包含第三方信息，默认不包含。
        self.contains_extern_info = contains_extern_info
        self.extern_uid = extern_uid
        self.join_time_from = join_time_from
        self.join_time_to = join_time_to
        self.max_results = max_results
        self.next_token = next_token
        self.organization_member_name = organization_member_name
        self.provider = provider
        self.state = state

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contains_extern_info is not None:
            result['containsExternInfo'] = self.contains_extern_info
        if self.extern_uid is not None:
            result['externUid'] = self.extern_uid
        if self.join_time_from is not None:
            result['joinTimeFrom'] = self.join_time_from
        if self.join_time_to is not None:
            result['joinTimeTo'] = self.join_time_to
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.organization_member_name is not None:
            result['organizationMemberName'] = self.organization_member_name
        if self.provider is not None:
            result['provider'] = self.provider
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('containsExternInfo') is not None:
            self.contains_extern_info = m.get('containsExternInfo')
        if m.get('externUid') is not None:
            self.extern_uid = m.get('externUid')
        if m.get('joinTimeFrom') is not None:
            self.join_time_from = m.get('joinTimeFrom')
        if m.get('joinTimeTo') is not None:
            self.join_time_to = m.get('joinTimeTo')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('organizationMemberName') is not None:
            self.organization_member_name = m.get('organizationMemberName')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class ListOrganizationMembersResponseBodyMembersIdentities(TeaModel):
    def __init__(
        self,
        extern_uid: str = None,
        provider: str = None,
    ):
        self.extern_uid = extern_uid
        self.provider = provider

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extern_uid is not None:
            result['externUid'] = self.extern_uid
        if self.provider is not None:
            result['provider'] = self.provider
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('externUid') is not None:
            self.extern_uid = m.get('externUid')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        return self


class ListOrganizationMembersResponseBodyMembers(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        birthday: int = None,
        dept_lists: List[str] = None,
        email: str = None,
        hired_date: int = None,
        identities: ListOrganizationMembersResponseBodyMembersIdentities = None,
        job_number: str = None,
        join_time: int = None,
        last_visit_time: int = None,
        mobile: str = None,
        organization_member_name: str = None,
        organization_role_id: str = None,
        organization_role_name: str = None,
        state: str = None,
    ):
        self.account_id = account_id
        self.birthday = birthday
        self.dept_lists = dept_lists
        self.email = email
        self.hired_date = hired_date
        self.identities = identities
        self.job_number = job_number
        self.join_time = join_time
        self.last_visit_time = last_visit_time
        self.mobile = mobile
        self.organization_member_name = organization_member_name
        self.organization_role_id = organization_role_id
        self.organization_role_name = organization_role_name
        self.state = state

    def validate(self):
        if self.identities:
            self.identities.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.birthday is not None:
            result['birthday'] = self.birthday
        if self.dept_lists is not None:
            result['deptLists'] = self.dept_lists
        if self.email is not None:
            result['email'] = self.email
        if self.hired_date is not None:
            result['hiredDate'] = self.hired_date
        if self.identities is not None:
            result['identities'] = self.identities.to_map()
        if self.job_number is not None:
            result['jobNumber'] = self.job_number
        if self.join_time is not None:
            result['joinTime'] = self.join_time
        if self.last_visit_time is not None:
            result['lastVisitTime'] = self.last_visit_time
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.organization_member_name is not None:
            result['organizationMemberName'] = self.organization_member_name
        if self.organization_role_id is not None:
            result['organizationRoleId'] = self.organization_role_id
        if self.organization_role_name is not None:
            result['organizationRoleName'] = self.organization_role_name
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('birthday') is not None:
            self.birthday = m.get('birthday')
        if m.get('deptLists') is not None:
            self.dept_lists = m.get('deptLists')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('hiredDate') is not None:
            self.hired_date = m.get('hiredDate')
        if m.get('identities') is not None:
            temp_model = ListOrganizationMembersResponseBodyMembersIdentities()
            self.identities = temp_model.from_map(m['identities'])
        if m.get('jobNumber') is not None:
            self.job_number = m.get('jobNumber')
        if m.get('joinTime') is not None:
            self.join_time = m.get('joinTime')
        if m.get('lastVisitTime') is not None:
            self.last_visit_time = m.get('lastVisitTime')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('organizationMemberName') is not None:
            self.organization_member_name = m.get('organizationMemberName')
        if m.get('organizationRoleId') is not None:
            self.organization_role_id = m.get('organizationRoleId')
        if m.get('organizationRoleName') is not None:
            self.organization_role_name = m.get('organizationRoleName')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class ListOrganizationMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        members: List[ListOrganizationMembersResponseBodyMembers] = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.members = members
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['members'] = []
        if self.members is not None:
            for k in self.members:
                result['members'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.members = []
        if m.get('members') is not None:
            for k in m.get('members'):
                temp_model = ListOrganizationMembersResponseBodyMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListOrganizationMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOrganizationMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOrganizationMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOrganizationsRequest(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        access_token: str = None,
        min_access_level: int = None,
    ):
        self.access_level = access_level
        self.access_token = access_token
        self.min_access_level = min_access_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.min_access_level is not None:
            result['minAccessLevel'] = self.min_access_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('minAccessLevel') is not None:
            self.min_access_level = m.get('minAccessLevel')
        return self


class ListOrganizationsResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        id: int = None,
        namespace_id: str = None,
        organization_alias: str = None,
        organization_id: str = None,
        organization_name: str = None,
        organization_role: str = None,
    ):
        self.access_level = access_level
        self.id = id
        self.namespace_id = namespace_id
        self.organization_alias = organization_alias
        self.organization_id = organization_id
        self.organization_name = organization_name
        self.organization_role = organization_role

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.id is not None:
            result['id'] = self.id
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.organization_alias is not None:
            result['organizationAlias'] = self.organization_alias
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.organization_name is not None:
            result['organizationName'] = self.organization_name
        if self.organization_role is not None:
            result['organizationRole'] = self.organization_role
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('organizationAlias') is not None:
            self.organization_alias = m.get('organizationAlias')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('organizationName') is not None:
            self.organization_name = m.get('organizationName')
        if m.get('organizationRole') is not None:
            self.organization_role = m.get('organizationRole')
        return self


class ListOrganizationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListOrganizationsResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListOrganizationsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListOrganizationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListOrganizationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOrganizationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineGroupPipelinesRequest(TeaModel):
    def __init__(
        self,
        create_end_time: int = None,
        create_start_time: int = None,
        execute_end_time: int = None,
        execute_start_time: int = None,
        max_results: int = None,
        next_token: str = None,
        pipeline_name: str = None,
        result_status_list: str = None,
    ):
        self.create_end_time = create_end_time
        self.create_start_time = create_start_time
        self.execute_end_time = execute_end_time
        self.execute_start_time = execute_start_time
        self.max_results = max_results
        self.next_token = next_token
        self.pipeline_name = pipeline_name
        self.result_status_list = result_status_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_end_time is not None:
            result['createEndTime'] = self.create_end_time
        if self.create_start_time is not None:
            result['createStartTime'] = self.create_start_time
        if self.execute_end_time is not None:
            result['executeEndTime'] = self.execute_end_time
        if self.execute_start_time is not None:
            result['executeStartTime'] = self.execute_start_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.pipeline_name is not None:
            result['pipelineName'] = self.pipeline_name
        if self.result_status_list is not None:
            result['resultStatusList'] = self.result_status_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createEndTime') is not None:
            self.create_end_time = m.get('createEndTime')
        if m.get('createStartTime') is not None:
            self.create_start_time = m.get('createStartTime')
        if m.get('executeEndTime') is not None:
            self.execute_end_time = m.get('executeEndTime')
        if m.get('executeStartTime') is not None:
            self.execute_start_time = m.get('executeStartTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pipelineName') is not None:
            self.pipeline_name = m.get('pipelineName')
        if m.get('resultStatusList') is not None:
            self.result_status_list = m.get('resultStatusList')
        return self


class ListPipelineGroupPipelinesResponseBodyPipelines(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        pipeline_id: int = None,
        pipeline_name: str = None,
    ):
        self.create_time = create_time
        self.pipeline_id = pipeline_id
        self.pipeline_name = pipeline_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['pipelineName'] = self.pipeline_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineName') is not None:
            self.pipeline_name = m.get('pipelineName')
        return self


class ListPipelineGroupPipelinesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        next_token: str = None,
        pipelines: List[ListPipelineGroupPipelinesResponseBodyPipelines] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.next_token = next_token
        self.pipelines = pipelines
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.pipelines:
            for k in self.pipelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['pipelines'] = []
        if self.pipelines is not None:
            for k in self.pipelines:
                result['pipelines'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.pipelines = []
        if m.get('pipelines') is not None:
            for k in m.get('pipelines'):
                temp_model = ListPipelineGroupPipelinesResponseBodyPipelines()
                self.pipelines.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPipelineGroupPipelinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineGroupPipelinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineGroupPipelinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineGroupsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class ListPipelineGroupsResponseBodyPipelineGroups(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        name: str = None,
    ):
        self.create_time = create_time
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListPipelineGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        next_token: str = None,
        pipeline_groups: List[ListPipelineGroupsResponseBodyPipelineGroups] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.next_token = next_token
        self.pipeline_groups = pipeline_groups
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.pipeline_groups:
            for k in self.pipeline_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['pipelineGroups'] = []
        if self.pipeline_groups is not None:
            for k in self.pipeline_groups:
                result['pipelineGroups'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.pipeline_groups = []
        if m.get('pipelineGroups') is not None:
            for k in m.get('pipelineGroups'):
                temp_model = ListPipelineGroupsResponseBodyPipelineGroups()
                self.pipeline_groups.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPipelineGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineJobHistorysRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        identifier: str = None,
        max_results: int = None,
        next_token: str = None,
    ):
        # This parameter is required.
        self.category = category
        # This parameter is required.
        self.identifier = identifier
        # This parameter is required.
        self.max_results = max_results
        self.next_token = next_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        return self


class ListPipelineJobHistorysResponseBodyJobs(TeaModel):
    def __init__(
        self,
        execute_number: int = None,
        identifier: str = None,
        job_id: int = None,
        job_name: str = None,
        operator_account_id: str = None,
        pipeline_id: int = None,
        pipeline_run_id: int = None,
        sources: str = None,
        status: str = None,
    ):
        self.execute_number = execute_number
        self.identifier = identifier
        self.job_id = job_id
        self.job_name = job_name
        self.operator_account_id = operator_account_id
        self.pipeline_id = pipeline_id
        self.pipeline_run_id = pipeline_run_id
        self.sources = sources
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.execute_number is not None:
            result['executeNumber'] = self.execute_number
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.job_id is not None:
            result['jobId'] = self.job_id
        if self.job_name is not None:
            result['jobName'] = self.job_name
        if self.operator_account_id is not None:
            result['operatorAccountId'] = self.operator_account_id
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_run_id is not None:
            result['pipelineRunId'] = self.pipeline_run_id
        if self.sources is not None:
            result['sources'] = self.sources
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('executeNumber') is not None:
            self.execute_number = m.get('executeNumber')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('jobId') is not None:
            self.job_id = m.get('jobId')
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        if m.get('operatorAccountId') is not None:
            self.operator_account_id = m.get('operatorAccountId')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineRunId') is not None:
            self.pipeline_run_id = m.get('pipelineRunId')
        if m.get('sources') is not None:
            self.sources = m.get('sources')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class ListPipelineJobHistorysResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        jobs: List[ListPipelineJobHistorysResponseBodyJobs] = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.jobs = jobs
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['jobs'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.jobs = []
        if m.get('jobs') is not None:
            for k in m.get('jobs'):
                temp_model = ListPipelineJobHistorysResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPipelineJobHistorysResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineJobHistorysResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineJobHistorysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineJobsRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
    ):
        # This parameter is required.
        self.category = category

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        return self


class ListPipelineJobsResponseBodyJobs(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        job_name: str = None,
        last_job_id: int = None,
        last_job_params: str = None,
    ):
        self.identifier = identifier
        self.job_name = job_name
        self.last_job_id = last_job_id
        self.last_job_params = last_job_params

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.job_name is not None:
            result['jobName'] = self.job_name
        if self.last_job_id is not None:
            result['lastJobId'] = self.last_job_id
        if self.last_job_params is not None:
            result['lastJobParams'] = self.last_job_params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('jobName') is not None:
            self.job_name = m.get('jobName')
        if m.get('lastJobId') is not None:
            self.last_job_id = m.get('lastJobId')
        if m.get('lastJobParams') is not None:
            self.last_job_params = m.get('lastJobParams')
        return self


class ListPipelineJobsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        jobs: List[ListPipelineJobsResponseBodyJobs] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.jobs = jobs
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['jobs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.jobs = []
        if m.get('jobs') is not None:
            for k in m.get('jobs'):
                temp_model = ListPipelineJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListPipelineJobsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineJobsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineRelationsRequest(TeaModel):
    def __init__(
        self,
        rel_object_type: str = None,
    ):
        # This parameter is required.
        self.rel_object_type = rel_object_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rel_object_type is not None:
            result['relObjectType'] = self.rel_object_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('relObjectType') is not None:
            self.rel_object_type = m.get('relObjectType')
        return self


class ListPipelineRelationsResponseBodyPipelineRelations(TeaModel):
    def __init__(
        self,
        ref_object_id: int = None,
    ):
        self.ref_object_id = ref_object_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ref_object_id is not None:
            result['refObjectId'] = self.ref_object_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('refObjectId') is not None:
            self.ref_object_id = m.get('refObjectId')
        return self


class ListPipelineRelationsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipeline_relations: List[ListPipelineRelationsResponseBodyPipelineRelations] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipeline_relations = pipeline_relations
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.pipeline_relations:
            for k in self.pipeline_relations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        result['pipelineRelations'] = []
        if self.pipeline_relations is not None:
            for k in self.pipeline_relations:
                result['pipelineRelations'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        self.pipeline_relations = []
        if m.get('pipelineRelations') is not None:
            for k in m.get('pipelineRelations'):
                temp_model = ListPipelineRelationsResponseBodyPipelineRelations()
                self.pipeline_relations.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListPipelineRelationsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineRelationsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineRelationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelineRunsRequest(TeaModel):
    def __init__(
        self,
        end_time: int = None,
        max_results: int = None,
        next_token: str = None,
        start_time: int = None,
        status: str = None,
        trigger_mode: int = None,
    ):
        self.end_time = end_time
        self.max_results = max_results
        self.next_token = next_token
        self.start_time = start_time
        self.status = status
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        if self.trigger_mode is not None:
            result['triggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('triggerMode') is not None:
            self.trigger_mode = m.get('triggerMode')
        return self


class ListPipelineRunsResponseBodyPipelineRuns(TeaModel):
    def __init__(
        self,
        creator_account_id: str = None,
        end_time: int = None,
        pipeline_id: int = None,
        pipeline_run_id: int = None,
        start_time: int = None,
        status: str = None,
        trigger_mode: int = None,
    ):
        self.creator_account_id = creator_account_id
        self.end_time = end_time
        self.pipeline_id = pipeline_id
        self.pipeline_run_id = pipeline_run_id
        self.start_time = start_time
        self.status = status
        self.trigger_mode = trigger_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.end_time is not None:
            result['endTime'] = self.end_time
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_run_id is not None:
            result['pipelineRunId'] = self.pipeline_run_id
        if self.start_time is not None:
            result['startTime'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        if self.trigger_mode is not None:
            result['triggerMode'] = self.trigger_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('endTime') is not None:
            self.end_time = m.get('endTime')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineRunId') is not None:
            self.pipeline_run_id = m.get('pipelineRunId')
        if m.get('startTime') is not None:
            self.start_time = m.get('startTime')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('triggerMode') is not None:
            self.trigger_mode = m.get('triggerMode')
        return self


class ListPipelineRunsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        next_token: str = None,
        pipeline_runs: List[ListPipelineRunsResponseBodyPipelineRuns] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.next_token = next_token
        self.pipeline_runs = pipeline_runs
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.pipeline_runs:
            for k in self.pipeline_runs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['pipelineRuns'] = []
        if self.pipeline_runs is not None:
            for k in self.pipeline_runs:
                result['pipelineRuns'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.pipeline_runs = []
        if m.get('pipelineRuns') is not None:
            for k in m.get('pipelineRuns'):
                temp_model = ListPipelineRunsResponseBodyPipelineRuns()
                self.pipeline_runs.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPipelineRunsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelineRunsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelineRunsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelinesRequest(TeaModel):
    def __init__(
        self,
        create_end_time: int = None,
        create_start_time: int = None,
        creator_account_ids: str = None,
        execute_account_ids: str = None,
        execute_end_time: int = None,
        execute_start_time: int = None,
        max_results: int = None,
        next_token: str = None,
        pipeline_name: str = None,
        status_list: str = None,
    ):
        self.create_end_time = create_end_time
        self.create_start_time = create_start_time
        self.creator_account_ids = creator_account_ids
        self.execute_account_ids = execute_account_ids
        self.execute_end_time = execute_end_time
        self.execute_start_time = execute_start_time
        self.max_results = max_results
        self.next_token = next_token
        self.pipeline_name = pipeline_name
        self.status_list = status_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_end_time is not None:
            result['createEndTime'] = self.create_end_time
        if self.create_start_time is not None:
            result['createStartTime'] = self.create_start_time
        if self.creator_account_ids is not None:
            result['creatorAccountIds'] = self.creator_account_ids
        if self.execute_account_ids is not None:
            result['executeAccountIds'] = self.execute_account_ids
        if self.execute_end_time is not None:
            result['executeEndTime'] = self.execute_end_time
        if self.execute_start_time is not None:
            result['executeStartTime'] = self.execute_start_time
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.pipeline_name is not None:
            result['pipelineName'] = self.pipeline_name
        if self.status_list is not None:
            result['statusList'] = self.status_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createEndTime') is not None:
            self.create_end_time = m.get('createEndTime')
        if m.get('createStartTime') is not None:
            self.create_start_time = m.get('createStartTime')
        if m.get('creatorAccountIds') is not None:
            self.creator_account_ids = m.get('creatorAccountIds')
        if m.get('executeAccountIds') is not None:
            self.execute_account_ids = m.get('executeAccountIds')
        if m.get('executeEndTime') is not None:
            self.execute_end_time = m.get('executeEndTime')
        if m.get('executeStartTime') is not None:
            self.execute_start_time = m.get('executeStartTime')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pipelineName') is not None:
            self.pipeline_name = m.get('pipelineName')
        if m.get('statusList') is not None:
            self.status_list = m.get('statusList')
        return self


class ListPipelinesResponseBodyPipelines(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_account_id: str = None,
        group_id: int = None,
        pipeline_id: int = None,
        pipeline_name: str = None,
    ):
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.group_id = group_id
        self.pipeline_id = pipeline_id
        self.pipeline_name = pipeline_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        if self.pipeline_name is not None:
            result['pipelineName'] = self.pipeline_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        if m.get('pipelineName') is not None:
            self.pipeline_name = m.get('pipelineName')
        return self


class ListPipelinesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        next_token: str = None,
        pipelines: List[ListPipelinesResponseBodyPipelines] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.next_token = next_token
        self.pipelines = pipelines
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.pipelines:
            for k in self.pipelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['pipelines'] = []
        if self.pipelines is not None:
            for k in self.pipelines:
                result['pipelines'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.pipelines = []
        if m.get('pipelines') is not None:
            for k in m.get('pipelines'):
                temp_model = ListPipelinesResponseBodyPipelines()
                self.pipelines.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListPipelinesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPipelinesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectLabelsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        repository_identity: str = None,
        search: str = None,
        sort: str = None,
        with_counts: bool = None,
    ):
        self.access_token = access_token
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        # This parameter is required.
        self.repository_identity = repository_identity
        self.search = search
        self.sort = sort
        self.with_counts = with_counts

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        if self.search is not None:
            result['search'] = self.search
        if self.sort is not None:
            result['sort'] = self.sort
        if self.with_counts is not None:
            result['withCounts'] = self.with_counts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('withCounts') is not None:
            self.with_counts = m.get('withCounts')
        return self


class ListProjectLabelsResponseBodyResult(TeaModel):
    def __init__(
        self,
        color: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
        open_merge_requests_count: int = None,
    ):
        self.color = color
        self.description = description
        self.id = id
        self.name = name
        self.open_merge_requests_count = open_merge_requests_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.open_merge_requests_count is not None:
            result['openMergeRequestsCount'] = self.open_merge_requests_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('openMergeRequestsCount') is not None:
            self.open_merge_requests_count = m.get('openMergeRequestsCount')
        return self


class ListProjectLabelsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListProjectLabelsResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListProjectLabelsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListProjectLabelsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectLabelsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectLabelsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectMembersRequest(TeaModel):
    def __init__(
        self,
        target_type: str = None,
    ):
        # This parameter is required.
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_type is not None:
            result['targetType'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        return self


class ListProjectMembersResponseBodyMembersDivision(TeaModel):
    def __init__(
        self,
        identifier: str = None,
    ):
        self.identifier = identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        return self


class ListProjectMembersResponseBodyMembersOrganizationUserInfo(TeaModel):
    def __init__(
        self,
        organization_identifier: str = None,
    ):
        self.organization_identifier = organization_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_identifier is not None:
            result['organizationIdentifier'] = self.organization_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationIdentifier') is not None:
            self.organization_identifier = m.get('organizationIdentifier')
        return self


class ListProjectMembersResponseBodyMembers(TeaModel):
    def __init__(
        self,
        account: str = None,
        avatar: str = None,
        ding_talk_id: str = None,
        display_name: str = None,
        display_nick_name: str = None,
        display_real_name: str = None,
        division: ListProjectMembersResponseBodyMembersDivision = None,
        email: str = None,
        gender: str = None,
        identifier: str = None,
        mobile: str = None,
        name_en: str = None,
        nick_name: str = None,
        nick_name_pinyin: str = None,
        organization_user_info: ListProjectMembersResponseBodyMembersOrganizationUserInfo = None,
        real_name: str = None,
        real_name_pinyin: str = None,
        role_name: str = None,
        stamp: str = None,
        tb_role_id: str = None,
    ):
        self.account = account
        self.avatar = avatar
        self.ding_talk_id = ding_talk_id
        self.display_name = display_name
        self.display_nick_name = display_nick_name
        self.display_real_name = display_real_name
        self.division = division
        self.email = email
        self.gender = gender
        self.identifier = identifier
        self.mobile = mobile
        self.name_en = name_en
        self.nick_name = nick_name
        self.nick_name_pinyin = nick_name_pinyin
        self.organization_user_info = organization_user_info
        self.real_name = real_name
        self.real_name_pinyin = real_name_pinyin
        # 角色名称
        self.role_name = role_name
        self.stamp = stamp
        self.tb_role_id = tb_role_id

    def validate(self):
        if self.division:
            self.division.validate()
        if self.organization_user_info:
            self.organization_user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['account'] = self.account
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.ding_talk_id is not None:
            result['dingTalkId'] = self.ding_talk_id
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.display_nick_name is not None:
            result['displayNickName'] = self.display_nick_name
        if self.display_real_name is not None:
            result['displayRealName'] = self.display_real_name
        if self.division is not None:
            result['division'] = self.division.to_map()
        if self.email is not None:
            result['email'] = self.email
        if self.gender is not None:
            result['gender'] = self.gender
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.mobile is not None:
            result['mobile'] = self.mobile
        if self.name_en is not None:
            result['nameEn'] = self.name_en
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.nick_name_pinyin is not None:
            result['nickNamePinyin'] = self.nick_name_pinyin
        if self.organization_user_info is not None:
            result['organizationUserInfo'] = self.organization_user_info.to_map()
        if self.real_name is not None:
            result['realName'] = self.real_name
        if self.real_name_pinyin is not None:
            result['realNamePinyin'] = self.real_name_pinyin
        if self.role_name is not None:
            result['roleName'] = self.role_name
        if self.stamp is not None:
            result['stamp'] = self.stamp
        if self.tb_role_id is not None:
            result['tbRoleId'] = self.tb_role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('dingTalkId') is not None:
            self.ding_talk_id = m.get('dingTalkId')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('displayNickName') is not None:
            self.display_nick_name = m.get('displayNickName')
        if m.get('displayRealName') is not None:
            self.display_real_name = m.get('displayRealName')
        if m.get('division') is not None:
            temp_model = ListProjectMembersResponseBodyMembersDivision()
            self.division = temp_model.from_map(m['division'])
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('gender') is not None:
            self.gender = m.get('gender')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('mobile') is not None:
            self.mobile = m.get('mobile')
        if m.get('nameEn') is not None:
            self.name_en = m.get('nameEn')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('nickNamePinyin') is not None:
            self.nick_name_pinyin = m.get('nickNamePinyin')
        if m.get('organizationUserInfo') is not None:
            temp_model = ListProjectMembersResponseBodyMembersOrganizationUserInfo()
            self.organization_user_info = temp_model.from_map(m['organizationUserInfo'])
        if m.get('realName') is not None:
            self.real_name = m.get('realName')
        if m.get('realNamePinyin') is not None:
            self.real_name_pinyin = m.get('realNamePinyin')
        if m.get('roleName') is not None:
            self.role_name = m.get('roleName')
        if m.get('stamp') is not None:
            self.stamp = m.get('stamp')
        if m.get('tbRoleId') is not None:
            self.tb_role_id = m.get('tbRoleId')
        return self


class ListProjectMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        members: List[ListProjectMembersResponseBodyMembers] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.members = members
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.members:
            for k in self.members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        result['members'] = []
        if self.members is not None:
            for k in self.members:
                result['members'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        self.members = []
        if m.get('members') is not None:
            for k in m.get('members'):
                temp_model = ListProjectMembersResponseBodyMembers()
                self.members.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListProjectMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectTemplatesRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
    ):
        # This parameter is required.
        self.category = category

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        return self


class ListProjectTemplatesResponseBodyTemplates(TeaModel):
    def __init__(
        self,
        copy_from: str = None,
        creator: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        icon: str = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        name_en: str = None,
        resource_category: str = None,
        resource_type: str = None,
        space_identifier: str = None,
        space_type: str = None,
        type: int = None,
    ):
        self.copy_from = copy_from
        self.creator = creator
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.icon = icon
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.name_en = name_en
        self.resource_category = resource_category
        self.resource_type = resource_type
        self.space_identifier = space_identifier
        self.space_type = space_type
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copy_from is not None:
            result['copyFrom'] = self.copy_from
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.icon is not None:
            result['icon'] = self.icon
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.name_en is not None:
            result['nameEn'] = self.name_en
        if self.resource_category is not None:
            result['resourceCategory'] = self.resource_category
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('copyFrom') is not None:
            self.copy_from = m.get('copyFrom')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameEn') is not None:
            self.name_en = m.get('nameEn')
        if m.get('resourceCategory') is not None:
            self.resource_category = m.get('resourceCategory')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListProjectTemplatesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        templates: List[ListProjectTemplatesResponseBodyTemplates] = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success
        self.templates = templates

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['templates'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.templates = []
        if m.get('templates') is not None:
            for k in m.get('templates'):
                temp_model = ListProjectTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        return self


class ListProjectTemplatesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectTemplatesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectWorkitemTypesRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        space_type: str = None,
    ):
        # This parameter is required.
        self.category = category
        # This parameter is required.
        self.space_type = space_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        return self


class ListProjectWorkitemTypesResponseBodyWorkitemTypes(TeaModel):
    def __init__(
        self,
        add_user: str = None,
        category_identifier: str = None,
        creator: str = None,
        default_type: bool = None,
        description: str = None,
        enable: bool = None,
        gmt_add: int = None,
        gmt_create: int = None,
        identifier: str = None,
        name: str = None,
        name_en: str = None,
        system_default: bool = None,
    ):
        self.add_user = add_user
        self.category_identifier = category_identifier
        self.creator = creator
        self.default_type = default_type
        self.description = description
        self.enable = enable
        self.gmt_add = gmt_add
        self.gmt_create = gmt_create
        self.identifier = identifier
        self.name = name
        self.name_en = name_en
        self.system_default = system_default

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_user is not None:
            result['addUser'] = self.add_user
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_type is not None:
            result['defaultType'] = self.default_type
        if self.description is not None:
            result['description'] = self.description
        if self.enable is not None:
            result['enable'] = self.enable
        if self.gmt_add is not None:
            result['gmtAdd'] = self.gmt_add
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.name is not None:
            result['name'] = self.name
        if self.name_en is not None:
            result['nameEn'] = self.name_en
        if self.system_default is not None:
            result['systemDefault'] = self.system_default
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('addUser') is not None:
            self.add_user = m.get('addUser')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('defaultType') is not None:
            self.default_type = m.get('defaultType')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enable') is not None:
            self.enable = m.get('enable')
        if m.get('gmtAdd') is not None:
            self.gmt_add = m.get('gmtAdd')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameEn') is not None:
            self.name_en = m.get('nameEn')
        if m.get('systemDefault') is not None:
            self.system_default = m.get('systemDefault')
        return self


class ListProjectWorkitemTypesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workitem_types: List[ListProjectWorkitemTypesResponseBodyWorkitemTypes] = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workitem_types = workitem_types

    def validate(self):
        if self.workitem_types:
            for k in self.workitem_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['workitemTypes'] = []
        if self.workitem_types is not None:
            for k in self.workitem_types:
                result['workitemTypes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.workitem_types = []
        if m.get('workitemTypes') is not None:
            for k in m.get('workitemTypes'):
                temp_model = ListProjectWorkitemTypesResponseBodyWorkitemTypes()
                self.workitem_types.append(temp_model.from_map(k))
        return self


class ListProjectWorkitemTypesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectWorkitemTypesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectWorkitemTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProjectsRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        conditions: str = None,
        extra_conditions: str = None,
        max_results: int = None,
        next_token: str = None,
        scope: str = None,
    ):
        # This parameter is required.
        self.category = category
        # {"conditionGroups":[[]]}
        self.conditions = conditions
        self.extra_conditions = extra_conditions
        self.max_results = max_results
        self.next_token = next_token
        self.scope = scope

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.conditions is not None:
            result['conditions'] = self.conditions
        if self.extra_conditions is not None:
            result['extraConditions'] = self.extra_conditions
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.scope is not None:
            result['scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('conditions') is not None:
            self.conditions = m.get('conditions')
        if m.get('extraConditions') is not None:
            self.extra_conditions = m.get('extraConditions')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        return self


class ListProjectsResponseBodyProjects(TeaModel):
    def __init__(
        self,
        category_identifier: str = None,
        creator: str = None,
        custom_code: str = None,
        delete_time: int = None,
        description: str = None,
        gmt_create: int = None,
        icon: str = None,
        identifier: str = None,
        logical_status: str = None,
        name: str = None,
        scope: str = None,
        status_stage_identifier: str = None,
        type_identifier: str = None,
    ):
        self.category_identifier = category_identifier
        self.creator = creator
        self.custom_code = custom_code
        self.delete_time = delete_time
        self.description = description
        self.gmt_create = gmt_create
        self.icon = icon
        self.identifier = identifier
        self.logical_status = logical_status
        self.name = name
        self.scope = scope
        self.status_stage_identifier = status_stage_identifier
        self.type_identifier = type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.custom_code is not None:
            result['customCode'] = self.custom_code
        if self.delete_time is not None:
            result['deleteTime'] = self.delete_time
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.icon is not None:
            result['icon'] = self.icon
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.name is not None:
            result['name'] = self.name
        if self.scope is not None:
            result['scope'] = self.scope
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.type_identifier is not None:
            result['typeIdentifier'] = self.type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('customCode') is not None:
            self.custom_code = m.get('customCode')
        if m.get('deleteTime') is not None:
            self.delete_time = m.get('deleteTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('typeIdentifier') is not None:
            self.type_identifier = m.get('typeIdentifier')
        return self


class ListProjectsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        max_results: int = None,
        next_token: str = None,
        projects: List[ListProjectsResponseBodyProjects] = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.max_results = max_results
        self.next_token = next_token
        self.projects = projects
        self.request_id = request_id
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.projects:
            for k in self.projects:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        result['projects'] = []
        if self.projects is not None:
            for k in self.projects:
                result['projects'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        self.projects = []
        if m.get('projects') is not None:
            for k in m.get('projects'):
                temp_model = ListProjectsResponseBodyProjects()
                self.projects.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListProjectsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProjectsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListProtectedBranchesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListProtectedBranchesResponseBodyResultAllowMergeUsers(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        username: str = None,
    ):
        self.avatar = avatar
        self.email = email
        self.id = id
        self.name = name
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListProtectedBranchesResponseBodyResultAllowPushUsers(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        username: str = None,
    ):
        self.avatar = avatar
        self.email = email
        self.id = id
        self.name = name
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        username: str = None,
    ):
        self.avatar = avatar
        self.email = email
        self.id = id
        self.name = name
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListProtectedBranchesResponseBodyResultMergeRequestSetting(TeaModel):
    def __init__(
        self,
        allow_merge_request_roles: List[int] = None,
        default_assignees: List[ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees] = None,
        is_allow_self_approval: bool = None,
        is_require_discussion_processed: bool = None,
        is_required: bool = None,
        is_reset_approval_when_new_push: bool = None,
        minimum_approval: int = None,
        mr_mode: str = None,
        white_list: str = None,
    ):
        self.allow_merge_request_roles = allow_merge_request_roles
        self.default_assignees = default_assignees
        self.is_allow_self_approval = is_allow_self_approval
        self.is_require_discussion_processed = is_require_discussion_processed
        self.is_required = is_required
        self.is_reset_approval_when_new_push = is_reset_approval_when_new_push
        self.minimum_approval = minimum_approval
        self.mr_mode = mr_mode
        self.white_list = white_list

    def validate(self):
        if self.default_assignees:
            for k in self.default_assignees:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_request_roles is not None:
            result['allowMergeRequestRoles'] = self.allow_merge_request_roles
        result['defaultAssignees'] = []
        if self.default_assignees is not None:
            for k in self.default_assignees:
                result['defaultAssignees'].append(k.to_map() if k else None)
        if self.is_allow_self_approval is not None:
            result['isAllowSelfApproval'] = self.is_allow_self_approval
        if self.is_require_discussion_processed is not None:
            result['isRequireDiscussionProcessed'] = self.is_require_discussion_processed
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_reset_approval_when_new_push is not None:
            result['isResetApprovalWhenNewPush'] = self.is_reset_approval_when_new_push
        if self.minimum_approval is not None:
            result['minimumApproval'] = self.minimum_approval
        if self.mr_mode is not None:
            result['mrMode'] = self.mr_mode
        if self.white_list is not None:
            result['whiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRequestRoles') is not None:
            self.allow_merge_request_roles = m.get('allowMergeRequestRoles')
        self.default_assignees = []
        if m.get('defaultAssignees') is not None:
            for k in m.get('defaultAssignees'):
                temp_model = ListProtectedBranchesResponseBodyResultMergeRequestSettingDefaultAssignees()
                self.default_assignees.append(temp_model.from_map(k))
        if m.get('isAllowSelfApproval') is not None:
            self.is_allow_self_approval = m.get('isAllowSelfApproval')
        if m.get('isRequireDiscussionProcessed') is not None:
            self.is_require_discussion_processed = m.get('isRequireDiscussionProcessed')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isResetApprovalWhenNewPush') is not None:
            self.is_reset_approval_when_new_push = m.get('isResetApprovalWhenNewPush')
        if m.get('minimumApproval') is not None:
            self.minimum_approval = m.get('minimumApproval')
        if m.get('mrMode') is not None:
            self.mr_mode = m.get('mrMode')
        if m.get('whiteList') is not None:
            self.white_list = m.get('whiteList')
        return self


class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems(TeaModel):
    def __init__(
        self,
        is_required: bool = None,
        name: str = None,
    ):
        self.is_required = is_required
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig(TeaModel):
    def __init__(
        self,
        check_items: List[ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems] = None,
    ):
        self.check_items = check_items

    def validate(self):
        if self.check_items:
            for k in self.check_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['checkItems'] = []
        if self.check_items is not None:
            for k in self.check_items:
                result['checkItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_items = []
        if m.get('checkItems') is not None:
            for k in m.get('checkItems'):
                temp_model = ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems()
                self.check_items.append(temp_model.from_map(k))
        return self


class ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig(TeaModel):
    def __init__(
        self,
        biz_no: str = None,
        enabled: bool = None,
        message: str = None,
        task_name: str = None,
    ):
        self.biz_no = biz_no
        self.enabled = enabled
        self.message = message
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_no is not None:
            result['bizNo'] = self.biz_no
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizNo') is not None:
            self.biz_no = m.get('bizNo')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class ListProtectedBranchesResponseBodyResultTestSettingDTO(TeaModel):
    def __init__(
        self,
        check_config: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig = None,
        check_task_quality_config: ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig = None,
        code_guidelines_detection: ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection = None,
        is_required: bool = None,
        sensitive_info_detection: ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection = None,
    ):
        self.check_config = check_config
        self.check_task_quality_config = check_task_quality_config
        self.code_guidelines_detection = code_guidelines_detection
        self.is_required = is_required
        self.sensitive_info_detection = sensitive_info_detection

    def validate(self):
        if self.check_config:
            self.check_config.validate()
        if self.check_task_quality_config:
            self.check_task_quality_config.validate()
        if self.code_guidelines_detection:
            self.code_guidelines_detection.validate()
        if self.sensitive_info_detection:
            self.sensitive_info_detection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_config is not None:
            result['checkConfig'] = self.check_config.to_map()
        if self.check_task_quality_config is not None:
            result['checkTaskQualityConfig'] = self.check_task_quality_config.to_map()
        if self.code_guidelines_detection is not None:
            result['codeGuidelinesDetection'] = self.code_guidelines_detection.to_map()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.sensitive_info_detection is not None:
            result['sensitiveInfoDetection'] = self.sensitive_info_detection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkConfig') is not None:
            temp_model = ListProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig()
            self.check_config = temp_model.from_map(m['checkConfig'])
        if m.get('checkTaskQualityConfig') is not None:
            temp_model = ListProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig()
            self.check_task_quality_config = temp_model.from_map(m['checkTaskQualityConfig'])
        if m.get('codeGuidelinesDetection') is not None:
            temp_model = ListProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection()
            self.code_guidelines_detection = temp_model.from_map(m['codeGuidelinesDetection'])
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('sensitiveInfoDetection') is not None:
            temp_model = ListProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection()
            self.sensitive_info_detection = temp_model.from_map(m['sensitiveInfoDetection'])
        return self


class ListProtectedBranchesResponseBodyResult(TeaModel):
    def __init__(
        self,
        allow_merge_roles: List[int] = None,
        allow_merge_user_ids: List[int] = None,
        allow_merge_users: List[ListProtectedBranchesResponseBodyResultAllowMergeUsers] = None,
        allow_push_roles: List[int] = None,
        allow_push_user_ids: List[int] = None,
        allow_push_users: List[ListProtectedBranchesResponseBodyResultAllowPushUsers] = None,
        branch: str = None,
        created_at: str = None,
        id: int = None,
        matches: List[str] = None,
        merge_request_setting: ListProtectedBranchesResponseBodyResultMergeRequestSetting = None,
        test_setting_dto: ListProtectedBranchesResponseBodyResultTestSettingDTO = None,
        updated_at: str = None,
    ):
        self.allow_merge_roles = allow_merge_roles
        self.allow_merge_user_ids = allow_merge_user_ids
        self.allow_merge_users = allow_merge_users
        self.allow_push_roles = allow_push_roles
        self.allow_push_user_ids = allow_push_user_ids
        self.allow_push_users = allow_push_users
        self.branch = branch
        self.created_at = created_at
        self.id = id
        self.matches = matches
        self.merge_request_setting = merge_request_setting
        self.test_setting_dto = test_setting_dto
        self.updated_at = updated_at

    def validate(self):
        if self.allow_merge_users:
            for k in self.allow_merge_users:
                if k:
                    k.validate()
        if self.allow_push_users:
            for k in self.allow_push_users:
                if k:
                    k.validate()
        if self.merge_request_setting:
            self.merge_request_setting.validate()
        if self.test_setting_dto:
            self.test_setting_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_roles is not None:
            result['allowMergeRoles'] = self.allow_merge_roles
        if self.allow_merge_user_ids is not None:
            result['allowMergeUserIds'] = self.allow_merge_user_ids
        result['allowMergeUsers'] = []
        if self.allow_merge_users is not None:
            for k in self.allow_merge_users:
                result['allowMergeUsers'].append(k.to_map() if k else None)
        if self.allow_push_roles is not None:
            result['allowPushRoles'] = self.allow_push_roles
        if self.allow_push_user_ids is not None:
            result['allowPushUserIds'] = self.allow_push_user_ids
        result['allowPushUsers'] = []
        if self.allow_push_users is not None:
            for k in self.allow_push_users:
                result['allowPushUsers'].append(k.to_map() if k else None)
        if self.branch is not None:
            result['branch'] = self.branch
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.matches is not None:
            result['matches'] = self.matches
        if self.merge_request_setting is not None:
            result['mergeRequestSetting'] = self.merge_request_setting.to_map()
        if self.test_setting_dto is not None:
            result['testSettingDTO'] = self.test_setting_dto.to_map()
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRoles') is not None:
            self.allow_merge_roles = m.get('allowMergeRoles')
        if m.get('allowMergeUserIds') is not None:
            self.allow_merge_user_ids = m.get('allowMergeUserIds')
        self.allow_merge_users = []
        if m.get('allowMergeUsers') is not None:
            for k in m.get('allowMergeUsers'):
                temp_model = ListProtectedBranchesResponseBodyResultAllowMergeUsers()
                self.allow_merge_users.append(temp_model.from_map(k))
        if m.get('allowPushRoles') is not None:
            self.allow_push_roles = m.get('allowPushRoles')
        if m.get('allowPushUserIds') is not None:
            self.allow_push_user_ids = m.get('allowPushUserIds')
        self.allow_push_users = []
        if m.get('allowPushUsers') is not None:
            for k in m.get('allowPushUsers'):
                temp_model = ListProtectedBranchesResponseBodyResultAllowPushUsers()
                self.allow_push_users.append(temp_model.from_map(k))
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('matches') is not None:
            self.matches = m.get('matches')
        if m.get('mergeRequestSetting') is not None:
            temp_model = ListProtectedBranchesResponseBodyResultMergeRequestSetting()
            self.merge_request_setting = temp_model.from_map(m['mergeRequestSetting'])
        if m.get('testSettingDTO') is not None:
            temp_model = ListProtectedBranchesResponseBodyResultTestSettingDTO()
            self.test_setting_dto = temp_model.from_map(m['testSettingDTO'])
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        return self


class ListProtectedBranchesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListProtectedBranchesResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListProtectedBranchesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListProtectedBranchesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListProtectedBranchesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListProtectedBranchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPushRulesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListPushRulesResponseBodyResultRuleInfos(TeaModel):
    def __init__(
        self,
        checker_name: str = None,
        checker_type: str = None,
        extra_message: str = None,
        file_rule_regexes: List[str] = None,
    ):
        self.checker_name = checker_name
        self.checker_type = checker_type
        self.extra_message = extra_message
        self.file_rule_regexes = file_rule_regexes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checker_name is not None:
            result['checkerName'] = self.checker_name
        if self.checker_type is not None:
            result['checkerType'] = self.checker_type
        if self.extra_message is not None:
            result['extraMessage'] = self.extra_message
        if self.file_rule_regexes is not None:
            result['fileRuleRegexes'] = self.file_rule_regexes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkerName') is not None:
            self.checker_name = m.get('checkerName')
        if m.get('checkerType') is not None:
            self.checker_type = m.get('checkerType')
        if m.get('extraMessage') is not None:
            self.extra_message = m.get('extraMessage')
        if m.get('fileRuleRegexes') is not None:
            self.file_rule_regexes = m.get('fileRuleRegexes')
        return self


class ListPushRulesResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        rule_infos: List[ListPushRulesResponseBodyResultRuleInfos] = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.rule_infos = rule_infos

    def validate(self):
        if self.rule_infos:
            for k in self.rule_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        result['ruleInfos'] = []
        if self.rule_infos is not None:
            for k in self.rule_infos:
                result['ruleInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        self.rule_infos = []
        if m.get('ruleInfos') is not None:
            for k in m.get('ruleInfos'):
                temp_model = ListPushRulesResponseBodyResultRuleInfos()
                self.rule_infos.append(temp_model.from_map(k))
        return self


class ListPushRulesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListPushRulesResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListPushRulesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListPushRulesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListPushRulesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPushRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoriesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        archived: bool = None,
        min_access_level: int = None,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        per_page: int = None,
        search: str = None,
        sort: str = None,
    ):
        self.access_token = access_token
        self.archived = archived
        self.min_access_level = min_access_level
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.per_page = per_page
        self.search = search
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.archived is not None:
            result['archived'] = self.archived
        if self.min_access_level is not None:
            result['minAccessLevel'] = self.min_access_level
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.per_page is not None:
            result['perPage'] = self.per_page
        if self.search is not None:
            result['search'] = self.search
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('archived') is not None:
            self.archived = m.get('archived')
        if m.get('minAccessLevel') is not None:
            self.min_access_level = m.get('minAccessLevel')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('perPage') is not None:
            self.per_page = m.get('perPage')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListRepositoriesResponseBodyResult(TeaModel):
    def __init__(
        self,
        id: int = None,
        access_level: int = None,
        archive: bool = None,
        avatar_url: str = None,
        created_at: str = None,
        description: str = None,
        import_status: str = None,
        last_activity_at: str = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        star: bool = None,
        star_count: int = None,
        updated_at: str = None,
        visibility_level: str = None,
        web_url: str = None,
    ):
        self.id = id
        self.access_level = access_level
        self.archive = archive
        self.avatar_url = avatar_url
        self.created_at = created_at
        self.description = description
        self.import_status = import_status
        self.last_activity_at = last_activity_at
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace_id = namespace_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.star = star
        self.star_count = star_count
        self.updated_at = updated_at
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.archive is not None:
            result['archive'] = self.archive
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.import_status is not None:
            result['importStatus'] = self.import_status
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.star is not None:
            result['star'] = self.star
        if self.star_count is not None:
            result['starCount'] = self.star_count
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('archive') is not None:
            self.archive = m.get('archive')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('importStatus') is not None:
            self.import_status = m.get('importStatus')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('star') is not None:
            self.star = m.get('star')
        if m.get('starCount') is not None:
            self.star_count = m.get('starCount')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class ListRepositoriesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: int = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoriesResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoriesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListRepositoriesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoriesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryBranchesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        search: str = None,
        sort: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.search = search
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.search is not None:
            result['search'] = self.search
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListRepositoryBranchesResponseBodyResultCommit(TeaModel):
    def __init__(
        self,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        committed_date: str = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        title: str = None,
    ):
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.committed_date = committed_date
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListRepositoryBranchesResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit: ListRepositoryBranchesResponseBodyResultCommit = None,
        name: str = None,
        protected: str = None,
    ):
        self.commit = commit
        self.name = name
        self.protected = protected

    def validate(self):
        if self.commit:
            self.commit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit is not None:
            result['commit'] = self.commit.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.protected is not None:
            result['protected'] = self.protected
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commit') is not None:
            temp_model = ListRepositoryBranchesResponseBodyResultCommit()
            self.commit = temp_model.from_map(m['commit'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('protected') is not None:
            self.protected = m.get('protected')
        return self


class ListRepositoryBranchesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryBranchesResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryBranchesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListRepositoryBranchesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryBranchesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryBranchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryCommitDiffRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        context_line: int = None,
        organization_id: str = None,
    ):
        # accessToken
        self.access_token = access_token
        self.context_line = context_line
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.context_line is not None:
            result['contextLine'] = self.context_line
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('contextLine') is not None:
            self.context_line = m.get('contextLine')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListRepositoryCommitDiffResponseBodyResult(TeaModel):
    def __init__(
        self,
        a_mode: str = None,
        b_mode: str = None,
        deleted_file: bool = None,
        diff: str = None,
        is_binary: bool = None,
        is_new_lfs: bool = None,
        is_old_lfs: bool = None,
        new_file: bool = None,
        new_id: str = None,
        new_path: str = None,
        old_id: str = None,
        old_path: str = None,
        renamed_file: bool = None,
    ):
        self.a_mode = a_mode
        self.b_mode = b_mode
        self.deleted_file = deleted_file
        self.diff = diff
        self.is_binary = is_binary
        self.is_new_lfs = is_new_lfs
        self.is_old_lfs = is_old_lfs
        self.new_file = new_file
        self.new_id = new_id
        self.new_path = new_path
        self.old_id = old_id
        self.old_path = old_path
        self.renamed_file = renamed_file

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.a_mode is not None:
            result['aMode'] = self.a_mode
        if self.b_mode is not None:
            result['bMode'] = self.b_mode
        if self.deleted_file is not None:
            result['deletedFile'] = self.deleted_file
        if self.diff is not None:
            result['diff'] = self.diff
        if self.is_binary is not None:
            result['isBinary'] = self.is_binary
        if self.is_new_lfs is not None:
            result['isNewLfs'] = self.is_new_lfs
        if self.is_old_lfs is not None:
            result['isOldLfs'] = self.is_old_lfs
        if self.new_file is not None:
            result['newFile'] = self.new_file
        if self.new_id is not None:
            result['newId'] = self.new_id
        if self.new_path is not None:
            result['newPath'] = self.new_path
        if self.old_id is not None:
            result['oldId'] = self.old_id
        if self.old_path is not None:
            result['oldPath'] = self.old_path
        if self.renamed_file is not None:
            result['renamedFile'] = self.renamed_file
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aMode') is not None:
            self.a_mode = m.get('aMode')
        if m.get('bMode') is not None:
            self.b_mode = m.get('bMode')
        if m.get('deletedFile') is not None:
            self.deleted_file = m.get('deletedFile')
        if m.get('diff') is not None:
            self.diff = m.get('diff')
        if m.get('isBinary') is not None:
            self.is_binary = m.get('isBinary')
        if m.get('isNewLfs') is not None:
            self.is_new_lfs = m.get('isNewLfs')
        if m.get('isOldLfs') is not None:
            self.is_old_lfs = m.get('isOldLfs')
        if m.get('newFile') is not None:
            self.new_file = m.get('newFile')
        if m.get('newId') is not None:
            self.new_id = m.get('newId')
        if m.get('newPath') is not None:
            self.new_path = m.get('newPath')
        if m.get('oldId') is not None:
            self.old_id = m.get('oldId')
        if m.get('oldPath') is not None:
            self.old_path = m.get('oldPath')
        if m.get('renamedFile') is not None:
            self.renamed_file = m.get('renamedFile')
        return self


class ListRepositoryCommitDiffResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryCommitDiffResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        # Id of the request
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryCommitDiffResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListRepositoryCommitDiffResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryCommitDiffResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryCommitDiffResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryCommitsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        end: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        path: str = None,
        ref_name: str = None,
        search: str = None,
        show_comments_count: bool = None,
        show_signature: bool = None,
        start: str = None,
    ):
        self.access_token = access_token
        self.end = end
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.path = path
        # This parameter is required.
        self.ref_name = ref_name
        self.search = search
        self.show_comments_count = show_comments_count
        self.show_signature = show_signature
        self.start = start

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.end is not None:
            result['end'] = self.end
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.path is not None:
            result['path'] = self.path
        if self.ref_name is not None:
            result['refName'] = self.ref_name
        if self.search is not None:
            result['search'] = self.search
        if self.show_comments_count is not None:
            result['showCommentsCount'] = self.show_comments_count
        if self.show_signature is not None:
            result['showSignature'] = self.show_signature
        if self.start is not None:
            result['start'] = self.start
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('refName') is not None:
            self.ref_name = m.get('refName')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('showCommentsCount') is not None:
            self.show_comments_count = m.get('showCommentsCount')
        if m.get('showSignature') is not None:
            self.show_signature = m.get('showSignature')
        if m.get('start') is not None:
            self.start = m.get('start')
        return self


class ListRepositoryCommitsResponseBodyResultAuthor(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
        website_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username
        self.website_url = website_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.website_url is not None:
            result['websiteUrl'] = self.website_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('websiteUrl') is not None:
            self.website_url = m.get('websiteUrl')
        return self


class ListRepositoryCommitsResponseBodyResultCommitter(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
        website_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username
        self.website_url = website_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.website_url is not None:
            result['websiteUrl'] = self.website_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('websiteUrl') is not None:
            self.website_url = m.get('websiteUrl')
        return self


class ListRepositoryCommitsResponseBodyResultSignature(TeaModel):
    def __init__(
        self,
        gpg_key_id: str = None,
        verification_status: str = None,
    ):
        self.gpg_key_id = gpg_key_id
        self.verification_status = verification_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gpg_key_id is not None:
            result['gpgKeyId'] = self.gpg_key_id
        if self.verification_status is not None:
            result['verificationStatus'] = self.verification_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gpgKeyId') is not None:
            self.gpg_key_id = m.get('gpgKeyId')
        if m.get('verificationStatus') is not None:
            self.verification_status = m.get('verificationStatus')
        return self


class ListRepositoryCommitsResponseBodyResult(TeaModel):
    def __init__(
        self,
        author: ListRepositoryCommitsResponseBodyResultAuthor = None,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        comments_count: int = None,
        committed_date: str = None,
        committer: ListRepositoryCommitsResponseBodyResultCommitter = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        signature: ListRepositoryCommitsResponseBodyResultSignature = None,
        title: str = None,
    ):
        self.author = author
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.comments_count = comments_count
        self.committed_date = committed_date
        self.committer = committer
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.signature = signature
        self.title = title

    def validate(self):
        if self.author:
            self.author.validate()
        if self.committer:
            self.committer.validate()
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.comments_count is not None:
            result['commentsCount'] = self.comments_count
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer is not None:
            result['committer'] = self.committer.to_map()
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = ListRepositoryCommitsResponseBodyResultAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('commentsCount') is not None:
            self.comments_count = m.get('commentsCount')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committer') is not None:
            temp_model = ListRepositoryCommitsResponseBodyResultCommitter()
            self.committer = temp_model.from_map(m['committer'])
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('signature') is not None:
            temp_model = ListRepositoryCommitsResponseBodyResultSignature()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListRepositoryCommitsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryCommitsResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryCommitsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListRepositoryCommitsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryCommitsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryCommitsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryGroupsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        include_personal: bool = None,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        parent_id: int = None,
        search: str = None,
        sort: str = None,
    ):
        self.access_token = access_token
        self.include_personal = include_personal
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        # This parameter is required.
        self.parent_id = parent_id
        self.search = search
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.include_personal is not None:
            result['includePersonal'] = self.include_personal
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.search is not None:
            result['search'] = self.search
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('includePersonal') is not None:
            self.include_personal = m.get('includePersonal')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListRepositoryGroupsResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        created_at: str = None,
        description: str = None,
        group_count: int = None,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        owner_id: int = None,
        parent_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        project_count: int = None,
        type: str = None,
        updated_at: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.created_at = created_at
        self.description = description
        self.group_count = group_count
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.project_count = project_count
        self.type = type
        self.updated_at = updated_at
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.group_count is not None:
            result['groupCount'] = self.group_count
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.project_count is not None:
            result['projectCount'] = self.project_count
        if self.type is not None:
            result['type'] = self.type
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('groupCount') is not None:
            self.group_count = m.get('groupCount')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('projectCount') is not None:
            self.project_count = m.get('projectCount')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class ListRepositoryGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryGroupsResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryGroupsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListRepositoryGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryMemberWithInheritedRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListRepositoryMemberWithInheritedResponseBodyResultInherited(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        path: str = None,
        path_with_namespace: str = None,
        type: str = None,
        visibility_level: str = None,
    ):
        # id
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.type = type
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.type is not None:
            result['type'] = self.type
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class ListRepositoryMemberWithInheritedResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        inherited: ListRepositoryMemberWithInheritedResponseBodyResultInherited = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.inherited = inherited
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        if self.inherited:
            self.inherited.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.inherited is not None:
            result['inherited'] = self.inherited.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inherited') is not None:
            temp_model = ListRepositoryMemberWithInheritedResponseBodyResultInherited()
            self.inherited = temp_model.from_map(m['inherited'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListRepositoryMemberWithInheritedResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryMemberWithInheritedResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryMemberWithInheritedResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListRepositoryMemberWithInheritedResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryMemberWithInheritedResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryMemberWithInheritedResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryTagsRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        search: str = None,
        sort: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.search = search
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.search is not None:
            result['search'] = self.search
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListRepositoryTagsResponseBodyResultCommitSignature(TeaModel):
    def __init__(
        self,
        gpg_key_id: str = None,
        verification_status: str = None,
    ):
        self.gpg_key_id = gpg_key_id
        self.verification_status = verification_status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gpg_key_id is not None:
            result['gpgKeyId'] = self.gpg_key_id
        if self.verification_status is not None:
            result['verificationStatus'] = self.verification_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gpgKeyId') is not None:
            self.gpg_key_id = m.get('gpgKeyId')
        if m.get('verificationStatus') is not None:
            self.verification_status = m.get('verificationStatus')
        return self


class ListRepositoryTagsResponseBodyResultCommit(TeaModel):
    def __init__(
        self,
        author_email: str = None,
        author_name: str = None,
        authored_date: str = None,
        committed_date: str = None,
        committer_email: str = None,
        committer_name: str = None,
        created_at: str = None,
        id: str = None,
        message: str = None,
        parent_ids: List[str] = None,
        short_id: str = None,
        signature: ListRepositoryTagsResponseBodyResultCommitSignature = None,
        title: str = None,
    ):
        self.author_email = author_email
        self.author_name = author_name
        self.authored_date = authored_date
        self.committed_date = committed_date
        self.committer_email = committer_email
        self.committer_name = committer_name
        self.created_at = created_at
        self.id = id
        self.message = message
        self.parent_ids = parent_ids
        self.short_id = short_id
        self.signature = signature
        self.title = title

    def validate(self):
        if self.signature:
            self.signature.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author_email is not None:
            result['authorEmail'] = self.author_email
        if self.author_name is not None:
            result['authorName'] = self.author_name
        if self.authored_date is not None:
            result['authoredDate'] = self.authored_date
        if self.committed_date is not None:
            result['committedDate'] = self.committed_date
        if self.committer_email is not None:
            result['committerEmail'] = self.committer_email
        if self.committer_name is not None:
            result['committerName'] = self.committer_name
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.parent_ids is not None:
            result['parentIds'] = self.parent_ids
        if self.short_id is not None:
            result['shortId'] = self.short_id
        if self.signature is not None:
            result['signature'] = self.signature.to_map()
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('authorEmail') is not None:
            self.author_email = m.get('authorEmail')
        if m.get('authorName') is not None:
            self.author_name = m.get('authorName')
        if m.get('authoredDate') is not None:
            self.authored_date = m.get('authoredDate')
        if m.get('committedDate') is not None:
            self.committed_date = m.get('committedDate')
        if m.get('committerEmail') is not None:
            self.committer_email = m.get('committerEmail')
        if m.get('committerName') is not None:
            self.committer_name = m.get('committerName')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('parentIds') is not None:
            self.parent_ids = m.get('parentIds')
        if m.get('shortId') is not None:
            self.short_id = m.get('shortId')
        if m.get('signature') is not None:
            temp_model = ListRepositoryTagsResponseBodyResultCommitSignature()
            self.signature = temp_model.from_map(m['signature'])
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListRepositoryTagsResponseBodyResult(TeaModel):
    def __init__(
        self,
        commit: ListRepositoryTagsResponseBodyResultCommit = None,
        id: str = None,
        message: str = None,
        name: str = None,
    ):
        self.commit = commit
        self.id = id
        self.message = message
        self.name = name

    def validate(self):
        if self.commit:
            self.commit.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit is not None:
            result['commit'] = self.commit.to_map()
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commit') is not None:
            temp_model = ListRepositoryTagsResponseBodyResultCommit()
            self.commit = temp_model.from_map(m['commit'])
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListRepositoryTagsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryTagsResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryTagsResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListRepositoryTagsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryTagsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryTreeRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        path: str = None,
        ref_name: str = None,
        type: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.path = path
        self.ref_name = ref_name
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.path is not None:
            result['path'] = self.path
        if self.ref_name is not None:
            result['refName'] = self.ref_name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('refName') is not None:
            self.ref_name = m.get('refName')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListRepositoryTreeResponseBodyResult(TeaModel):
    def __init__(
        self,
        id: str = None,
        is_lfs: bool = None,
        mode: str = None,
        name: str = None,
        path: str = None,
        type: str = None,
    ):
        self.id = id
        self.is_lfs = is_lfs
        self.mode = mode
        self.name = name
        self.path = path
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.is_lfs is not None:
            result['isLFS'] = self.is_lfs
        if self.mode is not None:
            result['mode'] = self.mode
        if self.name is not None:
            result['name'] = self.name
        if self.path is not None:
            result['path'] = self.path
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isLFS') is not None:
            self.is_lfs = m.get('isLFS')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListRepositoryTreeResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryTreeResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryTreeResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListRepositoryTreeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryTreeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryTreeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListRepositoryWebhookRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        return self


class ListRepositoryWebhookResponseBodyResult(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        description: str = None,
        enable_ssl_verification: bool = None,
        id: int = None,
        last_test_result: str = None,
        merge_requests_events: bool = None,
        note_events: bool = None,
        project_id: int = None,
        push_events: bool = None,
        secret_token: str = None,
        tag_push_events: bool = None,
        url: str = None,
    ):
        self.created_at = created_at
        self.description = description
        self.enable_ssl_verification = enable_ssl_verification
        self.id = id
        self.last_test_result = last_test_result
        self.merge_requests_events = merge_requests_events
        self.note_events = note_events
        self.project_id = project_id
        self.push_events = push_events
        self.secret_token = secret_token
        self.tag_push_events = tag_push_events
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.enable_ssl_verification is not None:
            result['enableSslVerification'] = self.enable_ssl_verification
        if self.id is not None:
            result['id'] = self.id
        if self.last_test_result is not None:
            result['lastTestResult'] = self.last_test_result
        if self.merge_requests_events is not None:
            result['mergeRequestsEvents'] = self.merge_requests_events
        if self.note_events is not None:
            result['noteEvents'] = self.note_events
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.push_events is not None:
            result['pushEvents'] = self.push_events
        if self.secret_token is not None:
            result['secretToken'] = self.secret_token
        if self.tag_push_events is not None:
            result['tagPushEvents'] = self.tag_push_events
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('enableSslVerification') is not None:
            self.enable_ssl_verification = m.get('enableSslVerification')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastTestResult') is not None:
            self.last_test_result = m.get('lastTestResult')
        if m.get('mergeRequestsEvents') is not None:
            self.merge_requests_events = m.get('mergeRequestsEvents')
        if m.get('noteEvents') is not None:
            self.note_events = m.get('noteEvents')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('pushEvents') is not None:
            self.push_events = m.get('pushEvents')
        if m.get('secretToken') is not None:
            self.secret_token = m.get('secretToken')
        if m.get('tagPushEvents') is not None:
            self.tag_push_events = m.get('tagPushEvents')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListRepositoryWebhookResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListRepositoryWebhookResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListRepositoryWebhookResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListRepositoryWebhookResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListRepositoryWebhookResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListRepositoryWebhookResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListResourceMembersResponseBodyResourceMembers(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        role_name: str = None,
        username: str = None,
    ):
        self.account_id = account_id
        self.role_name = role_name
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.role_name is not None:
            result['roleName'] = self.role_name
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('roleName') is not None:
            self.role_name = m.get('roleName')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListResourceMembersResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        resource_members: List[ListResourceMembersResponseBodyResourceMembers] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.resource_members = resource_members
        self.success = success

    def validate(self):
        if self.resource_members:
            for k in self.resource_members:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['resourceMembers'] = []
        if self.resource_members is not None:
            for k in self.resource_members:
                result['resourceMembers'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.resource_members = []
        if m.get('resourceMembers') is not None:
            for k in m.get('resourceMembers'):
                temp_model = ListResourceMembersResponseBodyResourceMembers()
                self.resource_members.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListResourceMembersResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListResourceMembersResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListResourceMembersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchCommitRequestRepoPath(TeaModel):
    def __init__(
        self,
        match_type: str = None,
        operator_type: str = None,
        value: str = None,
    ):
        self.match_type = match_type
        self.operator_type = operator_type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_type is not None:
            result['matchType'] = self.match_type
        if self.operator_type is not None:
            result['operatorType'] = self.operator_type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('matchType') is not None:
            self.match_type = m.get('matchType')
        if m.get('operatorType') is not None:
            self.operator_type = m.get('operatorType')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListSearchCommitRequest(TeaModel):
    def __init__(
        self,
        keyword: str = None,
        order: str = None,
        page: int = None,
        page_size: int = None,
        repo_path: ListSearchCommitRequestRepoPath = None,
        scope: str = None,
        sort: str = None,
        organization_id: str = None,
    ):
        # This parameter is required.
        self.keyword = keyword
        self.order = order
        self.page = page
        self.page_size = page_size
        self.repo_path = repo_path
        self.scope = scope
        self.sort = sort
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.repo_path:
            self.repo_path.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.order is not None:
            result['order'] = self.order
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path.to_map()
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sort is not None:
            result['sort'] = self.sort
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('repoPath') is not None:
            temp_model = ListSearchCommitRequestRepoPath()
            self.repo_path = temp_model.from_map(m['repoPath'])
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListSearchCommitResponseBodyResultHighlightTextMap(TeaModel):
    def __init__(
        self,
        commit_id: str = None,
        commit_message: str = None,
        organization_id: str = None,
        title: str = None,
    ):
        self.commit_id = commit_id
        self.commit_message = commit_message
        self.organization_id = organization_id
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.commit_message is not None:
            result['commitMessage'] = self.commit_message
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('commitMessage') is not None:
            self.commit_message = m.get('commitMessage')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListSearchCommitResponseBodyResultSourceAuthor(TeaModel):
    def __init__(
        self,
        email: str = None,
        name: str = None,
    ):
        self.email = email
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['email'] = self.email
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListSearchCommitResponseBodyResultSource(TeaModel):
    def __init__(
        self,
        author: ListSearchCommitResponseBodyResultSourceAuthor = None,
        author_time: str = None,
        commit_id: str = None,
        commit_message: str = None,
        organization_id: str = None,
        repo_path: str = None,
        title: str = None,
    ):
        self.author = author
        self.author_time = author_time
        self.commit_id = commit_id
        self.commit_message = commit_message
        self.organization_id = organization_id
        self.repo_path = repo_path
        self.title = title

    def validate(self):
        if self.author:
            self.author.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.author is not None:
            result['author'] = self.author.to_map()
        if self.author_time is not None:
            result['authorTime'] = self.author_time
        if self.commit_id is not None:
            result['commitId'] = self.commit_id
        if self.commit_message is not None:
            result['commitMessage'] = self.commit_message
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('author') is not None:
            temp_model = ListSearchCommitResponseBodyResultSourceAuthor()
            self.author = temp_model.from_map(m['author'])
        if m.get('authorTime') is not None:
            self.author_time = m.get('authorTime')
        if m.get('commitId') is not None:
            self.commit_id = m.get('commitId')
        if m.get('commitMessage') is not None:
            self.commit_message = m.get('commitMessage')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repoPath') is not None:
            self.repo_path = m.get('repoPath')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListSearchCommitResponseBodyResult(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        highlight_text_map: ListSearchCommitResponseBodyResultHighlightTextMap = None,
        source: ListSearchCommitResponseBodyResultSource = None,
    ):
        self.doc_id = doc_id
        self.highlight_text_map = highlight_text_map
        self.source = source

    def validate(self):
        if self.highlight_text_map:
            self.highlight_text_map.validate()
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['docId'] = self.doc_id
        if self.highlight_text_map is not None:
            result['highlightTextMap'] = self.highlight_text_map.to_map()
        if self.source is not None:
            result['source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('docId') is not None:
            self.doc_id = m.get('docId')
        if m.get('highlightTextMap') is not None:
            temp_model = ListSearchCommitResponseBodyResultHighlightTextMap()
            self.highlight_text_map = temp_model.from_map(m['highlightTextMap'])
        if m.get('source') is not None:
            temp_model = ListSearchCommitResponseBodyResultSource()
            self.source = temp_model.from_map(m['source'])
        return self


class ListSearchCommitResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListSearchCommitResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListSearchCommitResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListSearchCommitResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchCommitResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchCommitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchRepositoryRequestRepoPath(TeaModel):
    def __init__(
        self,
        match_type: str = None,
        operator_type: str = None,
        value: str = None,
    ):
        self.match_type = match_type
        self.operator_type = operator_type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_type is not None:
            result['matchType'] = self.match_type
        if self.operator_type is not None:
            result['operatorType'] = self.operator_type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('matchType') is not None:
            self.match_type = m.get('matchType')
        if m.get('operatorType') is not None:
            self.operator_type = m.get('operatorType')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListSearchRepositoryRequest(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        keyword: str = None,
        order: str = None,
        page: int = None,
        page_size: int = None,
        repo_path: ListSearchRepositoryRequestRepoPath = None,
        scope: str = None,
        sort: str = None,
        visibility_level: int = None,
        organization_id: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        # This parameter is required.
        self.keyword = keyword
        self.order = order
        self.page = page
        self.page_size = page_size
        self.repo_path = repo_path
        self.scope = scope
        self.sort = sort
        self.visibility_level = visibility_level
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.repo_path:
            self.repo_path.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.order is not None:
            result['order'] = self.order
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path.to_map()
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sort is not None:
            result['sort'] = self.sort
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('repoPath') is not None:
            temp_model = ListSearchRepositoryRequestRepoPath()
            self.repo_path = temp_model.from_map(m['repoPath'])
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListSearchRepositoryResponseBodyResultHighlightTextMap(TeaModel):
    def __init__(
        self,
        creator_user_id: str = None,
        description: str = None,
        organization_id: str = None,
        read_me: str = None,
        repo_name_with_namespace: str = None,
        repo_path: str = None,
    ):
        self.creator_user_id = creator_user_id
        self.description = description
        self.organization_id = organization_id
        self.read_me = read_me
        self.repo_name_with_namespace = repo_name_with_namespace
        self.repo_path = repo_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_user_id is not None:
            result['creatorUserId'] = self.creator_user_id
        if self.description is not None:
            result['description'] = self.description
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.read_me is not None:
            result['readMe'] = self.read_me
        if self.repo_name_with_namespace is not None:
            result['repoNameWithNamespace'] = self.repo_name_with_namespace
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorUserId') is not None:
            self.creator_user_id = m.get('creatorUserId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('readMe') is not None:
            self.read_me = m.get('readMe')
        if m.get('repoNameWithNamespace') is not None:
            self.repo_name_with_namespace = m.get('repoNameWithNamespace')
        if m.get('repoPath') is not None:
            self.repo_path = m.get('repoPath')
        return self


class ListSearchRepositoryResponseBodyResultSource(TeaModel):
    def __init__(
        self,
        create_time: str = None,
        description: str = None,
        last_activity_time: str = None,
        organization_id: str = None,
        read_me: str = None,
        repo_name: str = None,
        repo_path: str = None,
        visibility_level: int = None,
    ):
        self.create_time = create_time
        self.description = description
        self.last_activity_time = last_activity_time
        self.organization_id = organization_id
        self.read_me = read_me
        self.repo_name = repo_name
        self.repo_path = repo_path
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.description is not None:
            result['description'] = self.description
        if self.last_activity_time is not None:
            result['lastActivityTime'] = self.last_activity_time
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.read_me is not None:
            result['readMe'] = self.read_me
        if self.repo_name is not None:
            result['repoName'] = self.repo_name
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('lastActivityTime') is not None:
            self.last_activity_time = m.get('lastActivityTime')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('readMe') is not None:
            self.read_me = m.get('readMe')
        if m.get('repoName') is not None:
            self.repo_name = m.get('repoName')
        if m.get('repoPath') is not None:
            self.repo_path = m.get('repoPath')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class ListSearchRepositoryResponseBodyResult(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        highlight_text_map: ListSearchRepositoryResponseBodyResultHighlightTextMap = None,
        source: ListSearchRepositoryResponseBodyResultSource = None,
    ):
        self.doc_id = doc_id
        self.highlight_text_map = highlight_text_map
        self.source = source

    def validate(self):
        if self.highlight_text_map:
            self.highlight_text_map.validate()
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['docId'] = self.doc_id
        if self.highlight_text_map is not None:
            result['highlightTextMap'] = self.highlight_text_map.to_map()
        if self.source is not None:
            result['source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('docId') is not None:
            self.doc_id = m.get('docId')
        if m.get('highlightTextMap') is not None:
            temp_model = ListSearchRepositoryResponseBodyResultHighlightTextMap()
            self.highlight_text_map = temp_model.from_map(m['highlightTextMap'])
        if m.get('source') is not None:
            temp_model = ListSearchRepositoryResponseBodyResultSource()
            self.source = temp_model.from_map(m['source'])
        return self


class ListSearchRepositoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListSearchRepositoryResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListSearchRepositoryResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListSearchRepositoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchRepositoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchRepositoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSearchSourceCodeRequestFilePath(TeaModel):
    def __init__(
        self,
        match_type: str = None,
        operator_type: str = None,
        value: str = None,
    ):
        self.match_type = match_type
        self.operator_type = operator_type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_type is not None:
            result['matchType'] = self.match_type
        if self.operator_type is not None:
            result['operatorType'] = self.operator_type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('matchType') is not None:
            self.match_type = m.get('matchType')
        if m.get('operatorType') is not None:
            self.operator_type = m.get('operatorType')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListSearchSourceCodeRequestRepoPath(TeaModel):
    def __init__(
        self,
        match_type: str = None,
        operator_type: str = None,
        value: str = None,
    ):
        self.match_type = match_type
        self.operator_type = operator_type
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_type is not None:
            result['matchType'] = self.match_type
        if self.operator_type is not None:
            result['operatorType'] = self.operator_type
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('matchType') is not None:
            self.match_type = m.get('matchType')
        if m.get('operatorType') is not None:
            self.operator_type = m.get('operatorType')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListSearchSourceCodeRequest(TeaModel):
    def __init__(
        self,
        file_path: ListSearchSourceCodeRequestFilePath = None,
        is_code_block: bool = None,
        keyword: str = None,
        language: str = None,
        order: str = None,
        page: int = None,
        page_size: int = None,
        repo_path: ListSearchSourceCodeRequestRepoPath = None,
        scope: str = None,
        sort: str = None,
        organization_id: str = None,
    ):
        self.file_path = file_path
        self.is_code_block = is_code_block
        # This parameter is required.
        self.keyword = keyword
        self.language = language
        self.order = order
        self.page = page
        self.page_size = page_size
        self.repo_path = repo_path
        self.scope = scope
        self.sort = sort
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.file_path:
            self.file_path.validate()
        if self.repo_path:
            self.repo_path.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_path is not None:
            result['filePath'] = self.file_path.to_map()
        if self.is_code_block is not None:
            result['isCodeBlock'] = self.is_code_block
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.language is not None:
            result['language'] = self.language
        if self.order is not None:
            result['order'] = self.order
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path.to_map()
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sort is not None:
            result['sort'] = self.sort
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('filePath') is not None:
            temp_model = ListSearchSourceCodeRequestFilePath()
            self.file_path = temp_model.from_map(m['filePath'])
        if m.get('isCodeBlock') is not None:
            self.is_code_block = m.get('isCodeBlock')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('repoPath') is not None:
            temp_model = ListSearchSourceCodeRequestRepoPath()
            self.repo_path = temp_model.from_map(m['repoPath'])
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListSearchSourceCodeResponseBodyResultHighlightTextMap(TeaModel):
    def __init__(
        self,
        clob: str = None,
        file_name: str = None,
        language: str = None,
        organization_id: str = None,
    ):
        self.clob = clob
        self.file_name = file_name
        self.language = language
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clob is not None:
            result['clob'] = self.clob
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.language is not None:
            result['language'] = self.language
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('clob') is not None:
            self.clob = m.get('clob')
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ListSearchSourceCodeResponseBodyResultSource(TeaModel):
    def __init__(
        self,
        branch: str = None,
        checkin_date: str = None,
        file_name: str = None,
        file_path: str = None,
        language: str = None,
        organization_id: str = None,
        repo_path: str = None,
    ):
        self.branch = branch
        self.checkin_date = checkin_date
        self.file_name = file_name
        self.file_path = file_path
        self.language = language
        self.organization_id = organization_id
        self.repo_path = repo_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch is not None:
            result['branch'] = self.branch
        if self.checkin_date is not None:
            result['checkinDate'] = self.checkin_date
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.file_path is not None:
            result['filePath'] = self.file_path
        if self.language is not None:
            result['language'] = self.language
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repo_path is not None:
            result['repoPath'] = self.repo_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('checkinDate') is not None:
            self.checkin_date = m.get('checkinDate')
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        if m.get('language') is not None:
            self.language = m.get('language')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repoPath') is not None:
            self.repo_path = m.get('repoPath')
        return self


class ListSearchSourceCodeResponseBodyResult(TeaModel):
    def __init__(
        self,
        doc_id: str = None,
        highlight_text_map: ListSearchSourceCodeResponseBodyResultHighlightTextMap = None,
        source: ListSearchSourceCodeResponseBodyResultSource = None,
    ):
        self.doc_id = doc_id
        self.highlight_text_map = highlight_text_map
        self.source = source

    def validate(self):
        if self.highlight_text_map:
            self.highlight_text_map.validate()
        if self.source:
            self.source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.doc_id is not None:
            result['docId'] = self.doc_id
        if self.highlight_text_map is not None:
            result['highlightTextMap'] = self.highlight_text_map.to_map()
        if self.source is not None:
            result['source'] = self.source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('docId') is not None:
            self.doc_id = m.get('docId')
        if m.get('highlightTextMap') is not None:
            temp_model = ListSearchSourceCodeResponseBodyResultHighlightTextMap()
            self.highlight_text_map = temp_model.from_map(m['highlightTextMap'])
        if m.get('source') is not None:
            temp_model = ListSearchSourceCodeResponseBodyResultSource()
            self.source = temp_model.from_map(m['source'])
        return self


class ListSearchSourceCodeResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListSearchSourceCodeResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListSearchSourceCodeResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListSearchSourceCodeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSearchSourceCodeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSearchSourceCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListServiceAuthsRequest(TeaModel):
    def __init__(
        self,
        service_auth_type: str = None,
    ):
        # This parameter is required.
        self.service_auth_type = service_auth_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_auth_type is not None:
            result['serviceAuthType'] = self.service_auth_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('serviceAuthType') is not None:
            self.service_auth_type = m.get('serviceAuthType')
        return self


class ListServiceAuthsResponseBodyServiceAuths(TeaModel):
    def __init__(
        self,
        id: int = None,
        owner_name: str = None,
        owner_staff_id: str = None,
        type: str = None,
    ):
        self.id = id
        self.owner_name = owner_name
        self.owner_staff_id = owner_staff_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.owner_name is not None:
            result['ownerName'] = self.owner_name
        if self.owner_staff_id is not None:
            result['ownerStaffId'] = self.owner_staff_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('ownerName') is not None:
            self.owner_name = m.get('ownerName')
        if m.get('ownerStaffId') is not None:
            self.owner_staff_id = m.get('ownerStaffId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListServiceAuthsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        service_auths: List[ListServiceAuthsResponseBodyServiceAuths] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.service_auths = service_auths
        self.success = success

    def validate(self):
        if self.service_auths:
            for k in self.service_auths:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['serviceAuths'] = []
        if self.service_auths is not None:
            for k in self.service_auths:
                result['serviceAuths'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.service_auths = []
        if m.get('serviceAuths') is not None:
            for k in m.get('serviceAuths'):
                temp_model = ListServiceAuthsResponseBodyServiceAuths()
                self.service_auths.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListServiceAuthsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListServiceAuthsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListServiceAuthsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListServiceConnectionsRequest(TeaModel):
    def __init__(
        self,
        serice_connection_type: str = None,
    ):
        # This parameter is required.
        self.serice_connection_type = serice_connection_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.serice_connection_type is not None:
            result['sericeConnectionType'] = self.serice_connection_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('sericeConnectionType') is not None:
            self.serice_connection_type = m.get('sericeConnectionType')
        return self


class ListServiceConnectionsResponseBodyServiceConnections(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        id: int = None,
        name: str = None,
        owner_account_id: int = None,
        type: str = None,
        uuid: str = None,
    ):
        self.create_time = create_time
        self.id = id
        self.name = name
        self.owner_account_id = owner_account_id
        self.type = type
        self.uuid = uuid

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.owner_account_id is not None:
            result['ownerAccountId'] = self.owner_account_id
        if self.type is not None:
            result['type'] = self.type
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerAccountId') is not None:
            self.owner_account_id = m.get('ownerAccountId')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class ListServiceConnectionsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        service_connections: List[ListServiceConnectionsResponseBodyServiceConnections] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.service_connections = service_connections
        self.success = success

    def validate(self):
        if self.service_connections:
            for k in self.service_connections:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['serviceConnections'] = []
        if self.service_connections is not None:
            for k in self.service_connections:
                result['serviceConnections'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.service_connections = []
        if m.get('serviceConnections') is not None:
            for k in m.get('serviceConnections'):
                temp_model = ListServiceConnectionsResponseBodyServiceConnections()
                self.service_connections.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListServiceConnectionsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListServiceConnectionsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListServiceConnectionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListServiceCredentialsRequest(TeaModel):
    def __init__(
        self,
        service_credential_type: str = None,
    ):
        # This parameter is required.
        self.service_credential_type = service_credential_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.service_credential_type is not None:
            result['serviceCredentialType'] = self.service_credential_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('serviceCredentialType') is not None:
            self.service_credential_type = m.get('serviceCredentialType')
        return self


class ListServiceCredentialsResponseBodyServiceCredentials(TeaModel):
    def __init__(
        self,
        id: int = None,
        owner_name: str = None,
        owner_staff_id: str = None,
        type: str = None,
    ):
        self.id = id
        self.owner_name = owner_name
        self.owner_staff_id = owner_staff_id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.owner_name is not None:
            result['ownerName'] = self.owner_name
        if self.owner_staff_id is not None:
            result['ownerStaffId'] = self.owner_staff_id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('ownerName') is not None:
            self.owner_name = m.get('ownerName')
        if m.get('ownerStaffId') is not None:
            self.owner_staff_id = m.get('ownerStaffId')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListServiceCredentialsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        service_credentials: List[ListServiceCredentialsResponseBodyServiceCredentials] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.service_credentials = service_credentials
        self.success = success

    def validate(self):
        if self.service_credentials:
            for k in self.service_credentials:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['serviceCredentials'] = []
        if self.service_credentials is not None:
            for k in self.service_credentials:
                result['serviceCredentials'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.service_credentials = []
        if m.get('serviceCredentials') is not None:
            for k in m.get('serviceCredentials'):
                temp_model = ListServiceCredentialsResponseBodyServiceCredentials()
                self.service_credentials.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListServiceCredentialsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListServiceCredentialsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListServiceCredentialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSprintsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        space_identifier: str = None,
        space_type: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.space_type = space_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        return self


class ListSprintsResponseBodySprints(TeaModel):
    def __init__(
        self,
        creator: str = None,
        description: str = None,
        end_date: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        scope: str = None,
        space_identifier: str = None,
        start_date: int = None,
        status: str = None,
    ):
        self.creator = creator
        self.description = description
        self.end_date = end_date
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.scope = scope
        self.space_identifier = space_identifier
        self.start_date = start_date
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.end_date is not None:
            result['endDate'] = self.end_date
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.scope is not None:
            result['scope'] = self.scope
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.start_date is not None:
            result['startDate'] = self.start_date
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('endDate') is not None:
            self.end_date = m.get('endDate')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('startDate') is not None:
            self.start_date = m.get('startDate')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class ListSprintsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        sprints: List[ListSprintsResponseBodySprints] = None,
        success: bool = None,
        total_count: int = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.sprints = sprints
        self.success = success
        self.total_count = total_count

    def validate(self):
        if self.sprints:
            for k in self.sprints:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['sprints'] = []
        if self.sprints is not None:
            for k in self.sprints:
                result['sprints'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.sprints = []
        if m.get('sprints') is not None:
            for k in m.get('sprints'):
                temp_model = ListSprintsResponseBodySprints()
                self.sprints.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        return self


class ListSprintsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListSprintsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSprintsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTestCaseFieldsRequest(TeaModel):
    def __init__(
        self,
        space_identifier: str = None,
    ):
        # This parameter is required.
        self.space_identifier = space_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        return self


class ListTestCaseFieldsResponseBodyFieldsOptions(TeaModel):
    def __init__(
        self,
        display_value: str = None,
        field_identifier: str = None,
        identifier: str = None,
        level: int = None,
        position: int = None,
        value: str = None,
        value_en: str = None,
    ):
        self.display_value = display_value
        self.field_identifier = field_identifier
        self.identifier = identifier
        self.level = level
        self.position = position
        self.value = value
        self.value_en = value_en

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_value is not None:
            result['displayValue'] = self.display_value
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.level is not None:
            result['level'] = self.level
        if self.position is not None:
            result['position'] = self.position
        if self.value is not None:
            result['value'] = self.value
        if self.value_en is not None:
            result['valueEn'] = self.value_en
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayValue') is not None:
            self.display_value = m.get('displayValue')
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('position') is not None:
            self.position = m.get('position')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('valueEn') is not None:
            self.value_en = m.get('valueEn')
        return self


class ListTestCaseFieldsResponseBodyFields(TeaModel):
    def __init__(
        self,
        class_name: str = None,
        creator: str = None,
        default_value: str = None,
        description: str = None,
        format: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        is_required: bool = None,
        is_show_when_create: bool = None,
        is_system_required: bool = None,
        link_with_service: str = None,
        modifier: str = None,
        name: str = None,
        options: List[ListTestCaseFieldsResponseBodyFieldsOptions] = None,
        resource_type: str = None,
        type: str = None,
    ):
        self.class_name = class_name
        self.creator = creator
        self.default_value = default_value
        self.description = description
        self.format = format
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.is_required = is_required
        self.is_show_when_create = is_show_when_create
        self.is_system_required = is_system_required
        self.link_with_service = link_with_service
        self.modifier = modifier
        self.name = name
        self.options = options
        self.resource_type = resource_type
        self.type = type

    def validate(self):
        if self.options:
            for k in self.options:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_name is not None:
            result['className'] = self.class_name
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_value is not None:
            result['defaultValue'] = self.default_value
        if self.description is not None:
            result['description'] = self.description
        if self.format is not None:
            result['format'] = self.format
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_show_when_create is not None:
            result['isShowWhenCreate'] = self.is_show_when_create
        if self.is_system_required is not None:
            result['isSystemRequired'] = self.is_system_required
        if self.link_with_service is not None:
            result['linkWithService'] = self.link_with_service
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        result['options'] = []
        if self.options is not None:
            for k in self.options:
                result['options'].append(k.to_map() if k else None)
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('className') is not None:
            self.class_name = m.get('className')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('defaultValue') is not None:
            self.default_value = m.get('defaultValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('format') is not None:
            self.format = m.get('format')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isShowWhenCreate') is not None:
            self.is_show_when_create = m.get('isShowWhenCreate')
        if m.get('isSystemRequired') is not None:
            self.is_system_required = m.get('isSystemRequired')
        if m.get('linkWithService') is not None:
            self.link_with_service = m.get('linkWithService')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.options = []
        if m.get('options') is not None:
            for k in m.get('options'):
                temp_model = ListTestCaseFieldsResponseBodyFieldsOptions()
                self.options.append(temp_model.from_map(k))
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListTestCaseFieldsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        fields: List[ListTestCaseFieldsResponseBodyFields] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.fields = fields
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        result['fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['fields'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        self.fields = []
        if m.get('fields') is not None:
            for k in m.get('fields'):
                temp_model = ListTestCaseFieldsResponseBodyFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListTestCaseFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListTestCaseFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTestCaseFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserDrawRecordByPkRequest(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        draw_group: str = None,
        draw_pool_name: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.draw_group = draw_group
        self.draw_pool_name = draw_pool_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.draw_group is not None:
            result['drawGroup'] = self.draw_group
        if self.draw_pool_name is not None:
            result['drawPoolName'] = self.draw_pool_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('drawGroup') is not None:
            self.draw_group = m.get('drawGroup')
        if m.get('drawPoolName') is not None:
            self.draw_pool_name = m.get('drawPoolName')
        return self


class ListUserDrawRecordByPkResponseBodyData(TeaModel):
    def __init__(
        self,
        aliyun_pk: str = None,
        draw_group: str = None,
        draw_pool_name: str = None,
        draw_result: str = None,
        gmt_create: str = None,
        task_group_id: str = None,
        ucc_id: str = None,
    ):
        self.aliyun_pk = aliyun_pk
        self.draw_group = draw_group
        self.draw_pool_name = draw_pool_name
        self.draw_result = draw_result
        self.gmt_create = gmt_create
        self.task_group_id = task_group_id
        self.ucc_id = ucc_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.draw_group is not None:
            result['drawGroup'] = self.draw_group
        if self.draw_pool_name is not None:
            result['drawPoolName'] = self.draw_pool_name
        if self.draw_result is not None:
            result['drawResult'] = self.draw_result
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.task_group_id is not None:
            result['taskGroupId'] = self.task_group_id
        if self.ucc_id is not None:
            result['uccId'] = self.ucc_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('drawGroup') is not None:
            self.draw_group = m.get('drawGroup')
        if m.get('drawPoolName') is not None:
            self.draw_pool_name = m.get('drawPoolName')
        if m.get('drawResult') is not None:
            self.draw_result = m.get('drawResult')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('taskGroupId') is not None:
            self.task_group_id = m.get('taskGroupId')
        if m.get('uccId') is not None:
            self.ucc_id = m.get('uccId')
        return self


class ListUserDrawRecordByPkResponseBody(TeaModel):
    def __init__(
        self,
        code: str = None,
        data: List[ListUserDrawRecordByPkResponseBodyData] = None,
        message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.code = code
        self.data = data
        self.message = message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ListUserDrawRecordByPkResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListUserDrawRecordByPkResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserDrawRecordByPkResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserDrawRecordByPkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserKeysRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        order_by: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        sort: str = None,
    ):
        self.access_token = access_token
        self.order_by = order_by
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.sort = sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.sort is not None:
            result['sort'] = self.sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('sort') is not None:
            self.sort = m.get('sort')
        return self


class ListUserKeysResponseBodyResult(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        expire_time: str = None,
        finger_print: str = None,
        id: int = None,
        key_scope: str = None,
        last_used_time: str = None,
        public_key: str = None,
        title: str = None,
    ):
        self.created_at = created_at
        self.expire_time = expire_time
        self.finger_print = finger_print
        self.id = id
        self.key_scope = key_scope
        self.last_used_time = last_used_time
        self.public_key = public_key
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.expire_time is not None:
            result['expireTime'] = self.expire_time
        if self.finger_print is not None:
            result['fingerPrint'] = self.finger_print
        if self.id is not None:
            result['id'] = self.id
        if self.key_scope is not None:
            result['keyScope'] = self.key_scope
        if self.last_used_time is not None:
            result['lastUsedTime'] = self.last_used_time
        if self.public_key is not None:
            result['publicKey'] = self.public_key
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('expireTime') is not None:
            self.expire_time = m.get('expireTime')
        if m.get('fingerPrint') is not None:
            self.finger_print = m.get('fingerPrint')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('keyScope') is not None:
            self.key_scope = m.get('keyScope')
        if m.get('lastUsedTime') is not None:
            self.last_used_time = m.get('lastUsedTime')
        if m.get('publicKey') is not None:
            self.public_key = m.get('publicKey')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ListUserKeysResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListUserKeysResponseBodyResult] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListUserKeysResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListUserKeysResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserKeysResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserKeysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserResourcesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
        page: int = None,
        page_size: int = None,
        user_ids: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id
        self.page = page
        self.page_size = page_size
        self.user_ids = user_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['pageSize'] = self.page_size
        if self.user_ids is not None:
            result['userIds'] = self.user_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('pageSize') is not None:
            self.page_size = m.get('pageSize')
        if m.get('userIds') is not None:
            self.user_ids = m.get('userIds')
        return self


class ListUserResourcesResponseBodyResultGroupInfosGroupInfo(TeaModel):
    def __init__(
        self,
        created_at: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        owner_id: int = None,
        parent_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        updated_at: str = None,
        visibility_level: int = None,
    ):
        self.created_at = created_at
        self.description = description
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.updated_at = updated_at
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class ListUserResourcesResponseBodyResultGroupInfosGroupRole(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        cn_role_name: str = None,
        en_role_name: str = None,
        source_id: int = None,
        source_type: str = None,
    ):
        self.access_level = access_level
        self.cn_role_name = cn_role_name
        self.en_role_name = en_role_name
        self.source_id = source_id
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.cn_role_name is not None:
            result['cnRoleName'] = self.cn_role_name
        if self.en_role_name is not None:
            result['enRoleName'] = self.en_role_name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('cnRoleName') is not None:
            self.cn_role_name = m.get('cnRoleName')
        if m.get('enRoleName') is not None:
            self.en_role_name = m.get('enRoleName')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        return self


class ListUserResourcesResponseBodyResultGroupInfos(TeaModel):
    def __init__(
        self,
        group_info: ListUserResourcesResponseBodyResultGroupInfosGroupInfo = None,
        group_role: ListUserResourcesResponseBodyResultGroupInfosGroupRole = None,
    ):
        self.group_info = group_info
        self.group_role = group_role

    def validate(self):
        if self.group_info:
            self.group_info.validate()
        if self.group_role:
            self.group_role.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_info is not None:
            result['groupInfo'] = self.group_info.to_map()
        if self.group_role is not None:
            result['groupRole'] = self.group_role.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('groupInfo') is not None:
            temp_model = ListUserResourcesResponseBodyResultGroupInfosGroupInfo()
            self.group_info = temp_model.from_map(m['groupInfo'])
        if m.get('groupRole') is not None:
            temp_model = ListUserResourcesResponseBodyResultGroupInfosGroupRole()
            self.group_role = temp_model.from_map(m['groupRole'])
        return self


class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        archived: bool = None,
        created_at: str = None,
        creator_id: int = None,
        description: str = None,
        encrypted: bool = None,
        id: int = None,
        last_activity_at: str = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        updated_at: str = None,
        visibility_level: int = None,
    ):
        self.access_level = access_level
        self.archived = archived
        self.created_at = created_at
        self.creator_id = creator_id
        self.description = description
        self.encrypted = encrypted
        self.id = id
        self.last_activity_at = last_activity_at
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace_id = namespace_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.updated_at = updated_at
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.archived is not None:
            result['archived'] = self.archived
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.description is not None:
            result['description'] = self.description
        if self.encrypted is not None:
            result['encrypted'] = self.encrypted
        if self.id is not None:
            result['id'] = self.id
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('archived') is not None:
            self.archived = m.get('archived')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('encrypted') is not None:
            self.encrypted = m.get('encrypted')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        cn_role_name: str = None,
        en_role_name: str = None,
        source_id: int = None,
        source_type: str = None,
    ):
        self.access_level = access_level
        self.cn_role_name = cn_role_name
        self.en_role_name = en_role_name
        self.source_id = source_id
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.cn_role_name is not None:
            result['cnRoleName'] = self.cn_role_name
        if self.en_role_name is not None:
            result['enRoleName'] = self.en_role_name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('cnRoleName') is not None:
            self.cn_role_name = m.get('cnRoleName')
        if m.get('enRoleName') is not None:
            self.en_role_name = m.get('enRoleName')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        return self


class ListUserResourcesResponseBodyResultRepositoryInfos(TeaModel):
    def __init__(
        self,
        repository_info: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo = None,
        repository_role: ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole = None,
    ):
        self.repository_info = repository_info
        self.repository_role = repository_role

    def validate(self):
        if self.repository_info:
            self.repository_info.validate()
        if self.repository_role:
            self.repository_role.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.repository_info is not None:
            result['repositoryInfo'] = self.repository_info.to_map()
        if self.repository_role is not None:
            result['repositoryRole'] = self.repository_role.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('repositoryInfo') is not None:
            temp_model = ListUserResourcesResponseBodyResultRepositoryInfosRepositoryInfo()
            self.repository_info = temp_model.from_map(m['repositoryInfo'])
        if m.get('repositoryRole') is not None:
            temp_model = ListUserResourcesResponseBodyResultRepositoryInfosRepositoryRole()
            self.repository_role = temp_model.from_map(m['repositoryRole'])
        return self


class ListUserResourcesResponseBodyResultUserInfo(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        name: str = None,
        state: str = None,
        username: str = None,
    ):
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.name = name
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ListUserResourcesResponseBodyResult(TeaModel):
    def __init__(
        self,
        group_infos: List[ListUserResourcesResponseBodyResultGroupInfos] = None,
        repository_infos: List[ListUserResourcesResponseBodyResultRepositoryInfos] = None,
        user_info: ListUserResourcesResponseBodyResultUserInfo = None,
    ):
        self.group_infos = group_infos
        self.repository_infos = repository_infos
        self.user_info = user_info

    def validate(self):
        if self.group_infos:
            for k in self.group_infos:
                if k:
                    k.validate()
        if self.repository_infos:
            for k in self.repository_infos:
                if k:
                    k.validate()
        if self.user_info:
            self.user_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groupInfos'] = []
        if self.group_infos is not None:
            for k in self.group_infos:
                result['groupInfos'].append(k.to_map() if k else None)
        result['repositoryInfos'] = []
        if self.repository_infos is not None:
            for k in self.repository_infos:
                result['repositoryInfos'].append(k.to_map() if k else None)
        if self.user_info is not None:
            result['userInfo'] = self.user_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.group_infos = []
        if m.get('groupInfos') is not None:
            for k in m.get('groupInfos'):
                temp_model = ListUserResourcesResponseBodyResultGroupInfos()
                self.group_infos.append(temp_model.from_map(k))
        self.repository_infos = []
        if m.get('repositoryInfos') is not None:
            for k in m.get('repositoryInfos'):
                temp_model = ListUserResourcesResponseBodyResultRepositoryInfos()
                self.repository_infos.append(temp_model.from_map(k))
        if m.get('userInfo') is not None:
            temp_model = ListUserResourcesResponseBodyResultUserInfo()
            self.user_info = temp_model.from_map(m['userInfo'])
        return self


class ListUserResourcesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: List[ListUserResourcesResponseBodyResult] = None,
        success: bool = None,
        total: int = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success
        self.total = total

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = ListUserResourcesResponseBodyResult()
                self.result.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        return self


class ListUserResourcesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListUserResourcesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListVariableGroupsRequest(TeaModel):
    def __init__(
        self,
        max_results: int = None,
        next_token: str = None,
        page_order: str = None,
        page_sort: str = None,
    ):
        self.max_results = max_results
        self.next_token = next_token
        self.page_order = page_order
        self.page_sort = page_sort

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.page_order is not None:
            result['pageOrder'] = self.page_order
        if self.page_sort is not None:
            result['pageSort'] = self.page_sort
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('pageOrder') is not None:
            self.page_order = m.get('pageOrder')
        if m.get('pageSort') is not None:
            self.page_sort = m.get('pageSort')
        return self


class ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
    ):
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListVariableGroupsResponseBodyVariableGroupsVariables(TeaModel):
    def __init__(
        self,
        is_encrypted: bool = None,
        name: str = None,
        value: str = None,
    ):
        self.is_encrypted = is_encrypted
        self.name = name
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_encrypted is not None:
            result['isEncrypted'] = self.is_encrypted
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isEncrypted') is not None:
            self.is_encrypted = m.get('isEncrypted')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ListVariableGroupsResponseBodyVariableGroups(TeaModel):
    def __init__(
        self,
        create_time: int = None,
        creator_account_id: str = None,
        description: str = None,
        id: int = None,
        modifier_account_id: str = None,
        name: str = None,
        related_pipelines: List[ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines] = None,
        update_time: int = None,
        variables: List[ListVariableGroupsResponseBodyVariableGroupsVariables] = None,
    ):
        self.create_time = create_time
        self.creator_account_id = creator_account_id
        self.description = description
        self.id = id
        self.modifier_account_id = modifier_account_id
        self.name = name
        self.related_pipelines = related_pipelines
        self.update_time = update_time
        self.variables = variables

    def validate(self):
        if self.related_pipelines:
            for k in self.related_pipelines:
                if k:
                    k.validate()
        if self.variables:
            for k in self.variables:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.modifier_account_id is not None:
            result['modifierAccountId'] = self.modifier_account_id
        if self.name is not None:
            result['name'] = self.name
        result['relatedPipelines'] = []
        if self.related_pipelines is not None:
            for k in self.related_pipelines:
                result['relatedPipelines'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['updateTime'] = self.update_time
        result['variables'] = []
        if self.variables is not None:
            for k in self.variables:
                result['variables'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modifierAccountId') is not None:
            self.modifier_account_id = m.get('modifierAccountId')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.related_pipelines = []
        if m.get('relatedPipelines') is not None:
            for k in m.get('relatedPipelines'):
                temp_model = ListVariableGroupsResponseBodyVariableGroupsRelatedPipelines()
                self.related_pipelines.append(temp_model.from_map(k))
        if m.get('updateTime') is not None:
            self.update_time = m.get('updateTime')
        self.variables = []
        if m.get('variables') is not None:
            for k in m.get('variables'):
                temp_model = ListVariableGroupsResponseBodyVariableGroupsVariables()
                self.variables.append(temp_model.from_map(k))
        return self


class ListVariableGroupsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        variable_groups: List[ListVariableGroupsResponseBodyVariableGroups] = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count
        self.variable_groups = variable_groups

    def validate(self):
        if self.variable_groups:
            for k in self.variable_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        result['variableGroups'] = []
        if self.variable_groups is not None:
            for k in self.variable_groups:
                result['variableGroups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        self.variable_groups = []
        if m.get('variableGroups') is not None:
            for k in m.get('variableGroups'):
                temp_model = ListVariableGroupsResponseBodyVariableGroups()
                self.variable_groups.append(temp_model.from_map(k))
        return self


class ListVariableGroupsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListVariableGroupsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListVariableGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkItemAllFieldsRequest(TeaModel):
    def __init__(
        self,
        space_identifier: str = None,
        space_type: str = None,
        workitem_type_identifier: str = None,
    ):
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.space_type = space_type
        # This parameter is required.
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class ListWorkItemAllFieldsResponseBodyFieldsOptions(TeaModel):
    def __init__(
        self,
        display_value: str = None,
        field_identifier: str = None,
        identifier: str = None,
        level: int = None,
        position: int = None,
        value: str = None,
        value_en: str = None,
    ):
        self.display_value = display_value
        self.field_identifier = field_identifier
        self.identifier = identifier
        self.level = level
        self.position = position
        self.value = value
        self.value_en = value_en

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_value is not None:
            result['displayValue'] = self.display_value
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.level is not None:
            result['level'] = self.level
        if self.position is not None:
            result['position'] = self.position
        if self.value is not None:
            result['value'] = self.value
        if self.value_en is not None:
            result['valueEn'] = self.value_en
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayValue') is not None:
            self.display_value = m.get('displayValue')
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('position') is not None:
            self.position = m.get('position')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('valueEn') is not None:
            self.value_en = m.get('valueEn')
        return self


class ListWorkItemAllFieldsResponseBodyFields(TeaModel):
    def __init__(
        self,
        class_name: str = None,
        creator: str = None,
        default_value: str = None,
        description: str = None,
        format: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        is_required: bool = None,
        is_show_when_create: bool = None,
        is_system_required: bool = None,
        link_with_service: str = None,
        modifier: str = None,
        name: str = None,
        options: List[ListWorkItemAllFieldsResponseBodyFieldsOptions] = None,
        resource_type: str = None,
        type: str = None,
    ):
        self.class_name = class_name
        self.creator = creator
        self.default_value = default_value
        self.description = description
        self.format = format
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.is_required = is_required
        self.is_show_when_create = is_show_when_create
        self.is_system_required = is_system_required
        self.link_with_service = link_with_service
        self.modifier = modifier
        self.name = name
        self.options = options
        self.resource_type = resource_type
        self.type = type

    def validate(self):
        if self.options:
            for k in self.options:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.class_name is not None:
            result['className'] = self.class_name
        if self.creator is not None:
            result['creator'] = self.creator
        if self.default_value is not None:
            result['defaultValue'] = self.default_value
        if self.description is not None:
            result['description'] = self.description
        if self.format is not None:
            result['format'] = self.format
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_show_when_create is not None:
            result['isShowWhenCreate'] = self.is_show_when_create
        if self.is_system_required is not None:
            result['isSystemRequired'] = self.is_system_required
        if self.link_with_service is not None:
            result['linkWithService'] = self.link_with_service
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        result['options'] = []
        if self.options is not None:
            for k in self.options:
                result['options'].append(k.to_map() if k else None)
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('className') is not None:
            self.class_name = m.get('className')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('defaultValue') is not None:
            self.default_value = m.get('defaultValue')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('format') is not None:
            self.format = m.get('format')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isShowWhenCreate') is not None:
            self.is_show_when_create = m.get('isShowWhenCreate')
        if m.get('isSystemRequired') is not None:
            self.is_system_required = m.get('isSystemRequired')
        if m.get('linkWithService') is not None:
            self.link_with_service = m.get('linkWithService')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.options = []
        if m.get('options') is not None:
            for k in m.get('options'):
                temp_model = ListWorkItemAllFieldsResponseBodyFieldsOptions()
                self.options.append(temp_model.from_map(k))
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class ListWorkItemAllFieldsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        fields: List[ListWorkItemAllFieldsResponseBodyFields] = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.fields = fields
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        result['fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['fields'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        self.fields = []
        if m.get('fields') is not None:
            for k in m.get('fields'):
                temp_model = ListWorkItemAllFieldsResponseBodyFields()
                self.fields.append(temp_model.from_map(k))
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListWorkItemAllFieldsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkItemAllFieldsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkItemAllFieldsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkItemWorkFlowStatusRequest(TeaModel):
    def __init__(
        self,
        space_identifier: str = None,
        space_type: str = None,
        workitem_category_identifier: str = None,
        workitem_type_identifier: str = None,
    ):
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.space_type = space_type
        # This parameter is required.
        self.workitem_category_identifier = workitem_category_identifier
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.workitem_category_identifier is not None:
            result['workitemCategoryIdentifier'] = self.workitem_category_identifier
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('workitemCategoryIdentifier') is not None:
            self.workitem_category_identifier = m.get('workitemCategoryIdentifier')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class ListWorkItemWorkFlowStatusResponseBodyStatuses(TeaModel):
    def __init__(
        self,
        creator: str = None,
        description: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        modifier: str = None,
        name: str = None,
        resource_type: str = None,
        source: str = None,
        workflow_stage_identifier: str = None,
        workflow_stage_name: str = None,
    ):
        self.creator = creator
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.modifier = modifier
        self.name = name
        self.resource_type = resource_type
        self.source = source
        self.workflow_stage_identifier = workflow_stage_identifier
        self.workflow_stage_name = workflow_stage_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.resource_type is not None:
            result['resourceType'] = self.resource_type
        if self.source is not None:
            result['source'] = self.source
        if self.workflow_stage_identifier is not None:
            result['workflowStageIdentifier'] = self.workflow_stage_identifier
        if self.workflow_stage_name is not None:
            result['workflowStageName'] = self.workflow_stage_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('resourceType') is not None:
            self.resource_type = m.get('resourceType')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('workflowStageIdentifier') is not None:
            self.workflow_stage_identifier = m.get('workflowStageIdentifier')
        if m.get('workflowStageName') is not None:
            self.workflow_stage_name = m.get('workflowStageName')
        return self


class ListWorkItemWorkFlowStatusResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        statuses: List[ListWorkItemWorkFlowStatusResponseBodyStatuses] = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.statuses = statuses
        self.success = success

    def validate(self):
        if self.statuses:
            for k in self.statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        result['statuses'] = []
        if self.statuses is not None:
            for k in self.statuses:
                result['statuses'].append(k.to_map() if k else None)
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        self.statuses = []
        if m.get('statuses') is not None:
            for k in m.get('statuses'):
                temp_model = ListWorkItemWorkFlowStatusResponseBodyStatuses()
                self.statuses.append(temp_model.from_map(k))
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListWorkItemWorkFlowStatusResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkItemWorkFlowStatusResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkItemWorkFlowStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkitemAttachmentsResponseBodyAttachments(TeaModel):
    def __init__(
        self,
        creator: str = None,
        file_identifier: str = None,
        file_name: str = None,
        file_suffix: str = None,
        gmt_create: int = None,
        size: str = None,
        url: str = None,
    ):
        self.creator = creator
        self.file_identifier = file_identifier
        self.file_name = file_name
        self.file_suffix = file_suffix
        self.gmt_create = gmt_create
        self.size = size
        self.url = url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['creator'] = self.creator
        if self.file_identifier is not None:
            result['fileIdentifier'] = self.file_identifier
        if self.file_name is not None:
            result['fileName'] = self.file_name
        if self.file_suffix is not None:
            result['fileSuffix'] = self.file_suffix
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.size is not None:
            result['size'] = self.size
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('fileIdentifier') is not None:
            self.file_identifier = m.get('fileIdentifier')
        if m.get('fileName') is not None:
            self.file_name = m.get('fileName')
        if m.get('fileSuffix') is not None:
            self.file_suffix = m.get('fileSuffix')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('size') is not None:
            self.size = m.get('size')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class ListWorkitemAttachmentsResponseBody(TeaModel):
    def __init__(
        self,
        attachments: List[ListWorkitemAttachmentsResponseBodyAttachments] = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.attachments = attachments
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.attachments:
            for k in self.attachments:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['attachments'] = []
        if self.attachments is not None:
            for k in self.attachments:
                result['attachments'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.attachments = []
        if m.get('attachments') is not None:
            for k in m.get('attachments'):
                temp_model = ListWorkitemAttachmentsResponseBodyAttachments()
                self.attachments.append(temp_model.from_map(k))
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListWorkitemAttachmentsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkitemAttachmentsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkitemAttachmentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser(TeaModel):
    def __init__(
        self,
        identifier: str = None,
        name: str = None,
    ):
        self.identifier = identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListWorkitemEstimateResponseBodyWorkitemTimeEstimate(TeaModel):
    def __init__(
        self,
        description: str = None,
        gmt_create: int = None,
        gmt_end: int = None,
        gmt_modified: int = None,
        gmt_start: int = None,
        identifier: str = None,
        record_user: ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser = None,
        spent_time: float = None,
        type: str = None,
        workitem_identifier: str = None,
    ):
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_end = gmt_end
        self.gmt_modified = gmt_modified
        self.gmt_start = gmt_start
        self.identifier = identifier
        self.record_user = record_user
        self.spent_time = spent_time
        self.type = type
        self.workitem_identifier = workitem_identifier

    def validate(self):
        if self.record_user:
            self.record_user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_end is not None:
            result['gmtEnd'] = self.gmt_end
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.record_user is not None:
            result['recordUser'] = self.record_user.to_map()
        if self.spent_time is not None:
            result['spentTime'] = self.spent_time
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtEnd') is not None:
            self.gmt_end = m.get('gmtEnd')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('recordUser') is not None:
            temp_model = ListWorkitemEstimateResponseBodyWorkitemTimeEstimateRecordUser()
            self.record_user = temp_model.from_map(m['recordUser'])
        if m.get('spentTime') is not None:
            self.spent_time = m.get('spentTime')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class ListWorkitemEstimateResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        workitem_time_estimate: List[ListWorkitemEstimateResponseBodyWorkitemTimeEstimate] = None,
    ):
        self.code = code
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success
        self.workitem_time_estimate = workitem_time_estimate

    def validate(self):
        if self.workitem_time_estimate:
            for k in self.workitem_time_estimate:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['workitemTimeEstimate'] = []
        if self.workitem_time_estimate is not None:
            for k in self.workitem_time_estimate:
                result['workitemTimeEstimate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.workitem_time_estimate = []
        if m.get('workitemTimeEstimate') is not None:
            for k in m.get('workitemTimeEstimate'):
                temp_model = ListWorkitemEstimateResponseBodyWorkitemTimeEstimate()
                self.workitem_time_estimate.append(temp_model.from_map(k))
        return self


class ListWorkitemEstimateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkitemEstimateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkitemEstimateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkitemTimeResponseBodyWorkitemTime(TeaModel):
    def __init__(
        self,
        actual_time: float = None,
        description: str = None,
        gmt_create: int = None,
        gmt_end: int = None,
        gmt_modified: int = None,
        gmt_start: int = None,
        identifier: str = None,
        record_user: str = None,
        type: str = None,
        workitem_identifier: str = None,
    ):
        self.actual_time = actual_time
        self.description = description
        self.gmt_create = gmt_create
        self.gmt_end = gmt_end
        self.gmt_modified = gmt_modified
        self.gmt_start = gmt_start
        self.identifier = identifier
        self.record_user = record_user
        self.type = type
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.actual_time is not None:
            result['actualTime'] = self.actual_time
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_end is not None:
            result['gmtEnd'] = self.gmt_end
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.gmt_start is not None:
            result['gmtStart'] = self.gmt_start
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.record_user is not None:
            result['recordUser'] = self.record_user
        if self.type is not None:
            result['type'] = self.type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('actualTime') is not None:
            self.actual_time = m.get('actualTime')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtEnd') is not None:
            self.gmt_end = m.get('gmtEnd')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('gmtStart') is not None:
            self.gmt_start = m.get('gmtStart')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('recordUser') is not None:
            self.record_user = m.get('recordUser')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class ListWorkitemTimeResponseBody(TeaModel):
    def __init__(
        self,
        code: int = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        workitem_time: List[ListWorkitemTimeResponseBodyWorkitemTime] = None,
    ):
        self.code = code
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success
        self.workitem_time = workitem_time

    def validate(self):
        if self.workitem_time:
            for k in self.workitem_time:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        result['workitemTime'] = []
        if self.workitem_time is not None:
            for k in self.workitem_time:
                result['workitemTime'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        self.workitem_time = []
        if m.get('workitemTime') is not None:
            for k in m.get('workitemTime'):
                temp_model = ListWorkitemTimeResponseBodyWorkitemTime()
                self.workitem_time.append(temp_model.from_map(k))
        return self


class ListWorkitemTimeResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkitemTimeResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkitemTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListWorkitemsRequest(TeaModel):
    def __init__(
        self,
        category: str = None,
        conditions: str = None,
        extra_conditions: str = None,
        group_condition: str = None,
        max_results: str = None,
        next_token: str = None,
        order_by: str = None,
        search_type: str = None,
        space_identifier: str = None,
        space_type: str = None,
    ):
        # This parameter is required.
        self.category = category
        self.conditions = conditions
        self.extra_conditions = extra_conditions
        self.group_condition = group_condition
        self.max_results = max_results
        self.next_token = next_token
        self.order_by = order_by
        self.search_type = search_type
        # This parameter is required.
        self.space_identifier = space_identifier
        # This parameter is required.
        self.space_type = space_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.conditions is not None:
            result['conditions'] = self.conditions
        if self.extra_conditions is not None:
            result['extraConditions'] = self.extra_conditions
        if self.group_condition is not None:
            result['groupCondition'] = self.group_condition
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.order_by is not None:
            result['orderBy'] = self.order_by
        if self.search_type is not None:
            result['searchType'] = self.search_type
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('conditions') is not None:
            self.conditions = m.get('conditions')
        if m.get('extraConditions') is not None:
            self.extra_conditions = m.get('extraConditions')
        if m.get('groupCondition') is not None:
            self.group_condition = m.get('groupCondition')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('orderBy') is not None:
            self.order_by = m.get('orderBy')
        if m.get('searchType') is not None:
            self.search_type = m.get('searchType')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        return self


class ListWorkitemsResponseBodyWorkitems(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category_identifier: str = None,
        creator: str = None,
        document: str = None,
        finish_time: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        logical_status: str = None,
        modifier: str = None,
        parent_identifier: str = None,
        serial_number: str = None,
        space_identifier: str = None,
        space_name: str = None,
        space_type: str = None,
        sprint_identifier: str = None,
        status: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        subject: str = None,
        update_status_at: int = None,
        workitem_type_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.document = document
        self.finish_time = finish_time
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.logical_status = logical_status
        self.modifier = modifier
        self.parent_identifier = parent_identifier
        self.serial_number = serial_number
        self.space_identifier = space_identifier
        self.space_name = space_name
        self.space_type = space_type
        self.sprint_identifier = sprint_identifier
        self.status = status
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.subject = subject
        self.update_status_at = update_status_at
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.document is not None:
            result['document'] = self.document
        if self.finish_time is not None:
            result['finishTime'] = self.finish_time
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_name is not None:
            result['spaceName'] = self.space_name
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.sprint_identifier is not None:
            result['sprintIdentifier'] = self.sprint_identifier
        if self.status is not None:
            result['status'] = self.status
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.update_status_at is not None:
            result['updateStatusAt'] = self.update_status_at
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('document') is not None:
            self.document = m.get('document')
        if m.get('finishTime') is not None:
            self.finish_time = m.get('finishTime')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceName') is not None:
            self.space_name = m.get('spaceName')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('sprintIdentifier') is not None:
            self.sprint_identifier = m.get('sprintIdentifier')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('updateStatusAt') is not None:
            self.update_status_at = m.get('updateStatusAt')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class ListWorkitemsResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        max_results: int = None,
        next_token: str = None,
        request_id: str = None,
        success: bool = None,
        total_count: int = None,
        workitems: List[ListWorkitemsResponseBodyWorkitems] = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.max_results = max_results
        self.next_token = next_token
        self.request_id = request_id
        self.success = success
        self.total_count = total_count
        self.workitems = workitems

    def validate(self):
        if self.workitems:
            for k in self.workitems:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.max_results is not None:
            result['maxResults'] = self.max_results
        if self.next_token is not None:
            result['nextToken'] = self.next_token
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.total_count is not None:
            result['totalCount'] = self.total_count
        result['workitems'] = []
        if self.workitems is not None:
            for k in self.workitems:
                result['workitems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('maxResults') is not None:
            self.max_results = m.get('maxResults')
        if m.get('nextToken') is not None:
            self.next_token = m.get('nextToken')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('totalCount') is not None:
            self.total_count = m.get('totalCount')
        self.workitems = []
        if m.get('workitems') is not None:
            for k in m.get('workitems'):
                temp_model = ListWorkitemsResponseBodyWorkitems()
                self.workitems.append(temp_model.from_map(k))
        return self


class ListWorkitemsResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ListWorkitemsResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListWorkitemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LogPipelineJobRunResponseBodyLog(TeaModel):
    def __init__(
        self,
        content: str = None,
        more: bool = None,
    ):
        self.content = content
        self.more = more

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.more is not None:
            result['more'] = self.more
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('more') is not None:
            self.more = m.get('more')
        return self


class LogPipelineJobRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        log: LogPipelineJobRunResponseBodyLog = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.log = log
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.log:
            self.log.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.log is not None:
            result['log'] = self.log.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('log') is not None:
            temp_model = LogPipelineJobRunResponseBodyLog()
            self.log = temp_model.from_map(m['log'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class LogPipelineJobRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LogPipelineJobRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LogPipelineJobRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LogVMDeployMachineResponseBodyDeployMachineLog(TeaModel):
    def __init__(
        self,
        aliyun_region: str = None,
        deploy_begin_time: int = None,
        deploy_end_time: int = None,
        deploy_log: str = None,
        deploy_log_path: str = None,
    ):
        self.aliyun_region = aliyun_region
        self.deploy_begin_time = deploy_begin_time
        self.deploy_end_time = deploy_end_time
        self.deploy_log = deploy_log
        self.deploy_log_path = deploy_log_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_region is not None:
            result['aliyunRegion'] = self.aliyun_region
        if self.deploy_begin_time is not None:
            result['deployBeginTime'] = self.deploy_begin_time
        if self.deploy_end_time is not None:
            result['deployEndTime'] = self.deploy_end_time
        if self.deploy_log is not None:
            result['deployLog'] = self.deploy_log
        if self.deploy_log_path is not None:
            result['deployLogPath'] = self.deploy_log_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunRegion') is not None:
            self.aliyun_region = m.get('aliyunRegion')
        if m.get('deployBeginTime') is not None:
            self.deploy_begin_time = m.get('deployBeginTime')
        if m.get('deployEndTime') is not None:
            self.deploy_end_time = m.get('deployEndTime')
        if m.get('deployLog') is not None:
            self.deploy_log = m.get('deployLog')
        if m.get('deployLogPath') is not None:
            self.deploy_log_path = m.get('deployLogPath')
        return self


class LogVMDeployMachineResponseBody(TeaModel):
    def __init__(
        self,
        deploy_machine_log: LogVMDeployMachineResponseBodyDeployMachineLog = None,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.deploy_machine_log = deploy_machine_log
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.deploy_machine_log:
            self.deploy_machine_log.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_machine_log is not None:
            result['deployMachineLog'] = self.deploy_machine_log.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deployMachineLog') is not None:
            temp_model = LogVMDeployMachineResponseBodyDeployMachineLog()
            self.deploy_machine_log = temp_model.from_map(m['deployMachineLog'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class LogVMDeployMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: LogVMDeployMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LogVMDeployMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MergeMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        merge_message: str = None,
        merge_type: str = None,
        remove_source_branch: bool = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.merge_message = merge_message
        # This parameter is required.
        self.merge_type = merge_type
        self.remove_source_branch = remove_source_branch
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.merge_message is not None:
            result['mergeMessage'] = self.merge_message
        if self.merge_type is not None:
            result['mergeType'] = self.merge_type
        if self.remove_source_branch is not None:
            result['removeSourceBranch'] = self.remove_source_branch
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('mergeMessage') is not None:
            self.merge_message = m.get('mergeMessage')
        if m.get('mergeType') is not None:
            self.merge_type = m.get('mergeType')
        if m.get('removeSourceBranch') is not None:
            self.remove_source_branch = m.get('removeSourceBranch')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class MergeMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        biz_id: str = None,
        local_id: int = None,
        merged_revision: str = None,
        project_id: int = None,
        result: bool = None,
    ):
        self.biz_id = biz_id
        self.local_id = local_id
        self.merged_revision = merged_revision
        self.project_id = project_id
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_id is not None:
            result['bizId'] = self.biz_id
        if self.local_id is not None:
            result['localId'] = self.local_id
        if self.merged_revision is not None:
            result['mergedRevision'] = self.merged_revision
        if self.project_id is not None:
            result['projectId'] = self.project_id
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizId') is not None:
            self.biz_id = m.get('bizId')
        if m.get('localId') is not None:
            self.local_id = m.get('localId')
        if m.get('mergedRevision') is not None:
            self.merged_revision = m.get('mergedRevision')
        if m.get('projectId') is not None:
            self.project_id = m.get('projectId')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class MergeMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: MergeMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = MergeMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class MergeMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: MergeMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MergeMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PassPipelineValidateResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class PassPipelineValidateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PassPipelineValidateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PassPipelineValidateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PassReleaseStagePipelineValidateRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        organization_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['jobId'] = self.job_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobId') is not None:
            self.job_id = m.get('jobId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class PassReleaseStagePipelineValidateResponseBody(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class PassReleaseStagePipelineValidateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: PassReleaseStagePipelineValidateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PassReleaseStagePipelineValidateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefusePipelineValidateResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class RefusePipelineValidateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefusePipelineValidateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefusePipelineValidateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefuseReleaseStagePipelineValidateRequest(TeaModel):
    def __init__(
        self,
        job_id: str = None,
        organization_id: str = None,
    ):
        # This parameter is required.
        self.job_id = job_id
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['jobId'] = self.job_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('jobId') is not None:
            self.job_id = m.get('jobId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class RefuseReleaseStagePipelineValidateResponseBody(TeaModel):
    def __init__(
        self,
        success: bool = None,
    ):
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class RefuseReleaseStagePipelineValidateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RefuseReleaseStagePipelineValidateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefuseReleaseStagePipelineValidateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReopenMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ReopenMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class ReopenMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: ReopenMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = ReopenMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ReopenMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReopenMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReopenMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetSshKeyResponseBodySshKey(TeaModel):
    def __init__(
        self,
        id: int = None,
        public_key: str = None,
    ):
        self.id = id
        self.public_key = public_key

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.public_key is not None:
            result['publicKey'] = self.public_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('publicKey') is not None:
            self.public_key = m.get('publicKey')
        return self


class ResetSshKeyResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        ssh_key: ResetSshKeyResponseBodySshKey = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.ssh_key = ssh_key
        self.success = success

    def validate(self):
        if self.ssh_key:
            self.ssh_key.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.ssh_key is not None:
            result['sshKey'] = self.ssh_key.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('sshKey') is not None:
            temp_model = ResetSshKeyResponseBodySshKey()
            self.ssh_key = temp_model.from_map(m['sshKey'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ResetSshKeyResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResetSshKeyResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetSshKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResumeVMDeployOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ResumeVMDeployOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ResumeVMDeployOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResumeVMDeployOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetryPipelineJobRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class RetryPipelineJobRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetryPipelineJobRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetryPipelineJobRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RetryVMDeployMachineResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class RetryVMDeployMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: RetryVMDeployMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RetryVMDeployMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReviewMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        draft_comment_ids: List[str] = None,
        review_comment: str = None,
        review_opinion: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.draft_comment_ids = draft_comment_ids
        self.review_comment = review_comment
        # This parameter is required.
        self.review_opinion = review_opinion
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.draft_comment_ids is not None:
            result['draftCommentIds'] = self.draft_comment_ids
        if self.review_comment is not None:
            result['reviewComment'] = self.review_comment
        if self.review_opinion is not None:
            result['reviewOpinion'] = self.review_opinion
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('draftCommentIds') is not None:
            self.draft_comment_ids = m.get('draftCommentIds')
        if m.get('reviewComment') is not None:
            self.review_comment = m.get('reviewComment')
        if m.get('reviewOpinion') is not None:
            self.review_opinion = m.get('reviewOpinion')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class ReviewMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class ReviewMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: ReviewMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = ReviewMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ReviewMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: ReviewMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReviewMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SkipPipelineJobRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SkipPipelineJobRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SkipPipelineJobRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SkipPipelineJobRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SkipVMDeployMachineResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SkipVMDeployMachineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: SkipVMDeployMachineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SkipVMDeployMachineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartPipelineRunRequest(TeaModel):
    def __init__(
        self,
        params: str = None,
    ):
        self.params = params

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.params is not None:
            result['params'] = self.params
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('params') is not None:
            self.params = m.get('params')
        return self


class StartPipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        pipeline_run_id: int = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.pipeline_run_id = pipeline_run_id
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.pipeline_run_id is not None:
            result['pipelineRunId'] = self.pipeline_run_id
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('pipelineRunId') is not None:
            self.pipeline_run_id = m.get('pipelineRunId')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class StartPipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StartPipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartPipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopPipelineJobRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class StopPipelineJobRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopPipelineJobRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopPipelineJobRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopPipelineRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class StopPipelineRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopPipelineRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopPipelineRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopVMDeployOrderResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class StopVMDeployOrderResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: StopVMDeployOrderResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopVMDeployOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TransferRepositoryRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        group_id: str = None,
        organization_id: str = None,
        repository_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.group_id = group_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_id = repository_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.group_id is not None:
            result['groupId'] = self.group_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_id is not None:
            result['repositoryId'] = self.repository_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('groupId') is not None:
            self.group_id = m.get('groupId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryId') is not None:
            self.repository_id = m.get('repositoryId')
        return self


class TransferRepositoryResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        archived: bool = None,
        created_at: str = None,
        creator_id: int = None,
        demo_project: bool = None,
        description: str = None,
        encrypted: bool = None,
        id: int = None,
        last_activity_at: str = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        star_count: int = None,
        starred: bool = None,
        updated_at: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.access_level = access_level
        self.archived = archived
        self.created_at = created_at
        self.creator_id = creator_id
        self.demo_project = demo_project
        self.description = description
        self.encrypted = encrypted
        self.id = id
        self.last_activity_at = last_activity_at
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace_id = namespace_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.star_count = star_count
        self.starred = starred
        self.updated_at = updated_at
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.archived is not None:
            result['archived'] = self.archived
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.demo_project is not None:
            result['demoProject'] = self.demo_project
        if self.description is not None:
            result['description'] = self.description
        if self.encrypted is not None:
            result['encrypted'] = self.encrypted
        if self.id is not None:
            result['id'] = self.id
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace_id is not None:
            result['namespaceId'] = self.namespace_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.star_count is not None:
            result['starCount'] = self.star_count
        if self.starred is not None:
            result['starred'] = self.starred
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('archived') is not None:
            self.archived = m.get('archived')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('demoProject') is not None:
            self.demo_project = m.get('demoProject')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('encrypted') is not None:
            self.encrypted = m.get('encrypted')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespaceId') is not None:
            self.namespace_id = m.get('namespaceId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('starCount') is not None:
            self.star_count = m.get('starCount')
        if m.get('starred') is not None:
            self.starred = m.get('starred')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class TransferRepositoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: TransferRepositoryResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = TransferRepositoryResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class TransferRepositoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TransferRepositoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TransferRepositoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TriggerRepositoryMirrorSyncRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        account: str = None,
        organization_id: str = None,
        token: str = None,
    ):
        self.access_token = access_token
        self.account = account
        # This parameter is required.
        self.organization_id = organization_id
        self.token = token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.account is not None:
            result['account'] = self.account
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.token is not None:
            result['token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('token') is not None:
            self.token = m.get('token')
        return self


class TriggerRepositoryMirrorSyncResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class TriggerRepositoryMirrorSyncResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: TriggerRepositoryMirrorSyncResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = TriggerRepositoryMirrorSyncResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class TriggerRepositoryMirrorSyncResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: TriggerRepositoryMirrorSyncResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TriggerRepositoryMirrorSyncResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateAppMemberRequestPlayer(TeaModel):
    def __init__(
        self,
        id: str = None,
        type: str = None,
    ):
        self.id = id
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class UpdateAppMemberRequest(TeaModel):
    def __init__(
        self,
        player: UpdateAppMemberRequestPlayer = None,
        role_names: List[str] = None,
        organization_id: str = None,
    ):
        self.player = player
        self.role_names = role_names
        self.organization_id = organization_id

    def validate(self):
        if self.player:
            self.player.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.player is not None:
            result['player'] = self.player.to_map()
        if self.role_names is not None:
            result['roleNames'] = self.role_names
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('player') is not None:
            temp_model = UpdateAppMemberRequestPlayer()
            self.player = temp_model.from_map(m['player'])
        if m.get('roleNames') is not None:
            self.role_names = m.get('roleNames')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateAppMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: str = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            self.body = m.get('body')
        return self


class UpdateApplicationRequest(TeaModel):
    def __init__(
        self,
        owner_account_id: str = None,
        organization_id: str = None,
    ):
        self.owner_account_id = owner_account_id
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account_id is not None:
            result['ownerAccountId'] = self.owner_account_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ownerAccountId') is not None:
            self.owner_account_id = m.get('ownerAccountId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateApplicationResponseBody(TeaModel):
    def __init__(
        self,
        creator_account_id: str = None,
        description: str = None,
        gmt_create: str = None,
        name: str = None,
        request_id: str = None,
    ):
        self.creator_account_id = creator_account_id
        self.description = description
        self.gmt_create = gmt_create
        self.name = name
        self.request_id = request_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator_account_id is not None:
            result['creatorAccountId'] = self.creator_account_id
        if self.description is not None:
            result['description'] = self.description
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.name is not None:
            result['name'] = self.name
        if self.request_id is not None:
            result['requestId'] = self.request_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creatorAccountId') is not None:
            self.creator_account_id = m.get('creatorAccountId')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        return self


class UpdateApplicationResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateApplicationResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateApplicationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCheckRunRequestAnnotations(TeaModel):
    def __init__(
        self,
        annotation_level: str = None,
        end_column: int = None,
        end_line: int = None,
        message: str = None,
        path: str = None,
        raw_details: str = None,
        start_column: int = None,
        start_line: int = None,
        title: str = None,
    ):
        # This parameter is required.
        self.annotation_level = annotation_level
        self.end_column = end_column
        # This parameter is required.
        self.end_line = end_line
        # This parameter is required.
        self.message = message
        # This parameter is required.
        self.path = path
        self.raw_details = raw_details
        self.start_column = start_column
        # This parameter is required.
        self.start_line = start_line
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation_level is not None:
            result['annotationLevel'] = self.annotation_level
        if self.end_column is not None:
            result['endColumn'] = self.end_column
        if self.end_line is not None:
            result['endLine'] = self.end_line
        if self.message is not None:
            result['message'] = self.message
        if self.path is not None:
            result['path'] = self.path
        if self.raw_details is not None:
            result['rawDetails'] = self.raw_details
        if self.start_column is not None:
            result['startColumn'] = self.start_column
        if self.start_line is not None:
            result['startLine'] = self.start_line
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotationLevel') is not None:
            self.annotation_level = m.get('annotationLevel')
        if m.get('endColumn') is not None:
            self.end_column = m.get('endColumn')
        if m.get('endLine') is not None:
            self.end_line = m.get('endLine')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('rawDetails') is not None:
            self.raw_details = m.get('rawDetails')
        if m.get('startColumn') is not None:
            self.start_column = m.get('startColumn')
        if m.get('startLine') is not None:
            self.start_line = m.get('startLine')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class UpdateCheckRunRequestOutputImages(TeaModel):
    def __init__(
        self,
        alt: str = None,
        caption: str = None,
        image_url: str = None,
    ):
        # This parameter is required.
        self.alt = alt
        self.caption = caption
        # This parameter is required.
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alt is not None:
            result['alt'] = self.alt
        if self.caption is not None:
            result['caption'] = self.caption
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alt') is not None:
            self.alt = m.get('alt')
        if m.get('caption') is not None:
            self.caption = m.get('caption')
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        return self


class UpdateCheckRunRequestOutput(TeaModel):
    def __init__(
        self,
        images: List[UpdateCheckRunRequestOutputImages] = None,
        summary: str = None,
        text: str = None,
        title: str = None,
    ):
        self.images = images
        # This parameter is required.
        self.summary = summary
        self.text = text
        self.title = title

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['images'] = []
        if self.images is not None:
            for k in self.images:
                result['images'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary
        if self.text is not None:
            result['text'] = self.text
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('images') is not None:
            for k in m.get('images'):
                temp_model = UpdateCheckRunRequestOutputImages()
                self.images.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class UpdateCheckRunRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        annotations: List[UpdateCheckRunRequestAnnotations] = None,
        completed_at: str = None,
        conclusion: str = None,
        details_url: str = None,
        external_id: str = None,
        name: str = None,
        output: UpdateCheckRunRequestOutput = None,
        started_at: str = None,
        status: str = None,
        check_run_id: int = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        self.annotations = annotations
        self.completed_at = completed_at
        self.conclusion = conclusion
        self.details_url = details_url
        self.external_id = external_id
        self.name = name
        self.output = output
        self.started_at = started_at
        self.status = status
        # This parameter is required.
        self.check_run_id = check_run_id
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.conclusion is not None:
            result['conclusion'] = self.conclusion
        if self.details_url is not None:
            result['detailsUrl'] = self.details_url
        if self.external_id is not None:
            result['externalId'] = self.external_id
        if self.name is not None:
            result['name'] = self.name
        if self.output is not None:
            result['output'] = self.output.to_map()
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.check_run_id is not None:
            result['checkRunId'] = self.check_run_id
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = UpdateCheckRunRequestAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('conclusion') is not None:
            self.conclusion = m.get('conclusion')
        if m.get('detailsUrl') is not None:
            self.details_url = m.get('detailsUrl')
        if m.get('externalId') is not None:
            self.external_id = m.get('externalId')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('output') is not None:
            temp_model = UpdateCheckRunRequestOutput()
            self.output = temp_model.from_map(m['output'])
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('checkRunId') is not None:
            self.check_run_id = m.get('checkRunId')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class UpdateCheckRunResponseBodyResultAnnotations(TeaModel):
    def __init__(
        self,
        annotation_level: str = None,
        end_column: int = None,
        end_line: int = None,
        id: int = None,
        message: str = None,
        path: str = None,
        raw_details: str = None,
        start_column: int = None,
        start_line: int = None,
        title: str = None,
    ):
        self.annotation_level = annotation_level
        self.end_column = end_column
        self.end_line = end_line
        self.id = id
        self.message = message
        self.path = path
        self.raw_details = raw_details
        self.start_column = start_column
        self.start_line = start_line
        self.title = title

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotation_level is not None:
            result['annotationLevel'] = self.annotation_level
        if self.end_column is not None:
            result['endColumn'] = self.end_column
        if self.end_line is not None:
            result['endLine'] = self.end_line
        if self.id is not None:
            result['id'] = self.id
        if self.message is not None:
            result['message'] = self.message
        if self.path is not None:
            result['path'] = self.path
        if self.raw_details is not None:
            result['rawDetails'] = self.raw_details
        if self.start_column is not None:
            result['startColumn'] = self.start_column
        if self.start_line is not None:
            result['startLine'] = self.start_line
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotationLevel') is not None:
            self.annotation_level = m.get('annotationLevel')
        if m.get('endColumn') is not None:
            self.end_column = m.get('endColumn')
        if m.get('endLine') is not None:
            self.end_line = m.get('endLine')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('rawDetails') is not None:
            self.raw_details = m.get('rawDetails')
        if m.get('startColumn') is not None:
            self.start_column = m.get('startColumn')
        if m.get('startLine') is not None:
            self.start_line = m.get('startLine')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class UpdateCheckRunResponseBodyResultCheckSuite(TeaModel):
    def __init__(
        self,
        id: int = None,
    ):
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class UpdateCheckRunResponseBodyResultOutputImages(TeaModel):
    def __init__(
        self,
        alt: str = None,
        caption: str = None,
        image_url: str = None,
    ):
        self.alt = alt
        self.caption = caption
        self.image_url = image_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alt is not None:
            result['alt'] = self.alt
        if self.caption is not None:
            result['caption'] = self.caption
        if self.image_url is not None:
            result['imageUrl'] = self.image_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alt') is not None:
            self.alt = m.get('alt')
        if m.get('caption') is not None:
            self.caption = m.get('caption')
        if m.get('imageUrl') is not None:
            self.image_url = m.get('imageUrl')
        return self


class UpdateCheckRunResponseBodyResultOutput(TeaModel):
    def __init__(
        self,
        images: List[UpdateCheckRunResponseBodyResultOutputImages] = None,
        summary: str = None,
        text: str = None,
        title: str = None,
    ):
        self.images = images
        self.summary = summary
        self.text = text
        self.title = title

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['images'] = []
        if self.images is not None:
            for k in self.images:
                result['images'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary
        if self.text is not None:
            result['text'] = self.text
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.images = []
        if m.get('images') is not None:
            for k in m.get('images'):
                temp_model = UpdateCheckRunResponseBodyResultOutputImages()
                self.images.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('text') is not None:
            self.text = m.get('text')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class UpdateCheckRunResponseBodyResultWriter(TeaModel):
    def __init__(
        self,
        id: str = None,
        logo_url: str = None,
        name: str = None,
        slug: str = None,
        type: str = None,
    ):
        self.id = id
        self.logo_url = logo_url
        self.name = name
        self.slug = slug
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.logo_url is not None:
            result['logoUrl'] = self.logo_url
        if self.name is not None:
            result['name'] = self.name
        if self.slug is not None:
            result['slug'] = self.slug
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('logoUrl') is not None:
            self.logo_url = m.get('logoUrl')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('slug') is not None:
            self.slug = m.get('slug')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class UpdateCheckRunResponseBodyResult(TeaModel):
    def __init__(
        self,
        annotations: List[UpdateCheckRunResponseBodyResultAnnotations] = None,
        check_suite: UpdateCheckRunResponseBodyResultCheckSuite = None,
        completed_at: str = None,
        conclusion: str = None,
        created_at: str = None,
        details_url: str = None,
        external_id: str = None,
        head_sha: str = None,
        id: int = None,
        name: str = None,
        output: UpdateCheckRunResponseBodyResultOutput = None,
        started_at: str = None,
        status: str = None,
        updated_at: str = None,
        writer: UpdateCheckRunResponseBodyResultWriter = None,
    ):
        self.annotations = annotations
        self.check_suite = check_suite
        self.completed_at = completed_at
        self.conclusion = conclusion
        self.created_at = created_at
        self.details_url = details_url
        self.external_id = external_id
        self.head_sha = head_sha
        self.id = id
        self.name = name
        self.output = output
        self.started_at = started_at
        self.status = status
        self.updated_at = updated_at
        self.writer = writer

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.check_suite:
            self.check_suite.validate()
        if self.output:
            self.output.validate()
        if self.writer:
            self.writer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.check_suite is not None:
            result['checkSuite'] = self.check_suite.to_map()
        if self.completed_at is not None:
            result['completedAt'] = self.completed_at
        if self.conclusion is not None:
            result['conclusion'] = self.conclusion
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.details_url is not None:
            result['detailsUrl'] = self.details_url
        if self.external_id is not None:
            result['externalId'] = self.external_id
        if self.head_sha is not None:
            result['headSha'] = self.head_sha
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.output is not None:
            result['output'] = self.output.to_map()
        if self.started_at is not None:
            result['startedAt'] = self.started_at
        if self.status is not None:
            result['status'] = self.status
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.writer is not None:
            result['writer'] = self.writer.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = UpdateCheckRunResponseBodyResultAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('checkSuite') is not None:
            temp_model = UpdateCheckRunResponseBodyResultCheckSuite()
            self.check_suite = temp_model.from_map(m['checkSuite'])
        if m.get('completedAt') is not None:
            self.completed_at = m.get('completedAt')
        if m.get('conclusion') is not None:
            self.conclusion = m.get('conclusion')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('detailsUrl') is not None:
            self.details_url = m.get('detailsUrl')
        if m.get('externalId') is not None:
            self.external_id = m.get('externalId')
        if m.get('headSha') is not None:
            self.head_sha = m.get('headSha')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('output') is not None:
            temp_model = UpdateCheckRunResponseBodyResultOutput()
            self.output = temp_model.from_map(m['output'])
        if m.get('startedAt') is not None:
            self.started_at = m.get('startedAt')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('writer') is not None:
            temp_model = UpdateCheckRunResponseBodyResultWriter()
            self.writer = temp_model.from_map(m['writer'])
        return self


class UpdateCheckRunResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateCheckRunResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateCheckRunResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateCheckRunResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateCheckRunResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCheckRunResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFileRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        branch_name: str = None,
        commit_message: str = None,
        content: str = None,
        encoding: str = None,
        new_path: str = None,
        old_path: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.branch_name = branch_name
        # This parameter is required.
        self.commit_message = commit_message
        # This parameter is required.
        self.content = content
        self.encoding = encoding
        # This parameter is required.
        self.new_path = new_path
        # This parameter is required.
        self.old_path = old_path
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.commit_message is not None:
            result['commitMessage'] = self.commit_message
        if self.content is not None:
            result['content'] = self.content
        if self.encoding is not None:
            result['encoding'] = self.encoding
        if self.new_path is not None:
            result['newPath'] = self.new_path
        if self.old_path is not None:
            result['oldPath'] = self.old_path
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('commitMessage') is not None:
            self.commit_message = m.get('commitMessage')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('encoding') is not None:
            self.encoding = m.get('encoding')
        if m.get('newPath') is not None:
            self.new_path = m.get('newPath')
        if m.get('oldPath') is not None:
            self.old_path = m.get('oldPath')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateFileResponseBodyResult(TeaModel):
    def __init__(
        self,
        branch_name: str = None,
        file_path: str = None,
    ):
        self.branch_name = branch_name
        self.file_path = file_path

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.branch_name is not None:
            result['branchName'] = self.branch_name
        if self.file_path is not None:
            result['filePath'] = self.file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('branchName') is not None:
            self.branch_name = m.get('branchName')
        if m.get('filePath') is not None:
            self.file_path = m.get('filePath')
        return self


class UpdateFileResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateFileResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateFileResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateFileResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFileResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFlowTagRequest(TeaModel):
    def __init__(
        self,
        color: str = None,
        flow_tag_group_id: int = None,
        name: str = None,
    ):
        # This parameter is required.
        self.color = color
        # This parameter is required.
        self.flow_tag_group_id = flow_tag_group_id
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.flow_tag_group_id is not None:
            result['flowTagGroupId'] = self.flow_tag_group_id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('flowTagGroupId') is not None:
            self.flow_tag_group_id = m.get('flowTagGroupId')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateFlowTagResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateFlowTagResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFlowTagResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFlowTagResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFlowTagGroupRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateFlowTagGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateFlowTagGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateFlowTagGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFlowTagGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGroupRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        avatar_url: str = None,
        description: str = None,
        name: str = None,
        path: str = None,
        path_with_namespace: str = None,
        visibility_level: int = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.avatar_url = avatar_url
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.path = path
        # This parameter is required.
        self.path_with_namespace = path_with_namespace
        self.visibility_level = visibility_level
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateGroupResponseBodyResult(TeaModel):
    def __init__(
        self,
        avatar_url: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        name_with_namespace: str = None,
        owner_id: int = None,
        parent_id: int = None,
        path: str = None,
        path_with_namespace: str = None,
        type: str = None,
        visibility_level: int = None,
        web_url: str = None,
    ):
        self.avatar_url = avatar_url
        self.description = description
        self.id = id
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.owner_id = owner_id
        self.parent_id = parent_id
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.type = type
        self.visibility_level = visibility_level
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.type is not None:
            result['type'] = self.type
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class UpdateGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateGroupResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateGroupResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateGroupMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        aliyun_pk: str = None,
        access_level: int = None,
        member_type: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        # This parameter is required.
        self.aliyun_pk = aliyun_pk
        # This parameter is required.
        self.access_level = access_level
        self.member_type = member_type
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.aliyun_pk is not None:
            result['aliyunPk'] = self.aliyun_pk
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('aliyunPk') is not None:
            self.aliyun_pk = m.get('aliyunPk')
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateGroupMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        id: int = None,
        member_type: str = None,
        name: str = None,
        source_id: int = None,
        state: str = None,
        username: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.id = id
        self.member_type = member_type
        self.name = name
        self.source_id = source_id
        self.state = state
        self.username = username

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.id is not None:
            result['id'] = self.id
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.name is not None:
            result['name'] = self.name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class UpdateGroupMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateGroupMemberResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateGroupMemberResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateGroupMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateGroupMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateGroupMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateHostGroupRequest(TeaModel):
    def __init__(
        self,
        aliyun_region: str = None,
        ecs_label_key: str = None,
        ecs_label_value: str = None,
        ecs_type: str = None,
        env_id: str = None,
        machine_infos: str = None,
        name: str = None,
        service_connection_id: int = None,
        tag_ids: str = None,
        type: str = None,
    ):
        self.aliyun_region = aliyun_region
        self.ecs_label_key = ecs_label_key
        self.ecs_label_value = ecs_label_value
        self.ecs_type = ecs_type
        self.env_id = env_id
        self.machine_infos = machine_infos
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.service_connection_id = service_connection_id
        self.tag_ids = tag_ids
        # This parameter is required.
        self.type = type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_region is not None:
            result['aliyunRegion'] = self.aliyun_region
        if self.ecs_label_key is not None:
            result['ecsLabelKey'] = self.ecs_label_key
        if self.ecs_label_value is not None:
            result['ecsLabelValue'] = self.ecs_label_value
        if self.ecs_type is not None:
            result['ecsType'] = self.ecs_type
        if self.env_id is not None:
            result['envId'] = self.env_id
        if self.machine_infos is not None:
            result['machineInfos'] = self.machine_infos
        if self.name is not None:
            result['name'] = self.name
        if self.service_connection_id is not None:
            result['serviceConnectionId'] = self.service_connection_id
        if self.tag_ids is not None:
            result['tagIds'] = self.tag_ids
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyunRegion') is not None:
            self.aliyun_region = m.get('aliyunRegion')
        if m.get('ecsLabelKey') is not None:
            self.ecs_label_key = m.get('ecsLabelKey')
        if m.get('ecsLabelValue') is not None:
            self.ecs_label_value = m.get('ecsLabelValue')
        if m.get('ecsType') is not None:
            self.ecs_type = m.get('ecsType')
        if m.get('envId') is not None:
            self.env_id = m.get('envId')
        if m.get('machineInfos') is not None:
            self.machine_infos = m.get('machineInfos')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('serviceConnectionId') is not None:
            self.service_connection_id = m.get('serviceConnectionId')
        if m.get('tagIds') is not None:
            self.tag_ids = m.get('tagIds')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class UpdateHostGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateHostGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateHostGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateHostGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMergeRequestRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        description: str = None,
        title: str = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.description = description
        self.title = title
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.description is not None:
            result['description'] = self.description
        if self.title is not None:
            result['title'] = self.title
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateMergeRequestResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateMergeRequestResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateMergeRequestResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateMergeRequestResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateMergeRequestResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMergeRequestResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMergeRequestResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMergeRequestPersonnelRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        new_user_id_list: List[str] = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.new_user_id_list = new_user_id_list
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.new_user_id_list is not None:
            result['newUserIdList'] = self.new_user_id_list
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('newUserIdList') is not None:
            self.new_user_id_list = m.get('newUserIdList')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateMergeRequestPersonnelResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateMergeRequestPersonnelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateMergeRequestPersonnelResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateMergeRequestPersonnelResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateMergeRequestPersonnelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateMergeRequestPersonnelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMergeRequestPersonnelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateOrganizationMemberRequest(TeaModel):
    def __init__(
        self,
        organization_member_name: str = None,
    ):
        # This parameter is required.
        self.organization_member_name = organization_member_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_member_name is not None:
            result['organizationMemberName'] = self.organization_member_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationMemberName') is not None:
            self.organization_member_name = m.get('organizationMemberName')
        return self


class UpdateOrganizationMemberResponseBodyMember(TeaModel):
    def __init__(
        self,
        account_id: str = None,
        organization_member_name: str = None,
    ):
        self.account_id = account_id
        self.organization_member_name = organization_member_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['accountId'] = self.account_id
        if self.organization_member_name is not None:
            result['organizationMemberName'] = self.organization_member_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accountId') is not None:
            self.account_id = m.get('accountId')
        if m.get('organizationMemberName') is not None:
            self.organization_member_name = m.get('organizationMemberName')
        return self


class UpdateOrganizationMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        member: UpdateOrganizationMemberResponseBodyMember = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.member = member
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.member:
            self.member.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.member is not None:
            result['member'] = self.member.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('member') is not None:
            temp_model = UpdateOrganizationMemberResponseBodyMember()
            self.member = temp_model.from_map(m['member'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateOrganizationMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateOrganizationMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateOrganizationMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineRequest(TeaModel):
    def __init__(
        self,
        content: str = None,
        name: str = None,
        pipeline_id: str = None,
    ):
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.pipeline_id = pipeline_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.name is not None:
            result['name'] = self.name
        if self.pipeline_id is not None:
            result['pipelineId'] = self.pipeline_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pipelineId') is not None:
            self.pipeline_id = m.get('pipelineId')
        return self


class UpdatePipelineResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdatePipelineResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePipelineResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineBaseInfoRequest(TeaModel):
    def __init__(
        self,
        env_id: int = None,
        pipeline_name: str = None,
        tag_list: str = None,
    ):
        self.env_id = env_id
        # This parameter is required.
        self.pipeline_name = pipeline_name
        self.tag_list = tag_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.env_id is not None:
            result['envId'] = self.env_id
        if self.pipeline_name is not None:
            result['pipelineName'] = self.pipeline_name
        if self.tag_list is not None:
            result['tagList'] = self.tag_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('envId') is not None:
            self.env_id = m.get('envId')
        if m.get('pipelineName') is not None:
            self.pipeline_name = m.get('pipelineName')
        if m.get('tagList') is not None:
            self.tag_list = m.get('tagList')
        return self


class UpdatePipelineBaseInfoResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdatePipelineBaseInfoResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePipelineBaseInfoResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineBaseInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineGroupRequest(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # This parameter is required.
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdatePipelineGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdatePipelineGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePipelineGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProjectFieldRequestUpdateBasicFieldRequestList(TeaModel):
    def __init__(
        self,
        property_key: str = None,
        property_value: str = None,
    ):
        self.property_key = property_key
        self.property_value = property_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.property_key is not None:
            result['propertyKey'] = self.property_key
        if self.property_value is not None:
            result['propertyValue'] = self.property_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('propertyKey') is not None:
            self.property_key = m.get('propertyKey')
        if m.get('propertyValue') is not None:
            self.property_value = m.get('propertyValue')
        return self


class UpdateProjectFieldRequestUpdateForOpenApiList(TeaModel):
    def __init__(
        self,
        field_identifier: str = None,
        value: str = None,
    ):
        self.field_identifier = field_identifier
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class UpdateProjectFieldRequest(TeaModel):
    def __init__(
        self,
        status_identifier: str = None,
        update_basic_field_request_list: List[UpdateProjectFieldRequestUpdateBasicFieldRequestList] = None,
        update_for_open_api_list: List[UpdateProjectFieldRequestUpdateForOpenApiList] = None,
    ):
        self.status_identifier = status_identifier
        self.update_basic_field_request_list = update_basic_field_request_list
        self.update_for_open_api_list = update_for_open_api_list

    def validate(self):
        if self.update_basic_field_request_list:
            for k in self.update_basic_field_request_list:
                if k:
                    k.validate()
        if self.update_for_open_api_list:
            for k in self.update_for_open_api_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        result['updateBasicFieldRequestList'] = []
        if self.update_basic_field_request_list is not None:
            for k in self.update_basic_field_request_list:
                result['updateBasicFieldRequestList'].append(k.to_map() if k else None)
        result['updateForOpenApiList'] = []
        if self.update_for_open_api_list is not None:
            for k in self.update_for_open_api_list:
                result['updateForOpenApiList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        self.update_basic_field_request_list = []
        if m.get('updateBasicFieldRequestList') is not None:
            for k in m.get('updateBasicFieldRequestList'):
                temp_model = UpdateProjectFieldRequestUpdateBasicFieldRequestList()
                self.update_basic_field_request_list.append(temp_model.from_map(k))
        self.update_for_open_api_list = []
        if m.get('updateForOpenApiList') is not None:
            for k in m.get('updateForOpenApiList'):
                temp_model = UpdateProjectFieldRequestUpdateForOpenApiList()
                self.update_for_open_api_list.append(temp_model.from_map(k))
        return self


class UpdateProjectFieldResponseBodyProjectFieldList(TeaModel):
    def __init__(
        self,
        display_name: str = None,
        identifier: str = None,
        value: str = None,
        value_type: str = None,
    ):
        self.display_name = display_name
        self.identifier = identifier
        self.value = value
        self.value_type = value_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.value is not None:
            result['value'] = self.value
        if self.value_type is not None:
            result['valueType'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('valueType') is not None:
            self.value_type = m.get('valueType')
        return self


class UpdateProjectFieldResponseBodyProject(TeaModel):
    def __init__(
        self,
        category: str = None,
        category_identifier: str = None,
        creator: str = None,
        custom_code: str = None,
        description: str = None,
        field_list: List[UpdateProjectFieldResponseBodyProjectFieldList] = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        icon: str = None,
        icon_big: str = None,
        icon_group: str = None,
        icon_small: str = None,
        id: str = None,
        identifier: str = None,
        identifier_path: str = None,
        logical_status: str = None,
        modifier: str = None,
        name: str = None,
        organization_identifier: str = None,
        parent_identifier: str = None,
        scope: str = None,
        status_identifier: str = None,
        status_name: str = None,
        status_stage_identifier: str = None,
        sub_type: str = None,
        type_identifier: str = None,
    ):
        self.category = category
        self.category_identifier = category_identifier
        self.creator = creator
        self.custom_code = custom_code
        self.description = description
        self.field_list = field_list
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.icon = icon
        self.icon_big = icon_big
        self.icon_group = icon_group
        self.icon_small = icon_small
        self.id = id
        self.identifier = identifier
        self.identifier_path = identifier_path
        self.logical_status = logical_status
        self.modifier = modifier
        self.name = name
        self.organization_identifier = organization_identifier
        self.parent_identifier = parent_identifier
        self.scope = scope
        self.status_identifier = status_identifier
        self.status_name = status_name
        self.status_stage_identifier = status_stage_identifier
        self.sub_type = sub_type
        self.type_identifier = type_identifier

    def validate(self):
        if self.field_list:
            for k in self.field_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['category'] = self.category
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.custom_code is not None:
            result['customCode'] = self.custom_code
        if self.description is not None:
            result['description'] = self.description
        result['fieldList'] = []
        if self.field_list is not None:
            for k in self.field_list:
                result['fieldList'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.icon is not None:
            result['icon'] = self.icon
        if self.icon_big is not None:
            result['iconBig'] = self.icon_big
        if self.icon_group is not None:
            result['iconGroup'] = self.icon_group
        if self.icon_small is not None:
            result['iconSmall'] = self.icon_small
        if self.id is not None:
            result['id'] = self.id
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.identifier_path is not None:
            result['identifierPath'] = self.identifier_path
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.name is not None:
            result['name'] = self.name
        if self.organization_identifier is not None:
            result['organizationIdentifier'] = self.organization_identifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.scope is not None:
            result['scope'] = self.scope
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_name is not None:
            result['statusName'] = self.status_name
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.sub_type is not None:
            result['subType'] = self.sub_type
        if self.type_identifier is not None:
            result['typeIdentifier'] = self.type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('customCode') is not None:
            self.custom_code = m.get('customCode')
        if m.get('description') is not None:
            self.description = m.get('description')
        self.field_list = []
        if m.get('fieldList') is not None:
            for k in m.get('fieldList'):
                temp_model = UpdateProjectFieldResponseBodyProjectFieldList()
                self.field_list.append(temp_model.from_map(k))
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('icon') is not None:
            self.icon = m.get('icon')
        if m.get('iconBig') is not None:
            self.icon_big = m.get('iconBig')
        if m.get('iconGroup') is not None:
            self.icon_group = m.get('iconGroup')
        if m.get('iconSmall') is not None:
            self.icon_small = m.get('iconSmall')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('identifierPath') is not None:
            self.identifier_path = m.get('identifierPath')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationIdentifier') is not None:
            self.organization_identifier = m.get('organizationIdentifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusName') is not None:
            self.status_name = m.get('statusName')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subType') is not None:
            self.sub_type = m.get('subType')
        if m.get('typeIdentifier') is not None:
            self.type_identifier = m.get('typeIdentifier')
        return self


class UpdateProjectFieldResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        project: UpdateProjectFieldResponseBodyProject = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.project = project
        self.request_id = request_id
        # true/false
        self.success = success

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.project is not None:
            result['project'] = self.project.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('project') is not None:
            temp_model = UpdateProjectFieldResponseBodyProject()
            self.project = temp_model.from_map(m['project'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateProjectFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProjectFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProjectFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProjectLabelRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        color: str = None,
        description: str = None,
        name: str = None,
        organization_id: str = None,
        repository_identity: str = None,
    ):
        self.access_token = access_token
        self.color = color
        self.description = description
        self.name = name
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.repository_identity = repository_identity

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.repository_identity is not None:
            result['repositoryIdentity'] = self.repository_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('repositoryIdentity') is not None:
            self.repository_identity = m.get('repositoryIdentity')
        return self


class UpdateProjectLabelResponseBodyResult(TeaModel):
    def __init__(
        self,
        color: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
    ):
        self.color = color
        self.description = description
        self.id = id
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.color is not None:
            result['color'] = self.color
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateProjectLabelResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateProjectLabelResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateProjectLabelResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateProjectLabelResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProjectLabelResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProjectLabelResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProjectMemberRequest(TeaModel):
    def __init__(
        self,
        role_identifier: str = None,
        target_identifier: str = None,
        target_type: str = None,
        user_identifier: str = None,
        user_type: str = None,
    ):
        # This parameter is required.
        self.role_identifier = role_identifier
        # This parameter is required.
        self.target_identifier = target_identifier
        # This parameter is required.
        self.target_type = target_type
        # This parameter is required.
        self.user_identifier = user_identifier
        # This parameter is required.
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_identifier is not None:
            result['roleIdentifier'] = self.role_identifier
        if self.target_identifier is not None:
            result['targetIdentifier'] = self.target_identifier
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.user_identifier is not None:
            result['userIdentifier'] = self.user_identifier
        if self.user_type is not None:
            result['userType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('roleIdentifier') is not None:
            self.role_identifier = m.get('roleIdentifier')
        if m.get('targetIdentifier') is not None:
            self.target_identifier = m.get('targetIdentifier')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('userIdentifier') is not None:
            self.user_identifier = m.get('userIdentifier')
        if m.get('userType') is not None:
            self.user_type = m.get('userType')
        return self


class UpdateProjectMemberResponseBodyMember(TeaModel):
    def __init__(
        self,
        gmt_create: int = None,
        gmt_modified: int = None,
        id: str = None,
        role_identifier: str = None,
        target_identifier: str = None,
        target_type: str = None,
        user_identifier: str = None,
        user_type: str = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.role_identifier = role_identifier
        self.target_identifier = target_identifier
        self.target_type = target_type
        self.user_identifier = user_identifier
        self.user_type = user_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        if self.role_identifier is not None:
            result['roleIdentifier'] = self.role_identifier
        if self.target_identifier is not None:
            result['targetIdentifier'] = self.target_identifier
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.user_identifier is not None:
            result['userIdentifier'] = self.user_identifier
        if self.user_type is not None:
            result['userType'] = self.user_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('roleIdentifier') is not None:
            self.role_identifier = m.get('roleIdentifier')
        if m.get('targetIdentifier') is not None:
            self.target_identifier = m.get('targetIdentifier')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('userIdentifier') is not None:
            self.user_identifier = m.get('userIdentifier')
        if m.get('userType') is not None:
            self.user_type = m.get('userType')
        return self


class UpdateProjectMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        member: UpdateProjectMemberResponseBodyMember = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.member = member
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.member:
            self.member.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.member is not None:
            result['member'] = self.member.to_map()
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('member') is not None:
            temp_model = UpdateProjectMemberResponseBodyMember()
            self.member = temp_model.from_map(m['member'])
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateProjectMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProjectMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProjectMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateProtectedBranchesRequestMergeRequestSetting(TeaModel):
    def __init__(
        self,
        allow_merge_request_roles: List[int] = None,
        default_assignees: List[str] = None,
        is_allow_self_approval: bool = None,
        is_require_discussion_processed: bool = None,
        is_required: bool = None,
        is_reset_approval_when_new_push: bool = None,
        minimum_approval: int = None,
        mr_mode: str = None,
        white_list: str = None,
    ):
        self.allow_merge_request_roles = allow_merge_request_roles
        self.default_assignees = default_assignees
        self.is_allow_self_approval = is_allow_self_approval
        self.is_require_discussion_processed = is_require_discussion_processed
        self.is_required = is_required
        self.is_reset_approval_when_new_push = is_reset_approval_when_new_push
        self.minimum_approval = minimum_approval
        self.mr_mode = mr_mode
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_request_roles is not None:
            result['allowMergeRequestRoles'] = self.allow_merge_request_roles
        if self.default_assignees is not None:
            result['defaultAssignees'] = self.default_assignees
        if self.is_allow_self_approval is not None:
            result['isAllowSelfApproval'] = self.is_allow_self_approval
        if self.is_require_discussion_processed is not None:
            result['isRequireDiscussionProcessed'] = self.is_require_discussion_processed
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_reset_approval_when_new_push is not None:
            result['isResetApprovalWhenNewPush'] = self.is_reset_approval_when_new_push
        if self.minimum_approval is not None:
            result['minimumApproval'] = self.minimum_approval
        if self.mr_mode is not None:
            result['mrMode'] = self.mr_mode
        if self.white_list is not None:
            result['whiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRequestRoles') is not None:
            self.allow_merge_request_roles = m.get('allowMergeRequestRoles')
        if m.get('defaultAssignees') is not None:
            self.default_assignees = m.get('defaultAssignees')
        if m.get('isAllowSelfApproval') is not None:
            self.is_allow_self_approval = m.get('isAllowSelfApproval')
        if m.get('isRequireDiscussionProcessed') is not None:
            self.is_require_discussion_processed = m.get('isRequireDiscussionProcessed')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isResetApprovalWhenNewPush') is not None:
            self.is_reset_approval_when_new_push = m.get('isResetApprovalWhenNewPush')
        if m.get('minimumApproval') is not None:
            self.minimum_approval = m.get('minimumApproval')
        if m.get('mrMode') is not None:
            self.mr_mode = m.get('mrMode')
        if m.get('whiteList') is not None:
            self.white_list = m.get('whiteList')
        return self


class UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems(TeaModel):
    def __init__(
        self,
        is_required: bool = None,
        name: str = None,
    ):
        self.is_required = is_required
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateProtectedBranchesRequestTestSettingDTOCheckConfig(TeaModel):
    def __init__(
        self,
        check_items: List[UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems] = None,
    ):
        self.check_items = check_items

    def validate(self):
        if self.check_items:
            for k in self.check_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['checkItems'] = []
        if self.check_items is not None:
            for k in self.check_items:
                result['checkItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_items = []
        if m.get('checkItems') is not None:
            for k in m.get('checkItems'):
                temp_model = UpdateProtectedBranchesRequestTestSettingDTOCheckConfigCheckItems()
                self.check_items.append(temp_model.from_map(k))
        return self


class UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig(TeaModel):
    def __init__(
        self,
        biz_no: str = None,
        enabled: bool = None,
        message: str = None,
        task_name: str = None,
    ):
        self.biz_no = biz_no
        self.enabled = enabled
        self.message = message
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_no is not None:
            result['bizNo'] = self.biz_no
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizNo') is not None:
            self.biz_no = m.get('bizNo')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class UpdateProtectedBranchesRequestTestSettingDTO(TeaModel):
    def __init__(
        self,
        check_config: UpdateProtectedBranchesRequestTestSettingDTOCheckConfig = None,
        check_task_quality_config: UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig = None,
        code_guidelines_detection: UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection = None,
        is_required: bool = None,
        sensitive_info_detection: UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection = None,
    ):
        self.check_config = check_config
        self.check_task_quality_config = check_task_quality_config
        self.code_guidelines_detection = code_guidelines_detection
        self.is_required = is_required
        self.sensitive_info_detection = sensitive_info_detection

    def validate(self):
        if self.check_config:
            self.check_config.validate()
        if self.check_task_quality_config:
            self.check_task_quality_config.validate()
        if self.code_guidelines_detection:
            self.code_guidelines_detection.validate()
        if self.sensitive_info_detection:
            self.sensitive_info_detection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_config is not None:
            result['checkConfig'] = self.check_config.to_map()
        if self.check_task_quality_config is not None:
            result['checkTaskQualityConfig'] = self.check_task_quality_config.to_map()
        if self.code_guidelines_detection is not None:
            result['codeGuidelinesDetection'] = self.code_guidelines_detection.to_map()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.sensitive_info_detection is not None:
            result['sensitiveInfoDetection'] = self.sensitive_info_detection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkConfig') is not None:
            temp_model = UpdateProtectedBranchesRequestTestSettingDTOCheckConfig()
            self.check_config = temp_model.from_map(m['checkConfig'])
        if m.get('checkTaskQualityConfig') is not None:
            temp_model = UpdateProtectedBranchesRequestTestSettingDTOCheckTaskQualityConfig()
            self.check_task_quality_config = temp_model.from_map(m['checkTaskQualityConfig'])
        if m.get('codeGuidelinesDetection') is not None:
            temp_model = UpdateProtectedBranchesRequestTestSettingDTOCodeGuidelinesDetection()
            self.code_guidelines_detection = temp_model.from_map(m['codeGuidelinesDetection'])
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('sensitiveInfoDetection') is not None:
            temp_model = UpdateProtectedBranchesRequestTestSettingDTOSensitiveInfoDetection()
            self.sensitive_info_detection = temp_model.from_map(m['sensitiveInfoDetection'])
        return self


class UpdateProtectedBranchesRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        allow_merge_roles: List[int] = None,
        allow_merge_user_ids: List[str] = None,
        allow_push_roles: List[int] = None,
        allow_push_user_ids: List[str] = None,
        branch: str = None,
        id: int = None,
        merge_request_setting: UpdateProtectedBranchesRequestMergeRequestSetting = None,
        test_setting_dto: UpdateProtectedBranchesRequestTestSettingDTO = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.allow_merge_roles = allow_merge_roles
        self.allow_merge_user_ids = allow_merge_user_ids
        self.allow_push_roles = allow_push_roles
        self.allow_push_user_ids = allow_push_user_ids
        self.branch = branch
        self.id = id
        self.merge_request_setting = merge_request_setting
        self.test_setting_dto = test_setting_dto
        self.organization_id = organization_id

    def validate(self):
        if self.merge_request_setting:
            self.merge_request_setting.validate()
        if self.test_setting_dto:
            self.test_setting_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.allow_merge_roles is not None:
            result['allowMergeRoles'] = self.allow_merge_roles
        if self.allow_merge_user_ids is not None:
            result['allowMergeUserIds'] = self.allow_merge_user_ids
        if self.allow_push_roles is not None:
            result['allowPushRoles'] = self.allow_push_roles
        if self.allow_push_user_ids is not None:
            result['allowPushUserIds'] = self.allow_push_user_ids
        if self.branch is not None:
            result['branch'] = self.branch
        if self.id is not None:
            result['id'] = self.id
        if self.merge_request_setting is not None:
            result['mergeRequestSetting'] = self.merge_request_setting.to_map()
        if self.test_setting_dto is not None:
            result['testSettingDTO'] = self.test_setting_dto.to_map()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('allowMergeRoles') is not None:
            self.allow_merge_roles = m.get('allowMergeRoles')
        if m.get('allowMergeUserIds') is not None:
            self.allow_merge_user_ids = m.get('allowMergeUserIds')
        if m.get('allowPushRoles') is not None:
            self.allow_push_roles = m.get('allowPushRoles')
        if m.get('allowPushUserIds') is not None:
            self.allow_push_user_ids = m.get('allowPushUserIds')
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mergeRequestSetting') is not None:
            temp_model = UpdateProtectedBranchesRequestMergeRequestSetting()
            self.merge_request_setting = temp_model.from_map(m['mergeRequestSetting'])
        if m.get('testSettingDTO') is not None:
            temp_model = UpdateProtectedBranchesRequestTestSettingDTO()
            self.test_setting_dto = temp_model.from_map(m['testSettingDTO'])
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateProtectedBranchesResponseBodyResultMergeRequestSetting(TeaModel):
    def __init__(
        self,
        allow_merge_request_roles: List[int] = None,
        default_assignees: List[str] = None,
        is_allow_self_approval: bool = None,
        is_require_discussion_processed: bool = None,
        is_required: bool = None,
        is_reset_approval_when_new_push: bool = None,
        minimum_approval: int = None,
        mr_mode: str = None,
        white_list: str = None,
    ):
        self.allow_merge_request_roles = allow_merge_request_roles
        self.default_assignees = default_assignees
        self.is_allow_self_approval = is_allow_self_approval
        self.is_require_discussion_processed = is_require_discussion_processed
        self.is_required = is_required
        self.is_reset_approval_when_new_push = is_reset_approval_when_new_push
        self.minimum_approval = minimum_approval
        self.mr_mode = mr_mode
        self.white_list = white_list

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_request_roles is not None:
            result['allowMergeRequestRoles'] = self.allow_merge_request_roles
        if self.default_assignees is not None:
            result['defaultAssignees'] = self.default_assignees
        if self.is_allow_self_approval is not None:
            result['isAllowSelfApproval'] = self.is_allow_self_approval
        if self.is_require_discussion_processed is not None:
            result['isRequireDiscussionProcessed'] = self.is_require_discussion_processed
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.is_reset_approval_when_new_push is not None:
            result['isResetApprovalWhenNewPush'] = self.is_reset_approval_when_new_push
        if self.minimum_approval is not None:
            result['minimumApproval'] = self.minimum_approval
        if self.mr_mode is not None:
            result['mrMode'] = self.mr_mode
        if self.white_list is not None:
            result['whiteList'] = self.white_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRequestRoles') is not None:
            self.allow_merge_request_roles = m.get('allowMergeRequestRoles')
        if m.get('defaultAssignees') is not None:
            self.default_assignees = m.get('defaultAssignees')
        if m.get('isAllowSelfApproval') is not None:
            self.is_allow_self_approval = m.get('isAllowSelfApproval')
        if m.get('isRequireDiscussionProcessed') is not None:
            self.is_require_discussion_processed = m.get('isRequireDiscussionProcessed')
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('isResetApprovalWhenNewPush') is not None:
            self.is_reset_approval_when_new_push = m.get('isResetApprovalWhenNewPush')
        if m.get('minimumApproval') is not None:
            self.minimum_approval = m.get('minimumApproval')
        if m.get('mrMode') is not None:
            self.mr_mode = m.get('mrMode')
        if m.get('whiteList') is not None:
            self.white_list = m.get('whiteList')
        return self


class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems(TeaModel):
    def __init__(
        self,
        is_required: bool = None,
        name: str = None,
    ):
        self.is_required = is_required
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig(TeaModel):
    def __init__(
        self,
        check_items: List[UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems] = None,
    ):
        self.check_items = check_items

    def validate(self):
        if self.check_items:
            for k in self.check_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['checkItems'] = []
        if self.check_items is not None:
            for k in self.check_items:
                result['checkItems'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.check_items = []
        if m.get('checkItems') is not None:
            for k in m.get('checkItems'):
                temp_model = UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfigCheckItems()
                self.check_items.append(temp_model.from_map(k))
        return self


class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig(TeaModel):
    def __init__(
        self,
        biz_no: str = None,
        enabled: bool = None,
        message: str = None,
        task_name: str = None,
    ):
        self.biz_no = biz_no
        self.enabled = enabled
        self.message = message
        self.task_name = task_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_no is not None:
            result['bizNo'] = self.biz_no
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        if self.task_name is not None:
            result['taskName'] = self.task_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('bizNo') is not None:
            self.biz_no = m.get('bizNo')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('taskName') is not None:
            self.task_name = m.get('taskName')
        return self


class UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection(TeaModel):
    def __init__(
        self,
        enabled: bool = None,
        message: str = None,
    ):
        self.enabled = enabled
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class UpdateProtectedBranchesResponseBodyResultTestSettingDTO(TeaModel):
    def __init__(
        self,
        check_config: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig = None,
        check_task_quality_config: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig = None,
        code_guidelines_detection: UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection = None,
        is_required: bool = None,
        sensitive_info_detection: UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection = None,
    ):
        self.check_config = check_config
        self.check_task_quality_config = check_task_quality_config
        self.code_guidelines_detection = code_guidelines_detection
        self.is_required = is_required
        self.sensitive_info_detection = sensitive_info_detection

    def validate(self):
        if self.check_config:
            self.check_config.validate()
        if self.check_task_quality_config:
            self.check_task_quality_config.validate()
        if self.code_guidelines_detection:
            self.code_guidelines_detection.validate()
        if self.sensitive_info_detection:
            self.sensitive_info_detection.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.check_config is not None:
            result['checkConfig'] = self.check_config.to_map()
        if self.check_task_quality_config is not None:
            result['checkTaskQualityConfig'] = self.check_task_quality_config.to_map()
        if self.code_guidelines_detection is not None:
            result['codeGuidelinesDetection'] = self.code_guidelines_detection.to_map()
        if self.is_required is not None:
            result['isRequired'] = self.is_required
        if self.sensitive_info_detection is not None:
            result['sensitiveInfoDetection'] = self.sensitive_info_detection.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkConfig') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckConfig()
            self.check_config = temp_model.from_map(m['checkConfig'])
        if m.get('checkTaskQualityConfig') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResultTestSettingDTOCheckTaskQualityConfig()
            self.check_task_quality_config = temp_model.from_map(m['checkTaskQualityConfig'])
        if m.get('codeGuidelinesDetection') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResultTestSettingDTOCodeGuidelinesDetection()
            self.code_guidelines_detection = temp_model.from_map(m['codeGuidelinesDetection'])
        if m.get('isRequired') is not None:
            self.is_required = m.get('isRequired')
        if m.get('sensitiveInfoDetection') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResultTestSettingDTOSensitiveInfoDetection()
            self.sensitive_info_detection = temp_model.from_map(m['sensitiveInfoDetection'])
        return self


class UpdateProtectedBranchesResponseBodyResult(TeaModel):
    def __init__(
        self,
        allow_merge_roles: List[int] = None,
        allow_merge_user_ids: List[int] = None,
        allow_push_roles: List[int] = None,
        allow_push_user_ids: List[int] = None,
        branch: str = None,
        id: int = None,
        merge_request_setting: UpdateProtectedBranchesResponseBodyResultMergeRequestSetting = None,
        test_setting_dto: UpdateProtectedBranchesResponseBodyResultTestSettingDTO = None,
    ):
        self.allow_merge_roles = allow_merge_roles
        self.allow_merge_user_ids = allow_merge_user_ids
        self.allow_push_roles = allow_push_roles
        self.allow_push_user_ids = allow_push_user_ids
        self.branch = branch
        self.id = id
        self.merge_request_setting = merge_request_setting
        self.test_setting_dto = test_setting_dto

    def validate(self):
        if self.merge_request_setting:
            self.merge_request_setting.validate()
        if self.test_setting_dto:
            self.test_setting_dto.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_merge_roles is not None:
            result['allowMergeRoles'] = self.allow_merge_roles
        if self.allow_merge_user_ids is not None:
            result['allowMergeUserIds'] = self.allow_merge_user_ids
        if self.allow_push_roles is not None:
            result['allowPushRoles'] = self.allow_push_roles
        if self.allow_push_user_ids is not None:
            result['allowPushUserIds'] = self.allow_push_user_ids
        if self.branch is not None:
            result['branch'] = self.branch
        if self.id is not None:
            result['id'] = self.id
        if self.merge_request_setting is not None:
            result['mergeRequestSetting'] = self.merge_request_setting.to_map()
        if self.test_setting_dto is not None:
            result['testSettingDTO'] = self.test_setting_dto.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowMergeRoles') is not None:
            self.allow_merge_roles = m.get('allowMergeRoles')
        if m.get('allowMergeUserIds') is not None:
            self.allow_merge_user_ids = m.get('allowMergeUserIds')
        if m.get('allowPushRoles') is not None:
            self.allow_push_roles = m.get('allowPushRoles')
        if m.get('allowPushUserIds') is not None:
            self.allow_push_user_ids = m.get('allowPushUserIds')
        if m.get('branch') is not None:
            self.branch = m.get('branch')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mergeRequestSetting') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResultMergeRequestSetting()
            self.merge_request_setting = temp_model.from_map(m['mergeRequestSetting'])
        if m.get('testSettingDTO') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResultTestSettingDTO()
            self.test_setting_dto = temp_model.from_map(m['testSettingDTO'])
        return self


class UpdateProtectedBranchesResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateProtectedBranchesResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateProtectedBranchesResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateProtectedBranchesResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateProtectedBranchesResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateProtectedBranchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePushReviewOnOffRequest(TeaModel):
    def __init__(
        self,
        organization_id: str = None,
        trunk_mode: bool = None,
    ):
        # This parameter is required.
        self.organization_id = organization_id
        # This parameter is required.
        self.trunk_mode = trunk_mode

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        if self.trunk_mode is not None:
            result['trunkMode'] = self.trunk_mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        if m.get('trunkMode') is not None:
            self.trunk_mode = m.get('trunkMode')
        return self


class UpdatePushReviewOnOffResponseBodyResult(TeaModel):
    def __init__(
        self,
        result: bool = None,
    ):
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdatePushReviewOnOffResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdatePushReviewOnOffResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdatePushReviewOnOffResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdatePushReviewOnOffResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePushReviewOnOffResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePushReviewOnOffResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePushRuleRequestRuleInfos(TeaModel):
    def __init__(
        self,
        checker_name: str = None,
        checker_type: str = None,
        extra_message: str = None,
        file_rule_regexes: List[str] = None,
    ):
        self.checker_name = checker_name
        self.checker_type = checker_type
        self.extra_message = extra_message
        self.file_rule_regexes = file_rule_regexes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checker_name is not None:
            result['checkerName'] = self.checker_name
        if self.checker_type is not None:
            result['checkerType'] = self.checker_type
        if self.extra_message is not None:
            result['extraMessage'] = self.extra_message
        if self.file_rule_regexes is not None:
            result['fileRuleRegexes'] = self.file_rule_regexes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkerName') is not None:
            self.checker_name = m.get('checkerName')
        if m.get('checkerType') is not None:
            self.checker_type = m.get('checkerType')
        if m.get('extraMessage') is not None:
            self.extra_message = m.get('extraMessage')
        if m.get('fileRuleRegexes') is not None:
            self.file_rule_regexes = m.get('fileRuleRegexes')
        return self


class UpdatePushRuleRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        rule_infos: List[UpdatePushRuleRequestRuleInfos] = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.rule_infos = rule_infos
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.rule_infos:
            for k in self.rule_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        result['ruleInfos'] = []
        if self.rule_infos is not None:
            for k in self.rule_infos:
                result['ruleInfos'].append(k.to_map() if k else None)
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        self.rule_infos = []
        if m.get('ruleInfos') is not None:
            for k in m.get('ruleInfos'):
                temp_model = UpdatePushRuleRequestRuleInfos()
                self.rule_infos.append(temp_model.from_map(k))
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdatePushRuleResponseBodyResultRuleInfos(TeaModel):
    def __init__(
        self,
        checker_name: str = None,
        checker_type: str = None,
        extra_message: str = None,
        file_rule_regexes: List[str] = None,
    ):
        self.checker_name = checker_name
        self.checker_type = checker_type
        self.extra_message = extra_message
        self.file_rule_regexes = file_rule_regexes

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.checker_name is not None:
            result['checkerName'] = self.checker_name
        if self.checker_type is not None:
            result['checkerType'] = self.checker_type
        if self.extra_message is not None:
            result['extraMessage'] = self.extra_message
        if self.file_rule_regexes is not None:
            result['fileRuleRegexes'] = self.file_rule_regexes
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('checkerName') is not None:
            self.checker_name = m.get('checkerName')
        if m.get('checkerType') is not None:
            self.checker_type = m.get('checkerType')
        if m.get('extraMessage') is not None:
            self.extra_message = m.get('extraMessage')
        if m.get('fileRuleRegexes') is not None:
            self.file_rule_regexes = m.get('fileRuleRegexes')
        return self


class UpdatePushRuleResponseBodyResult(TeaModel):
    def __init__(
        self,
        gmt_create: str = None,
        gmt_modified: str = None,
        id: int = None,
        rule_infos: List[UpdatePushRuleResponseBodyResultRuleInfos] = None,
    ):
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.id = id
        self.rule_infos = rule_infos

    def validate(self):
        if self.rule_infos:
            for k in self.rule_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.id is not None:
            result['id'] = self.id
        result['ruleInfos'] = []
        if self.rule_infos is not None:
            for k in self.rule_infos:
                result['ruleInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('id') is not None:
            self.id = m.get('id')
        self.rule_infos = []
        if m.get('ruleInfos') is not None:
            for k in m.get('ruleInfos'):
                temp_model = UpdatePushRuleResponseBodyResultRuleInfos()
                self.rule_infos.append(temp_model.from_map(k))
        return self


class UpdatePushRuleResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdatePushRuleResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdatePushRuleResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdatePushRuleResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdatePushRuleResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePushRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRepositoryRequestProjectCloneDownloadMethodList(TeaModel):
    def __init__(
        self,
        allowed: bool = None,
        permission_code: str = None,
    ):
        self.allowed = allowed
        self.permission_code = permission_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allowed is not None:
            result['allowed'] = self.allowed
        if self.permission_code is not None:
            result['permissionCode'] = self.permission_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowed') is not None:
            self.allowed = m.get('allowed')
        if m.get('permissionCode') is not None:
            self.permission_code = m.get('permissionCode')
        return self


class UpdateRepositoryRequestProjectCloneDownloadRoleList(TeaModel):
    def __init__(
        self,
        allowed: bool = None,
        role_code: int = None,
    ):
        self.allowed = allowed
        self.role_code = role_code

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allowed is not None:
            result['allowed'] = self.allowed
        if self.role_code is not None:
            result['roleCode'] = self.role_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('allowed') is not None:
            self.allowed = m.get('allowed')
        if m.get('roleCode') is not None:
            self.role_code = m.get('roleCode')
        return self


class UpdateRepositoryRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        admin_setting_language: str = None,
        avatar: str = None,
        builds_enabled: bool = None,
        check_email: bool = None,
        default_branch: str = None,
        description: str = None,
        id: int = None,
        issues_enabled: bool = None,
        merge_requests_enabled: bool = None,
        name: str = None,
        open_clone_download_control: bool = None,
        path: str = None,
        project_clone_download_method_list: List[UpdateRepositoryRequestProjectCloneDownloadMethodList] = None,
        project_clone_download_role_list: List[UpdateRepositoryRequestProjectCloneDownloadRoleList] = None,
        snippets_enabled: bool = None,
        visibility_level: int = None,
        wiki_enabled: bool = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.admin_setting_language = admin_setting_language
        self.avatar = avatar
        self.builds_enabled = builds_enabled
        self.check_email = check_email
        self.default_branch = default_branch
        self.description = description
        self.id = id
        self.issues_enabled = issues_enabled
        self.merge_requests_enabled = merge_requests_enabled
        self.name = name
        self.open_clone_download_control = open_clone_download_control
        self.path = path
        self.project_clone_download_method_list = project_clone_download_method_list
        self.project_clone_download_role_list = project_clone_download_role_list
        self.snippets_enabled = snippets_enabled
        self.visibility_level = visibility_level
        self.wiki_enabled = wiki_enabled
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.project_clone_download_method_list:
            for k in self.project_clone_download_method_list:
                if k:
                    k.validate()
        if self.project_clone_download_role_list:
            for k in self.project_clone_download_role_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.admin_setting_language is not None:
            result['adminSettingLanguage'] = self.admin_setting_language
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.builds_enabled is not None:
            result['buildsEnabled'] = self.builds_enabled
        if self.check_email is not None:
            result['checkEmail'] = self.check_email
        if self.default_branch is not None:
            result['defaultBranch'] = self.default_branch
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.issues_enabled is not None:
            result['issuesEnabled'] = self.issues_enabled
        if self.merge_requests_enabled is not None:
            result['mergeRequestsEnabled'] = self.merge_requests_enabled
        if self.name is not None:
            result['name'] = self.name
        if self.open_clone_download_control is not None:
            result['openCloneDownloadControl'] = self.open_clone_download_control
        if self.path is not None:
            result['path'] = self.path
        result['projectCloneDownloadMethodList'] = []
        if self.project_clone_download_method_list is not None:
            for k in self.project_clone_download_method_list:
                result['projectCloneDownloadMethodList'].append(k.to_map() if k else None)
        result['projectCloneDownloadRoleList'] = []
        if self.project_clone_download_role_list is not None:
            for k in self.project_clone_download_role_list:
                result['projectCloneDownloadRoleList'].append(k.to_map() if k else None)
        if self.snippets_enabled is not None:
            result['snippetsEnabled'] = self.snippets_enabled
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.wiki_enabled is not None:
            result['wikiEnabled'] = self.wiki_enabled
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('adminSettingLanguage') is not None:
            self.admin_setting_language = m.get('adminSettingLanguage')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('buildsEnabled') is not None:
            self.builds_enabled = m.get('buildsEnabled')
        if m.get('checkEmail') is not None:
            self.check_email = m.get('checkEmail')
        if m.get('defaultBranch') is not None:
            self.default_branch = m.get('defaultBranch')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('issuesEnabled') is not None:
            self.issues_enabled = m.get('issuesEnabled')
        if m.get('mergeRequestsEnabled') is not None:
            self.merge_requests_enabled = m.get('mergeRequestsEnabled')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('openCloneDownloadControl') is not None:
            self.open_clone_download_control = m.get('openCloneDownloadControl')
        if m.get('path') is not None:
            self.path = m.get('path')
        self.project_clone_download_method_list = []
        if m.get('projectCloneDownloadMethodList') is not None:
            for k in m.get('projectCloneDownloadMethodList'):
                temp_model = UpdateRepositoryRequestProjectCloneDownloadMethodList()
                self.project_clone_download_method_list.append(temp_model.from_map(k))
        self.project_clone_download_role_list = []
        if m.get('projectCloneDownloadRoleList') is not None:
            for k in m.get('projectCloneDownloadRoleList'):
                temp_model = UpdateRepositoryRequestProjectCloneDownloadRoleList()
                self.project_clone_download_role_list.append(temp_model.from_map(k))
        if m.get('snippetsEnabled') is not None:
            self.snippets_enabled = m.get('snippetsEnabled')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('wikiEnabled') is not None:
            self.wiki_enabled = m.get('wikiEnabled')
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateRepositoryResponseBodyResultNamespace(TeaModel):
    def __init__(
        self,
        avatar: str = None,
        created_at: str = None,
        description: str = None,
        id: int = None,
        name: str = None,
        owner_id: int = None,
        path: str = None,
        updated_at: str = None,
        visibility_level: int = None,
    ):
        self.avatar = avatar
        self.created_at = created_at
        self.description = description
        self.id = id
        self.name = name
        self.owner_id = owner_id
        self.path = path
        self.updated_at = updated_at
        self.visibility_level = visibility_level

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.owner_id is not None:
            result['ownerId'] = self.owner_id
        if self.path is not None:
            result['path'] = self.path
        if self.updated_at is not None:
            result['updatedAt'] = self.updated_at
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ownerId') is not None:
            self.owner_id = m.get('ownerId')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('updatedAt') is not None:
            self.updated_at = m.get('updatedAt')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        return self


class UpdateRepositoryResponseBodyResult(TeaModel):
    def __init__(
        self,
        archived: bool = None,
        avatar_url: str = None,
        builds_enabled: bool = None,
        created_at: str = None,
        creator_id: int = None,
        default_branch: str = None,
        description: str = None,
        http_url_to_repo: str = None,
        id: int = None,
        issues_enabled: bool = None,
        last_activity_at: str = None,
        merge_requests_enabled: bool = None,
        name: str = None,
        name_with_namespace: str = None,
        namespace: UpdateRepositoryResponseBodyResultNamespace = None,
        path: str = None,
        path_with_namespace: str = None,
        snippets_enabled: bool = None,
        ssh_url_to_repo: str = None,
        visibility_level: int = None,
        web_url: str = None,
        wiki_enabled: bool = None,
    ):
        self.archived = archived
        self.avatar_url = avatar_url
        self.builds_enabled = builds_enabled
        self.created_at = created_at
        self.creator_id = creator_id
        self.default_branch = default_branch
        self.description = description
        self.http_url_to_repo = http_url_to_repo
        self.id = id
        self.issues_enabled = issues_enabled
        self.last_activity_at = last_activity_at
        self.merge_requests_enabled = merge_requests_enabled
        self.name = name
        self.name_with_namespace = name_with_namespace
        self.namespace = namespace
        self.path = path
        self.path_with_namespace = path_with_namespace
        self.snippets_enabled = snippets_enabled
        self.ssh_url_to_repo = ssh_url_to_repo
        self.visibility_level = visibility_level
        self.web_url = web_url
        self.wiki_enabled = wiki_enabled

    def validate(self):
        if self.namespace:
            self.namespace.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.archived is not None:
            result['archived'] = self.archived
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.builds_enabled is not None:
            result['buildsEnabled'] = self.builds_enabled
        if self.created_at is not None:
            result['createdAt'] = self.created_at
        if self.creator_id is not None:
            result['creatorId'] = self.creator_id
        if self.default_branch is not None:
            result['defaultBranch'] = self.default_branch
        if self.description is not None:
            result['description'] = self.description
        if self.http_url_to_repo is not None:
            result['httpUrlToRepo'] = self.http_url_to_repo
        if self.id is not None:
            result['id'] = self.id
        if self.issues_enabled is not None:
            result['issuesEnabled'] = self.issues_enabled
        if self.last_activity_at is not None:
            result['lastActivityAt'] = self.last_activity_at
        if self.merge_requests_enabled is not None:
            result['mergeRequestsEnabled'] = self.merge_requests_enabled
        if self.name is not None:
            result['name'] = self.name
        if self.name_with_namespace is not None:
            result['nameWithNamespace'] = self.name_with_namespace
        if self.namespace is not None:
            result['namespace'] = self.namespace.to_map()
        if self.path is not None:
            result['path'] = self.path
        if self.path_with_namespace is not None:
            result['pathWithNamespace'] = self.path_with_namespace
        if self.snippets_enabled is not None:
            result['snippetsEnabled'] = self.snippets_enabled
        if self.ssh_url_to_repo is not None:
            result['sshUrlToRepo'] = self.ssh_url_to_repo
        if self.visibility_level is not None:
            result['visibilityLevel'] = self.visibility_level
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        if self.wiki_enabled is not None:
            result['wikiEnabled'] = self.wiki_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('archived') is not None:
            self.archived = m.get('archived')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('buildsEnabled') is not None:
            self.builds_enabled = m.get('buildsEnabled')
        if m.get('createdAt') is not None:
            self.created_at = m.get('createdAt')
        if m.get('creatorId') is not None:
            self.creator_id = m.get('creatorId')
        if m.get('defaultBranch') is not None:
            self.default_branch = m.get('defaultBranch')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('httpUrlToRepo') is not None:
            self.http_url_to_repo = m.get('httpUrlToRepo')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('issuesEnabled') is not None:
            self.issues_enabled = m.get('issuesEnabled')
        if m.get('lastActivityAt') is not None:
            self.last_activity_at = m.get('lastActivityAt')
        if m.get('mergeRequestsEnabled') is not None:
            self.merge_requests_enabled = m.get('mergeRequestsEnabled')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('nameWithNamespace') is not None:
            self.name_with_namespace = m.get('nameWithNamespace')
        if m.get('namespace') is not None:
            temp_model = UpdateRepositoryResponseBodyResultNamespace()
            self.namespace = temp_model.from_map(m['namespace'])
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('pathWithNamespace') is not None:
            self.path_with_namespace = m.get('pathWithNamespace')
        if m.get('snippetsEnabled') is not None:
            self.snippets_enabled = m.get('snippetsEnabled')
        if m.get('sshUrlToRepo') is not None:
            self.ssh_url_to_repo = m.get('sshUrlToRepo')
        if m.get('visibilityLevel') is not None:
            self.visibility_level = m.get('visibilityLevel')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        if m.get('wikiEnabled') is not None:
            self.wiki_enabled = m.get('wikiEnabled')
        return self


class UpdateRepositoryResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateRepositoryResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateRepositoryResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateRepositoryResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRepositoryResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRepositoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateRepositoryMemberRequestRelatedInfos(TeaModel):
    def __init__(
        self,
        related_id: str = None,
        source_id: int = None,
        source_type: str = None,
    ):
        self.related_id = related_id
        self.source_id = source_id
        self.source_type = source_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.related_id is not None:
            result['relatedId'] = self.related_id
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('relatedId') is not None:
            self.related_id = m.get('relatedId')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        return self


class UpdateRepositoryMemberRequest(TeaModel):
    def __init__(
        self,
        access_token: str = None,
        access_level: int = None,
        expire_at: str = None,
        member_type: str = None,
        related_id: str = None,
        related_infos: List[UpdateRepositoryMemberRequestRelatedInfos] = None,
        organization_id: str = None,
    ):
        self.access_token = access_token
        self.access_level = access_level
        self.expire_at = expire_at
        self.member_type = member_type
        self.related_id = related_id
        self.related_infos = related_infos
        # This parameter is required.
        self.organization_id = organization_id

    def validate(self):
        if self.related_infos:
            for k in self.related_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_token is not None:
            result['accessToken'] = self.access_token
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.expire_at is not None:
            result['expireAt'] = self.expire_at
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.related_id is not None:
            result['relatedId'] = self.related_id
        result['relatedInfos'] = []
        if self.related_infos is not None:
            for k in self.related_infos:
                result['relatedInfos'].append(k.to_map() if k else None)
        if self.organization_id is not None:
            result['organizationId'] = self.organization_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessToken') is not None:
            self.access_token = m.get('accessToken')
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('expireAt') is not None:
            self.expire_at = m.get('expireAt')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('relatedId') is not None:
            self.related_id = m.get('relatedId')
        self.related_infos = []
        if m.get('relatedInfos') is not None:
            for k in m.get('relatedInfos'):
                temp_model = UpdateRepositoryMemberRequestRelatedInfos()
                self.related_infos.append(temp_model.from_map(k))
        if m.get('organizationId') is not None:
            self.organization_id = m.get('organizationId')
        return self


class UpdateRepositoryMemberResponseBodyResult(TeaModel):
    def __init__(
        self,
        access_level: int = None,
        avatar_url: str = None,
        email: str = None,
        expire_at: str = None,
        id: int = None,
        member_name: str = None,
        member_type: str = None,
        name: str = None,
        source_id: int = None,
        source_type: str = None,
        state: str = None,
        username: str = None,
        web_url: str = None,
    ):
        self.access_level = access_level
        self.avatar_url = avatar_url
        self.email = email
        self.expire_at = expire_at
        self.id = id
        self.member_name = member_name
        self.member_type = member_type
        self.name = name
        self.source_id = source_id
        self.source_type = source_type
        self.state = state
        self.username = username
        # web url
        self.web_url = web_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_level is not None:
            result['accessLevel'] = self.access_level
        if self.avatar_url is not None:
            result['avatarUrl'] = self.avatar_url
        if self.email is not None:
            result['email'] = self.email
        if self.expire_at is not None:
            result['expireAt'] = self.expire_at
        if self.id is not None:
            result['id'] = self.id
        if self.member_name is not None:
            result['memberName'] = self.member_name
        if self.member_type is not None:
            result['memberType'] = self.member_type
        if self.name is not None:
            result['name'] = self.name
        if self.source_id is not None:
            result['sourceId'] = self.source_id
        if self.source_type is not None:
            result['sourceType'] = self.source_type
        if self.state is not None:
            result['state'] = self.state
        if self.username is not None:
            result['username'] = self.username
        if self.web_url is not None:
            result['webUrl'] = self.web_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessLevel') is not None:
            self.access_level = m.get('accessLevel')
        if m.get('avatarUrl') is not None:
            self.avatar_url = m.get('avatarUrl')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('expireAt') is not None:
            self.expire_at = m.get('expireAt')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('memberName') is not None:
            self.member_name = m.get('memberName')
        if m.get('memberType') is not None:
            self.member_type = m.get('memberType')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('sourceId') is not None:
            self.source_id = m.get('sourceId')
        if m.get('sourceType') is not None:
            self.source_type = m.get('sourceType')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('webUrl') is not None:
            self.web_url = m.get('webUrl')
        return self


class UpdateRepositoryMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        result: UpdateRepositoryMemberResponseBodyResult = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.result = result
        self.success = success

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.result is not None:
            result['result'] = self.result.to_map()
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('result') is not None:
            temp_model = UpdateRepositoryMemberResponseBodyResult()
            self.result = temp_model.from_map(m['result'])
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateRepositoryMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateRepositoryMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateRepositoryMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateResourceMemberRequest(TeaModel):
    def __init__(
        self,
        role_name: str = None,
    ):
        # This parameter is required.
        self.role_name = role_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.role_name is not None:
            result['roleName'] = self.role_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('roleName') is not None:
            self.role_name = m.get('roleName')
        return self


class UpdateResourceMemberResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateResourceMemberResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateResourceMemberResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateResourceMemberResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTestCaseRequestUpdateWorkitemPropertyRequest(TeaModel):
    def __init__(
        self,
        field_identifier: str = None,
        field_value: str = None,
    ):
        # This parameter is required.
        self.field_identifier = field_identifier
        # This parameter is required.
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class UpdateTestCaseRequest(TeaModel):
    def __init__(
        self,
        update_workitem_property_request: List[UpdateTestCaseRequestUpdateWorkitemPropertyRequest] = None,
    ):
        # This parameter is required.
        self.update_workitem_property_request = update_workitem_property_request

    def validate(self):
        if self.update_workitem_property_request:
            for k in self.update_workitem_property_request:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['updateWorkitemPropertyRequest'] = []
        if self.update_workitem_property_request is not None:
            for k in self.update_workitem_property_request:
                result['updateWorkitemPropertyRequest'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.update_workitem_property_request = []
        if m.get('updateWorkitemPropertyRequest') is not None:
            for k in m.get('updateWorkitemPropertyRequest'):
                temp_model = UpdateTestCaseRequestUpdateWorkitemPropertyRequest()
                self.update_workitem_property_request.append(temp_model.from_map(k))
        return self


class UpdateTestCaseResponseBodyTestcaseAssignedTo(TeaModel):
    def __init__(
        self,
        assign_identifier: str = None,
        name: str = None,
        tb_role_id: str = None,
    ):
        self.assign_identifier = assign_identifier
        self.name = name
        self.tb_role_id = tb_role_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assign_identifier is not None:
            result['assignIdentifier'] = self.assign_identifier
        if self.name is not None:
            result['name'] = self.name
        if self.tb_role_id is not None:
            result['tbRoleId'] = self.tb_role_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignIdentifier') is not None:
            self.assign_identifier = m.get('assignIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tbRoleId') is not None:
            self.tb_role_id = m.get('tbRoleId')
        return self


class UpdateTestCaseResponseBodyTestcaseCreator(TeaModel):
    def __init__(
        self,
        create_identifier: str = None,
        name: str = None,
    ):
        self.create_identifier = create_identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_identifier is not None:
            result['createIdentifier'] = self.create_identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('createIdentifier') is not None:
            self.create_identifier = m.get('createIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult(TeaModel):
    def __init__(
        self,
        expect_content: str = None,
        expect_content_type: str = None,
        expect_identifier: str = None,
    ):
        self.expect_content = expect_content
        self.expect_content_type = expect_content_type
        self.expect_identifier = expect_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect_content is not None:
            result['expectContent'] = self.expect_content
        if self.expect_content_type is not None:
            result['expectContentType'] = self.expect_content_type
        if self.expect_identifier is not None:
            result['expectIdentifier'] = self.expect_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expectContent') is not None:
            self.expect_content = m.get('expectContent')
        if m.get('expectContentType') is not None:
            self.expect_content_type = m.get('expectContentType')
        if m.get('expectIdentifier') is not None:
            self.expect_identifier = m.get('expectIdentifier')
        return self


class UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition(TeaModel):
    def __init__(
        self,
        pre_content: str = None,
        pre_content_type: str = None,
        pre_identifier: str = None,
    ):
        self.pre_content = pre_content
        self.pre_content_type = pre_content_type
        self.pre_identifier = pre_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_content is not None:
            result['preContent'] = self.pre_content
        if self.pre_content_type is not None:
            result['preContentType'] = self.pre_content_type
        if self.pre_identifier is not None:
            result['preIdentifier'] = self.pre_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('preContent') is not None:
            self.pre_content = m.get('preContent')
        if m.get('preContentType') is not None:
            self.pre_content_type = m.get('preContentType')
        if m.get('preIdentifier') is not None:
            self.pre_identifier = m.get('preIdentifier')
        return self


class UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent(TeaModel):
    def __init__(
        self,
        step_content: str = None,
        step_content_type: str = None,
        step_identifier: str = None,
    ):
        self.step_content = step_content
        self.step_content_type = step_content_type
        self.step_identifier = step_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.step_content is not None:
            result['stepContent'] = self.step_content
        if self.step_content_type is not None:
            result['stepContentType'] = self.step_content_type
        if self.step_identifier is not None:
            result['stepIdentifier'] = self.step_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('stepContent') is not None:
            self.step_content = m.get('stepContent')
        if m.get('stepContentType') is not None:
            self.step_content_type = m.get('stepContentType')
        if m.get('stepIdentifier') is not None:
            self.step_identifier = m.get('stepIdentifier')
        return self


class UpdateTestCaseResponseBodyTestcaseDetailInfo(TeaModel):
    def __init__(
        self,
        expected_result: UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult = None,
        precondition: UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition = None,
        step_content: UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent = None,
        step_type: str = None,
    ):
        self.expected_result = expected_result
        self.precondition = precondition
        self.step_content = step_content
        self.step_type = step_type

    def validate(self):
        if self.expected_result:
            self.expected_result.validate()
        if self.precondition:
            self.precondition.validate()
        if self.step_content:
            self.step_content.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expected_result is not None:
            result['expectedResult'] = self.expected_result.to_map()
        if self.precondition is not None:
            result['precondition'] = self.precondition.to_map()
        if self.step_content is not None:
            result['stepContent'] = self.step_content.to_map()
        if self.step_type is not None:
            result['stepType'] = self.step_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expectedResult') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseDetailInfoExpectedResult()
            self.expected_result = temp_model.from_map(m['expectedResult'])
        if m.get('precondition') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseDetailInfoPrecondition()
            self.precondition = temp_model.from_map(m['precondition'])
        if m.get('stepContent') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseDetailInfoStepContent()
            self.step_content = temp_model.from_map(m['stepContent'])
        if m.get('stepType') is not None:
            self.step_type = m.get('stepType')
        return self


class UpdateTestCaseResponseBodyTestcaseDirectory(TeaModel):
    def __init__(
        self,
        child_identifier: str = None,
        directory_identifier: str = None,
        name: str = None,
        path_name: List[str] = None,
    ):
        self.child_identifier = child_identifier
        self.directory_identifier = directory_identifier
        self.name = name
        self.path_name = path_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.child_identifier is not None:
            result['childIdentifier'] = self.child_identifier
        if self.directory_identifier is not None:
            result['directoryIdentifier'] = self.directory_identifier
        if self.name is not None:
            result['name'] = self.name
        if self.path_name is not None:
            result['pathName'] = self.path_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('childIdentifier') is not None:
            self.child_identifier = m.get('childIdentifier')
        if m.get('directoryIdentifier') is not None:
            self.directory_identifier = m.get('directoryIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pathName') is not None:
            self.path_name = m.get('pathName')
        return self


class UpdateTestCaseResponseBodyTestcaseModifier(TeaModel):
    def __init__(
        self,
        modify_identifier: str = None,
        name: str = None,
    ):
        self.modify_identifier = modify_identifier
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.modify_identifier is not None:
            result['modifyIdentifier'] = self.modify_identifier
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('modifyIdentifier') is not None:
            self.modify_identifier = m.get('modifyIdentifier')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateTestCaseResponseBodyTestcase(TeaModel):
    def __init__(
        self,
        assigned_to: UpdateTestCaseResponseBodyTestcaseAssignedTo = None,
        category_identifier: str = None,
        creator: UpdateTestCaseResponseBodyTestcaseCreator = None,
        detail_info: UpdateTestCaseResponseBodyTestcaseDetailInfo = None,
        directory: UpdateTestCaseResponseBodyTestcaseDirectory = None,
        identifier: str = None,
        modifier: UpdateTestCaseResponseBodyTestcaseModifier = None,
        space_identifier: str = None,
        space_type: str = None,
        subject: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.detail_info = detail_info
        self.directory = directory
        self.identifier = identifier
        self.modifier = modifier
        self.space_identifier = space_identifier
        self.space_type = space_type
        self.subject = subject

    def validate(self):
        if self.assigned_to:
            self.assigned_to.validate()
        if self.creator:
            self.creator.validate()
        if self.detail_info:
            self.detail_info.validate()
        if self.directory:
            self.directory.validate()
        if self.modifier:
            self.modifier.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to.to_map()
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator.to_map()
        if self.detail_info is not None:
            result['detailInfo'] = self.detail_info.to_map()
        if self.directory is not None:
            result['directory'] = self.directory.to_map()
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.modifier is not None:
            result['modifier'] = self.modifier.to_map()
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.subject is not None:
            result['subject'] = self.subject
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseAssignedTo()
            self.assigned_to = temp_model.from_map(m['assignedTo'])
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseCreator()
            self.creator = temp_model.from_map(m['creator'])
        if m.get('detailInfo') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseDetailInfo()
            self.detail_info = temp_model.from_map(m['detailInfo'])
        if m.get('directory') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseDirectory()
            self.directory = temp_model.from_map(m['directory'])
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('modifier') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcaseModifier()
            self.modifier = temp_model.from_map(m['modifier'])
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        return self


class UpdateTestCaseResponseBody(TeaModel):
    def __init__(
        self,
        testcase: UpdateTestCaseResponseBodyTestcase = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.testcase = testcase
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.testcase:
            self.testcase.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.testcase is not None:
            result['Testcase'] = self.testcase.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('Testcase') is not None:
            temp_model = UpdateTestCaseResponseBodyTestcase()
            self.testcase = temp_model.from_map(m['Testcase'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateTestCaseResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTestCaseResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTestCaseResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTestResultRequest(TeaModel):
    def __init__(
        self,
        executor: str = None,
        status: str = None,
    ):
        self.executor = executor
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.executor is not None:
            result['executor'] = self.executor
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('executor') is not None:
            self.executor = m.get('executor')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateTestResultResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateTestResultResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateTestResultResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTestResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateVariableGroupRequest(TeaModel):
    def __init__(
        self,
        description: str = None,
        name: str = None,
        variables: str = None,
    ):
        self.description = description
        # This parameter is required.
        self.name = name
        # This parameter is required.
        self.variables = variables

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.variables is not None:
            result['variables'] = self.variables
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('variables') is not None:
            self.variables = m.get('variables')
        return self


class UpdateVariableGroupResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateVariableGroupResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateVariableGroupResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateVariableGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkItemRequest(TeaModel):
    def __init__(
        self,
        field_type: str = None,
        identifier: str = None,
        property_key: str = None,
        property_value: str = None,
    ):
        # This parameter is required.
        self.field_type = field_type
        # This parameter is required.
        self.identifier = identifier
        # This parameter is required.
        self.property_key = property_key
        # This parameter is required.
        self.property_value = property_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_type is not None:
            result['fieldType'] = self.field_type
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.property_key is not None:
            result['propertyKey'] = self.property_key
        if self.property_value is not None:
            result['propertyValue'] = self.property_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldType') is not None:
            self.field_type = m.get('fieldType')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('propertyKey') is not None:
            self.property_key = m.get('propertyKey')
        if m.get('propertyValue') is not None:
            self.property_value = m.get('propertyValue')
        return self


class UpdateWorkItemResponseBodyWorkitem(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category_identifier: str = None,
        creator: str = None,
        document: str = None,
        document_format: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        logical_status: str = None,
        modifier: str = None,
        parent_identifier: str = None,
        serial_number: str = None,
        space_identifier: str = None,
        space_name: str = None,
        space_type: str = None,
        sprint_identifier: str = None,
        status: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        subject: str = None,
        update_status_at: int = None,
        workitem_type_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.document = document
        self.document_format = document_format
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.logical_status = logical_status
        self.modifier = modifier
        self.parent_identifier = parent_identifier
        self.serial_number = serial_number
        self.space_identifier = space_identifier
        self.space_name = space_name
        self.space_type = space_type
        self.sprint_identifier = sprint_identifier
        self.status = status
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.subject = subject
        self.update_status_at = update_status_at
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.document is not None:
            result['document'] = self.document
        if self.document_format is not None:
            result['documentFormat'] = self.document_format
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_name is not None:
            result['spaceName'] = self.space_name
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.sprint_identifier is not None:
            result['sprintIdentifier'] = self.sprint_identifier
        if self.status is not None:
            result['status'] = self.status
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.update_status_at is not None:
            result['updateStatusAt'] = self.update_status_at
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('document') is not None:
            self.document = m.get('document')
        if m.get('documentFormat') is not None:
            self.document_format = m.get('documentFormat')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceName') is not None:
            self.space_name = m.get('spaceName')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('sprintIdentifier') is not None:
            self.sprint_identifier = m.get('sprintIdentifier')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('updateStatusAt') is not None:
            self.update_status_at = m.get('updateStatusAt')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class UpdateWorkItemResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: bool = None,
        workitem: UpdateWorkItemResponseBodyWorkitem = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success
        self.workitem = workitem

    def validate(self):
        if self.workitem:
            self.workitem.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workitem is not None:
            result['workitem'] = self.workitem.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workitem') is not None:
            temp_model = UpdateWorkItemResponseBodyWorkitem()
            self.workitem = temp_model.from_map(m['workitem'])
        return self


class UpdateWorkItemResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkItemResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkItemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkitemCommentRequest(TeaModel):
    def __init__(
        self,
        comment_id: int = None,
        content: str = None,
        format_type: str = None,
        workitem_identifier: str = None,
    ):
        # This parameter is required.
        self.comment_id = comment_id
        # This parameter is required.
        self.content = content
        # This parameter is required.
        self.format_type = format_type
        # This parameter is required.
        self.workitem_identifier = workitem_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment_id is not None:
            result['commentId'] = self.comment_id
        if self.content is not None:
            result['content'] = self.content
        if self.format_type is not None:
            result['formatType'] = self.format_type
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('commentId') is not None:
            self.comment_id = m.get('commentId')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('formatType') is not None:
            self.format_type = m.get('formatType')
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class UpdateWorkitemCommentResponseBodyCommentUser(TeaModel):
    def __init__(
        self,
        account: str = None,
        avatar: str = None,
        display_name: str = None,
        identifier: str = None,
        nick_name: str = None,
        real_name: str = None,
    ):
        self.account = account
        self.avatar = avatar
        self.display_name = display_name
        self.identifier = identifier
        self.nick_name = nick_name
        self.real_name = real_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account is not None:
            result['account'] = self.account
        if self.avatar is not None:
            result['avatar'] = self.avatar
        if self.display_name is not None:
            result['displayName'] = self.display_name
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.nick_name is not None:
            result['nickName'] = self.nick_name
        if self.real_name is not None:
            result['realName'] = self.real_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('account') is not None:
            self.account = m.get('account')
        if m.get('avatar') is not None:
            self.avatar = m.get('avatar')
        if m.get('displayName') is not None:
            self.display_name = m.get('displayName')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('nickName') is not None:
            self.nick_name = m.get('nickName')
        if m.get('realName') is not None:
            self.real_name = m.get('realName')
        return self


class UpdateWorkitemCommentResponseBodyComment(TeaModel):
    def __init__(
        self,
        content: str = None,
        create_time: int = None,
        format_type: str = None,
        id: str = None,
        is_top: bool = None,
        modified_time: int = None,
        parent_id: int = None,
        target_identifier: str = None,
        target_type: str = None,
        top_time: int = None,
        user: UpdateWorkitemCommentResponseBodyCommentUser = None,
    ):
        self.content = content
        self.create_time = create_time
        self.format_type = format_type
        self.id = id
        self.is_top = is_top
        self.modified_time = modified_time
        self.parent_id = parent_id
        self.target_identifier = target_identifier
        self.target_type = target_type
        self.top_time = top_time
        self.user = user

    def validate(self):
        if self.user:
            self.user.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['content'] = self.content
        if self.create_time is not None:
            result['createTime'] = self.create_time
        if self.format_type is not None:
            result['formatType'] = self.format_type
        if self.id is not None:
            result['id'] = self.id
        if self.is_top is not None:
            result['isTop'] = self.is_top
        if self.modified_time is not None:
            result['modifiedTime'] = self.modified_time
        if self.parent_id is not None:
            result['parentId'] = self.parent_id
        if self.target_identifier is not None:
            result['targetIdentifier'] = self.target_identifier
        if self.target_type is not None:
            result['targetType'] = self.target_type
        if self.top_time is not None:
            result['topTime'] = self.top_time
        if self.user is not None:
            result['user'] = self.user.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('createTime') is not None:
            self.create_time = m.get('createTime')
        if m.get('formatType') is not None:
            self.format_type = m.get('formatType')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('isTop') is not None:
            self.is_top = m.get('isTop')
        if m.get('modifiedTime') is not None:
            self.modified_time = m.get('modifiedTime')
        if m.get('parentId') is not None:
            self.parent_id = m.get('parentId')
        if m.get('targetIdentifier') is not None:
            self.target_identifier = m.get('targetIdentifier')
        if m.get('targetType') is not None:
            self.target_type = m.get('targetType')
        if m.get('topTime') is not None:
            self.top_time = m.get('topTime')
        if m.get('user') is not None:
            temp_model = UpdateWorkitemCommentResponseBodyCommentUser()
            self.user = temp_model.from_map(m['user'])
        return self


class UpdateWorkitemCommentResponseBody(TeaModel):
    def __init__(
        self,
        comment: UpdateWorkitemCommentResponseBodyComment = None,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.comment = comment
        self.error_code = error_code
        self.error_msg = error_msg
        # Id of the request
        self.request_id = request_id
        self.success = success

    def validate(self):
        if self.comment:
            self.comment.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comment is not None:
            result['comment'] = self.comment.to_map()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('comment') is not None:
            temp_model = UpdateWorkitemCommentResponseBodyComment()
            self.comment = temp_model.from_map(m['comment'])
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateWorkitemCommentResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkitemCommentResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkitemCommentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest(TeaModel):
    def __init__(
        self,
        field_identifier: str = None,
        field_value: str = None,
    ):
        # This parameter is required.
        self.field_identifier = field_identifier
        # This parameter is required.
        self.field_value = field_value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field_identifier is not None:
            result['fieldIdentifier'] = self.field_identifier
        if self.field_value is not None:
            result['fieldValue'] = self.field_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fieldIdentifier') is not None:
            self.field_identifier = m.get('fieldIdentifier')
        if m.get('fieldValue') is not None:
            self.field_value = m.get('fieldValue')
        return self


class UpdateWorkitemFieldRequest(TeaModel):
    def __init__(
        self,
        update_workitem_property_request: List[UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest] = None,
        workitem_identifier: str = None,
    ):
        # This parameter is required.
        self.update_workitem_property_request = update_workitem_property_request
        # This parameter is required.
        self.workitem_identifier = workitem_identifier

    def validate(self):
        if self.update_workitem_property_request:
            for k in self.update_workitem_property_request:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['updateWorkitemPropertyRequest'] = []
        if self.update_workitem_property_request is not None:
            for k in self.update_workitem_property_request:
                result['updateWorkitemPropertyRequest'].append(k.to_map() if k else None)
        if self.workitem_identifier is not None:
            result['workitemIdentifier'] = self.workitem_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.update_workitem_property_request = []
        if m.get('updateWorkitemPropertyRequest') is not None:
            for k in m.get('updateWorkitemPropertyRequest'):
                temp_model = UpdateWorkitemFieldRequestUpdateWorkitemPropertyRequest()
                self.update_workitem_property_request.append(temp_model.from_map(k))
        if m.get('workitemIdentifier') is not None:
            self.workitem_identifier = m.get('workitemIdentifier')
        return self


class UpdateWorkitemFieldResponseBodyWorkitem(TeaModel):
    def __init__(
        self,
        assigned_to: str = None,
        category_identifier: str = None,
        creator: str = None,
        document: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        identifier: str = None,
        logical_status: str = None,
        modifier: str = None,
        parent_identifier: str = None,
        serial_number: str = None,
        space_identifier: str = None,
        space_name: str = None,
        space_type: str = None,
        sprint_identifier: str = None,
        status: str = None,
        status_identifier: str = None,
        status_stage_identifier: str = None,
        subject: str = None,
        update_status_at: int = None,
        workitem_type_identifier: str = None,
    ):
        self.assigned_to = assigned_to
        self.category_identifier = category_identifier
        self.creator = creator
        self.document = document
        self.gmt_create = gmt_create
        self.gmt_modified = gmt_modified
        self.identifier = identifier
        self.logical_status = logical_status
        self.modifier = modifier
        self.parent_identifier = parent_identifier
        self.serial_number = serial_number
        self.space_identifier = space_identifier
        self.space_name = space_name
        self.space_type = space_type
        self.sprint_identifier = sprint_identifier
        self.status = status
        self.status_identifier = status_identifier
        self.status_stage_identifier = status_stage_identifier
        self.subject = subject
        self.update_status_at = update_status_at
        self.workitem_type_identifier = workitem_type_identifier

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_to is not None:
            result['assignedTo'] = self.assigned_to
        if self.category_identifier is not None:
            result['categoryIdentifier'] = self.category_identifier
        if self.creator is not None:
            result['creator'] = self.creator
        if self.document is not None:
            result['document'] = self.document
        if self.gmt_create is not None:
            result['gmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmtModified'] = self.gmt_modified
        if self.identifier is not None:
            result['identifier'] = self.identifier
        if self.logical_status is not None:
            result['logicalStatus'] = self.logical_status
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.parent_identifier is not None:
            result['parentIdentifier'] = self.parent_identifier
        if self.serial_number is not None:
            result['serialNumber'] = self.serial_number
        if self.space_identifier is not None:
            result['spaceIdentifier'] = self.space_identifier
        if self.space_name is not None:
            result['spaceName'] = self.space_name
        if self.space_type is not None:
            result['spaceType'] = self.space_type
        if self.sprint_identifier is not None:
            result['sprintIdentifier'] = self.sprint_identifier
        if self.status is not None:
            result['status'] = self.status
        if self.status_identifier is not None:
            result['statusIdentifier'] = self.status_identifier
        if self.status_stage_identifier is not None:
            result['statusStageIdentifier'] = self.status_stage_identifier
        if self.subject is not None:
            result['subject'] = self.subject
        if self.update_status_at is not None:
            result['updateStatusAt'] = self.update_status_at
        if self.workitem_type_identifier is not None:
            result['workitemTypeIdentifier'] = self.workitem_type_identifier
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('assignedTo') is not None:
            self.assigned_to = m.get('assignedTo')
        if m.get('categoryIdentifier') is not None:
            self.category_identifier = m.get('categoryIdentifier')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('document') is not None:
            self.document = m.get('document')
        if m.get('gmtCreate') is not None:
            self.gmt_create = m.get('gmtCreate')
        if m.get('gmtModified') is not None:
            self.gmt_modified = m.get('gmtModified')
        if m.get('identifier') is not None:
            self.identifier = m.get('identifier')
        if m.get('logicalStatus') is not None:
            self.logical_status = m.get('logicalStatus')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('parentIdentifier') is not None:
            self.parent_identifier = m.get('parentIdentifier')
        if m.get('serialNumber') is not None:
            self.serial_number = m.get('serialNumber')
        if m.get('spaceIdentifier') is not None:
            self.space_identifier = m.get('spaceIdentifier')
        if m.get('spaceName') is not None:
            self.space_name = m.get('spaceName')
        if m.get('spaceType') is not None:
            self.space_type = m.get('spaceType')
        if m.get('sprintIdentifier') is not None:
            self.sprint_identifier = m.get('sprintIdentifier')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('statusIdentifier') is not None:
            self.status_identifier = m.get('statusIdentifier')
        if m.get('statusStageIdentifier') is not None:
            self.status_stage_identifier = m.get('statusStageIdentifier')
        if m.get('subject') is not None:
            self.subject = m.get('subject')
        if m.get('updateStatusAt') is not None:
            self.update_status_at = m.get('updateStatusAt')
        if m.get('workitemTypeIdentifier') is not None:
            self.workitem_type_identifier = m.get('workitemTypeIdentifier')
        return self


class UpdateWorkitemFieldResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_msg: str = None,
        request_id: str = None,
        success: bool = None,
        workitem: UpdateWorkitemFieldResponseBodyWorkitem = None,
    ):
        self.error_code = error_code
        self.error_msg = error_msg
        self.request_id = request_id
        self.success = success
        self.workitem = workitem

    def validate(self):
        if self.workitem:
            self.workitem.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_msg is not None:
            result['errorMsg'] = self.error_msg
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        if self.workitem is not None:
            result['workitem'] = self.workitem.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMsg') is not None:
            self.error_msg = m.get('errorMsg')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('workitem') is not None:
            temp_model = UpdateWorkitemFieldResponseBodyWorkitem()
            self.workitem = temp_model.from_map(m['workitem'])
        return self


class UpdateWorkitemFieldResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: UpdateWorkitemFieldResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateWorkitemFieldResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class WorkitemAttachmentCreateRequest(TeaModel):
    def __init__(
        self,
        file_key: str = None,
        original_filename: str = None,
    ):
        # This parameter is required.
        self.file_key = file_key
        # This parameter is required.
        self.original_filename = original_filename

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_key is not None:
            result['fileKey'] = self.file_key
        if self.original_filename is not None:
            result['originalFilename'] = self.original_filename
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fileKey') is not None:
            self.file_key = m.get('fileKey')
        if m.get('originalFilename') is not None:
            self.original_filename = m.get('originalFilename')
        return self


class WorkitemAttachmentCreateResponseBody(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        error_message: str = None,
        request_id: str = None,
        success: str = None,
    ):
        self.error_code = error_code
        self.error_message = error_message
        self.request_id = request_id
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['errorCode'] = self.error_code
        if self.error_message is not None:
            result['errorMessage'] = self.error_message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('errorCode') is not None:
            self.error_code = m.get('errorCode')
        if m.get('errorMessage') is not None:
            self.error_message = m.get('errorMessage')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class WorkitemAttachmentCreateResponse(TeaModel):
    def __init__(
        self,
        headers: Dict[str, str] = None,
        status_code: int = None,
        body: WorkitemAttachmentCreateResponseBody = None,
    ):
        self.headers = headers
        self.status_code = status_code
        self.body = body

    def validate(self):
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = WorkitemAttachmentCreateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


