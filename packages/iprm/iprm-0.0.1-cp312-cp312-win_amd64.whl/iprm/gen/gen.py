import os
import sys
from pathlib import Path
from abc import ABC, abstractmethod
from iprm.load.load import Loader
from iprm.util.env import Env
from iprm.core.object import Object
from iprm.api.obj.project import Project
from iprm.api.obj.subdirectories import SubDirectories
from iprm.api.obj.cxx import CXXTarget
from iprm.api.obj.rust import RustTarget

iprm_gen_dir_path = os.path.dirname(__file__)
src_dir_path = os.path.abspath(os.path.join(iprm_gen_dir_path, '..', '..'))
sys.path.append(src_dir_path)
from iprm.util.vcvarsall import find_vcvarsall


class Generator(ABC):
    def __init__(self, loader: Loader, **kwargs):
        self._loader = loader
        # TODO: rename this build_system?
        self._generator = kwargs.get('generator')
        # TODO: let user pass it in on CLI instead of generator sub classes hardcoding it
        self._build_dir = kwargs.get('build_dir')

    @abstractmethod
    def generator_name(self):
        pass

    @abstractmethod
    def generated_file_name(self):
        pass

    @abstractmethod
    def release_build_type(self):
        pass

    @property
    def loader(self):
        return self._loader

    @property
    def project_dir_str(self):
        return str(self.loader.project_dir)

    def generate_project(self):
        project_objects = self.loader.load_project()
        num_files_to_generate = len(project_objects.keys()) if project_objects is not None else 0
        if num_files_to_generate == 0:
            self.loader.log_sink.log_message(f'{self.loader.file_name()}: no CMakeLists.txt files to generate')
            return

        sorted_project_file_objects = {}
        for native_file_path, objects in project_objects.items():
            # TODO: properly sort objects based on generation requirements (although we may not need it anymore if
            #  the API re-write structured in such a way that each object has all the context it needs. This is the
            #  ideal/goal for drastic simplifications
            # sorted_project_file_objects[native_file_path] = sorted(objects, key=self._order_key)
            sorted_project_file_objects[native_file_path] = objects

        # Ensure we process all the files with frameworks first, so we can set up any global state
        # required by targets that depend on the framework. In handwritten CMake you can set things
        # up such that variables/data is set before anyone depends on it, but we don't have that luxury
        sorted_project_file_paths = sorted(sorted_project_file_objects.keys(),
                                           key=lambda k: not any(
                                               proj_file_obj.is_framework for proj_file_obj in
                                               sorted_project_file_objects[k]))

        num_files_generated = 1
        for project_file_path in sorted_project_file_paths:
            def gen_log():
                self.loader.log_sink.log_message(
                    f'[{num_files_generated}/{num_files_to_generate}] Generating {self.generated_file_name()} from '
                    f'{project_file_path}', end='\r')

            gen_log()

            objects = sorted_project_file_objects[project_file_path]

            from iprm import __version__
            from datetime import datetime, timezone
            generated_content = [
                '# =========================================================',
                '# WARNING: This file is auto-generated. DO NOT EDIT MANUALLY',
                f'# Generated by: iprm (v{__version__})',
                f'# Generated on: {datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S %Z")}',
                f'# Platform: {Env.platform.display_name()}',
                '# =========================================================',
            ]
            for obj in objects:
                # NOTE: Generators are state-less, it assumes validation on the native objects has happened by this
                # point and just spits out what the object tells it to. Actual validation on the generated files can
                # be tested by running the various configure, build, test, and install commands to target project model
                # supports and independently verifying the results are what one expects
                generated_obj_content = self._generate_object(obj)
                if generated_obj_content:
                    generated_content.extend(generated_obj_content)
                else:
                    # TODO: log saying no content for the object was generated
                    pass

            generated_file_path = Path(str(project_file_path)).parent / self.generated_file_name()
            with open(generated_file_path, 'w') as file:
                file.write('\n'.join(generated_content))
                num_files_generated += 1
        self.loader.log_sink.log_message('')
        self._write_scripts()

    @classmethod
    def _generate_object(cls, obj: Object) -> list[str]:
        from typing import cast
        if obj.is_project:
            project = cast(Project, obj)
            return cls._generate_project(project)
        elif obj.is_subdirs:
            subdirs = cast(SubDirectories, obj)
            return cls._generate_subdirectories(subdirs)
        elif obj.is_cxx:
            cxx = cast(CXXTarget, obj)
            return cls._generate_cxx(cxx)
        elif obj.is_rust:
            rust = cast(RustTarget, obj)
            return cls._generate_rust(rust)
        return []

    @classmethod
    @abstractmethod
    def _generate_project(cls, project: Project) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_subdirectories(cls, subdirs: SubDirectories) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_cxx(cls, cxx: CXXTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_rust(cls, rust: RustTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def current_src_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def current_bin_dir(cls):
        pass



    # TODO: for all these, re-update them to make each generator sub class have to implement the configure,
    #  build, test, and install commands. That is, what would you execute on the command line to perform those
    #  actions for the particular generator implementation

    def _write_scripts(self):
        if Env.platform.windows:
            self._write_scripts_win()
        else:
            self._write_scripts_unix()

    def _write_scripts_win(self):
        vcvarsall_path = find_vcvarsall()
        assert vcvarsall_path is not None
        invoke_vcvarsall = f'call "{vcvarsall_path}" x64'
        configure_script_name = f'{self.generator_name()}_configure.bat'
        configure_script_content = f'''@echo off
{invoke_vcvarsall}
setlocal
set "current_dir=%cd%"
cd "{self.project_dir_str}"
if "%1"=="" (
    set BUILD_TYPE={self.release_build_type()}
) else (
    set BUILD_TYPE=%1
)
{self._write_configure(self._build_dir, self._generator, '%BUILD_TYPE%')}
cd "%current_dir%"
endlocal'''
        self._write_script(configure_script_name, configure_script_content, self.project_dir_str)

        build_script_name = f'{self.generator_name()}_build.bat'
        build_script_content = f'''@echo off
{invoke_vcvarsall}
setlocal
set "current_dir=%cd%"
cd "{self.project_dir_str}"
if "%1"=="" (
    set BUILD_TYPE={self.release_build_type()}
) else (
    set BUILD_TYPE=%1
)
{self._write_build(self._build_dir, '%BUILD_TYPE%')}
cd "%current_dir%"
endlocal'''
        self._write_script(build_script_name, build_script_content, self.project_dir_str)

        test_script_name = f'{self.generator_name()}_test.bat'
        test_script_content = f'''@echo off
{invoke_vcvarsall}
setlocal
set "current_dir=%cd%"
cd "{self.project_dir_str}"
{self._write_test(self._build_dir)}
cd "%current_dir%"
endlocal'''
        self._write_script(test_script_name, test_script_content, self.project_dir_str)

    def _write_scripts_unix(self):
        configure_script_name = f'{self.generator_name()}_configure.sh'
        configure_script_content = f'''#!/bin/sh
current_dir=$(pwd)
cd "{self.project_dir_str}" || exit
BUILD_TYPE=${{1:-{self.release_build_type()}}}
{self._write_configure(self._build_dir, self._generator, '$BUILD_TYPE')}
cd "$current_dir" || exit'''
        self._write_script(configure_script_name, configure_script_content, self.project_dir_str)

        build_script_name = f'{self.generator_name()}_build.sh'
        build_script_content = f'''#!/bin/sh
current_dir=$(pwd)
cd "{self.project_dir_str}" || exit
BUILD_TYPE=${{1:-{self.release_build_type()}}}
{self._write_build(self._build_dir, '$BUILD_TYPE')}
cd "$current_dir" || exit'''
        self._write_script(build_script_name, build_script_content, self.project_dir_str)

        test_script_name = f'{self.generator_name()}_test.sh'
        test_script_content = f'''#!/bin/sh
current_dir=$(pwd)
cd "{self.project_dir_str}" || exit
{self._write_test(self._build_dir)}
cd "$current_dir" || exit'''
        self._write_script(test_script_name, test_script_content, self.project_dir_str)

    @classmethod
    def _write_script(cls, name, content, root_dir):
        file = os.path.join(root_dir, name)
        with open(file, 'w', newline='\n') as f:
            f.write(content)
        if not Env.platform.windows:
            import stat
            st = os.stat(file)
            os.chmod(file, st.st_mode | stat.S_IEXEC)

    @classmethod
    @abstractmethod
    def _write_configure(cls, build_dir: str, build_system: str, build_type: str) -> str:
        pass

    @classmethod
    @abstractmethod
    def _write_build(cls, build_dir: str, build_type: str) -> str:
        pass

    @classmethod
    @abstractmethod
    def _write_test(cls, build_dir: str) -> str:
        pass
