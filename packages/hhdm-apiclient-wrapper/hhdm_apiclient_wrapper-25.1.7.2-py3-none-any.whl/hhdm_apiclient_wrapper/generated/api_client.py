from datetime import datetime
import json
from typing import Mapping, MutableMapping

from .. import base_api_client
from ..models import *


# Inherit from the manually written ApiClient class with utility methods and context
class ApiClient(base_api_client.ApiClient):

    async def get_ambient_measurement_by_id(self, account_id: str, ambient_measurement_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_ambient_measurements_for_event(self, account_id: str, event_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}AmbientMeasurements"

        param_lookup = dict()
        param_lookup["eventId"] = event_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_ambient_measurement(self, account_id: str, event_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}AmbientMeasurements?eventId={event_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_ambient_measurement(self, account_id: str, ambient_measurement_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}", update_model)
        return response.is_success

    async def delete_ambient_measurement(self, account_id: str, ambient_measurement_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}")
        return response.is_success

    async def get_ambient_measurement_attachments_by_id(self, account_id: str, ambient_measurement_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_ambient_measurement_attachments_by_name(self, account_id: str, ambient_measurement_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_ambient_measurement_collection_item_attachments_by_id(self, account_id: str, ambient_measurement_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_ambient_measurement_collection_item_attachments_by_name(self, account_id: str, ambient_measurement_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_ambient_measurement_attachment(self, account_id: str, ambient_measurement_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_ambient_measurement_collection_item_attachment(self, account_id: str, ambient_measurement_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_ambient_measurement_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, ambient_measurement_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_ambient_measurement_attachment(
            add_attached_file_response.account_id,
            ambient_measurement_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, ambient_measurement_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, ambient_measurement_id, None, None)

    async def _set_ambient_measurement_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, ambient_measurement_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_ambient_measurement_collection_item_attachment(
            add_attached_file_response.account_id,
            ambient_measurement_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, ambient_measurement_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, ambient_measurement_id, collection_name, collection_item_id, None, None)

    async def _upload_ambient_measurement_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, ambient_measurement_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, ambient_measurement_id, source_path, file_name)

            return await self._set_ambient_measurement_attachment_server_state_to_completed(add_attached_file_response, ambient_measurement_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, ambient_measurement_id, source_path, file_name, message=e)

    async def _upload_ambient_measurement_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, ambient_measurement_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, ambient_measurement_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_ambient_measurement_collection_item_attachment_server_state_to_completed(add_attached_file_response, ambient_measurement_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, ambient_measurement_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_ambient_measurement(self, account_id: str, ambient_measurement_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to ambient_measurement.
        
        :param account_id: str, 
        :param ambient_measurement_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, ambient_measurement_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, ambient_measurement_id, source_path, model.file_name)

        return await self._upload_ambient_measurement_attachment(parsed_response, ambient_measurement_id, file, model.file_name)

    async def add_attachment_to_ambient_measurement_collection_item(self, account_id: str, ambient_measurement_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to ambient_measurement_collection_item.
        
        :param account_id: str, 
        :param ambient_measurement_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, ambient_measurement_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, ambient_measurement_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_ambient_measurement_collection_item_attachment(parsed_response, ambient_measurement_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_ambient_measurement_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_ambient_measurement_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_ambient_measurement_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_ambient_measurement_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_ambient_measurement_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_ambient_measurement_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_ambient_measurement_attachment(self, account_id: str, ambient_measurement_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_ambient_measurement_collection_item_attachment(self, account_id: str, ambient_measurement_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AmbientMeasurements/{ambient_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_car_by_id(self, account_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Cars/{car_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_cars(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Cars"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_car(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Cars?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_car(self, account_id: str, car_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Cars/{car_id}", update_model)
        return response.is_success

    async def delete_car(self, account_id: str, car_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Cars/{car_id}")
        return response.is_success

    async def get_car_attachments_by_id(self, account_id: str, car_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Cars/{car_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Cars/{car_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_attachments_by_name(self, account_id: str, car_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_collection_item_attachments_by_id(self, account_id: str, car_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Cars/{car_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Cars/{car_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_collection_item_attachments_by_name(self, account_id: str, car_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_car_attachment(self, account_id: str, car_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_car_collection_item_attachment(self, account_id: str, car_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_car_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, car_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_car_attachment(
            add_attached_file_response.account_id,
            car_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, car_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, car_id, None, None)

    async def _set_car_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, car_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_car_collection_item_attachment(
            add_attached_file_response.account_id,
            car_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, car_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, car_id, collection_name, collection_item_id, None, None)

    async def _upload_car_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, car_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_id, source_path, file_name)

            return await self._set_car_attachment_server_state_to_completed(add_attached_file_response, car_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_id, source_path, file_name, message=e)

    async def _upload_car_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, car_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_car_collection_item_attachment_server_state_to_completed(add_attached_file_response, car_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_car(self, account_id: str, car_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to car.
        
        :param account_id: str, 
        :param car_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, car_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, car_id, source_path, model.file_name)

        return await self._upload_car_attachment(parsed_response, car_id, file, model.file_name)

    async def add_attachment_to_car_collection_item(self, account_id: str, car_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to car_collection_item.
        
        :param account_id: str, 
        :param car_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, car_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, car_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_car_collection_item_attachment(parsed_response, car_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_car_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_car_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_car_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_car_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_car_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_car_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_car_attachment(self, account_id: str, car_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_car_collection_item_attachment(self, account_id: str, car_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Cars/{car_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_championship_by_id(self, account_id: str, championship_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Championships/{championship_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_championships(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Championships"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_championship(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Championships?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_championship(self, account_id: str, championship_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Championships/{championship_id}", update_model)
        return response.is_success

    async def delete_championship(self, account_id: str, championship_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Championships/{championship_id}")
        return response.is_success

    async def get_championship_attachments_by_id(self, account_id: str, championship_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Championships/{championship_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Championships/{championship_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_championship_attachments_by_name(self, account_id: str, championship_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_championship_collection_item_attachments_by_id(self, account_id: str, championship_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Championships/{championship_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Championships/{championship_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_championship_collection_item_attachments_by_name(self, account_id: str, championship_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_championship_attachment(self, account_id: str, championship_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_championship_collection_item_attachment(self, account_id: str, championship_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_championship_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, championship_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_championship_attachment(
            add_attached_file_response.account_id,
            championship_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, championship_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, championship_id, None, None)

    async def _set_championship_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, championship_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_championship_collection_item_attachment(
            add_attached_file_response.account_id,
            championship_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, championship_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, championship_id, collection_name, collection_item_id, None, None)

    async def _upload_championship_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, championship_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, championship_id, source_path, file_name)

            return await self._set_championship_attachment_server_state_to_completed(add_attached_file_response, championship_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, championship_id, source_path, file_name, message=e)

    async def _upload_championship_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, championship_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, championship_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_championship_collection_item_attachment_server_state_to_completed(add_attached_file_response, championship_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, championship_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_championship(self, account_id: str, championship_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to championship.
        
        :param account_id: str, 
        :param championship_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, championship_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, championship_id, source_path, model.file_name)

        return await self._upload_championship_attachment(parsed_response, championship_id, file, model.file_name)

    async def add_attachment_to_championship_collection_item(self, account_id: str, championship_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to championship_collection_item.
        
        :param account_id: str, 
        :param championship_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, championship_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, championship_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_championship_collection_item_attachment(parsed_response, championship_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_championship_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_championship_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_championship_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_championship_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_championship_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_championship_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_championship_attachment(self, account_id: str, championship_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_championship_collection_item_attachment(self, account_id: str, championship_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Championships/{championship_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_event_by_id(self, account_id: str, event_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Events/{event_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_event(self, account_id: str, championship_id: str, track_id: str, default_track_configuration_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Events?championshipId={championship_id}&trackId={track_id}&defaultTrackConfigurationId={default_track_configuration_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_event(self, account_id: str, event_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Events/{event_id}", update_model)
        return response.is_success

    async def delete_event(self, account_id: str, event_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Events/{event_id}")
        return response.is_success

    async def get_event_attachments_by_id(self, account_id: str, event_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Events/{event_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Events/{event_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_event_attachments_by_name(self, account_id: str, event_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Events/{event_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_event_collection_item_attachments_by_id(self, account_id: str, event_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Events/{event_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Events/{event_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_event_collection_item_attachments_by_name(self, account_id: str, event_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Events/{event_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_event_attachment(self, account_id: str, event_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Events/{event_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_event_collection_item_attachment(self, account_id: str, event_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Events/{event_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_event_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, event_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_event_attachment(
            add_attached_file_response.account_id,
            event_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, event_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, event_id, None, None)

    async def _set_event_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, event_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_event_collection_item_attachment(
            add_attached_file_response.account_id,
            event_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, event_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, event_id, collection_name, collection_item_id, None, None)

    async def _upload_event_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, event_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_id, source_path, file_name)

            return await self._set_event_attachment_server_state_to_completed(add_attached_file_response, event_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_id, source_path, file_name, message=e)

    async def _upload_event_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, event_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_event_collection_item_attachment_server_state_to_completed(add_attached_file_response, event_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_event(self, account_id: str, event_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to event.
        
        :param account_id: str, 
        :param event_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Events/{event_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, event_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, event_id, source_path, model.file_name)

        return await self._upload_event_attachment(parsed_response, event_id, file, model.file_name)

    async def add_attachment_to_event_collection_item(self, account_id: str, event_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to event_collection_item.
        
        :param account_id: str, 
        :param event_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Events/{event_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, event_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, event_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_event_collection_item_attachment(parsed_response, event_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_event_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_event_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_event_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_event_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_event_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_event_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_event_attachment(self, account_id: str, event_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Events/{event_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_event_collection_item_attachment(self, account_id: str, event_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Events/{event_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_event_car_data_by_id(self, account_id: str, event_car_data_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}EventCarDatas/{event_car_data_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_event_car_data_for_event_car(self, account_id: str, event_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}EventCarDatas"

        param_lookup = dict()
        param_lookup["eventId"] = event_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def update_event_car_data(self, account_id: str, event_car_data_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}", update_model)
        return response.is_success

    async def get_event_car_data_attachments_by_id(self, account_id: str, event_car_data_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def get_event_car_data_attachments_by_name(self, account_id: str, event_car_data_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def get_event_car_data_collection_item_attachments_by_id(self, account_id: str, event_car_data_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def get_event_car_data_collection_item_attachments_by_name(self, account_id: str, event_car_data_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def update_event_car_data_attachment(self, account_id: str, event_car_data_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_event_car_data_collection_item_attachment(self, account_id: str, event_car_data_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_event_car_data_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, event_car_data_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_event_car_data_attachment(
            add_attached_file_response.account_id,
            event_car_data_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, event_car_data_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, event_car_data_id, None, None)

    async def _set_event_car_data_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, event_car_data_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_event_car_data_collection_item_attachment(
            add_attached_file_response.account_id,
            event_car_data_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, event_car_data_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, event_car_data_id, collection_name, collection_item_id, None, None)

    async def _upload_event_car_data_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, event_car_data_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_car_data_id, source_path, file_name)

            return await self._set_event_car_data_attachment_server_state_to_completed(add_attached_file_response, event_car_data_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_car_data_id, source_path, file_name, message=e)

    async def _upload_event_car_data_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, event_car_data_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_car_data_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_event_car_data_collection_item_attachment_server_state_to_completed(add_attached_file_response, event_car_data_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, event_car_data_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_event_car_data(self, account_id: str, event_car_data_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to event_car_data.
        
        :param account_id: str, 
        :param event_car_data_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, event_car_data_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, event_car_data_id, source_path, model.file_name)

        return await self._upload_event_car_data_attachment(parsed_response, event_car_data_id, file, model.file_name)

    async def add_attachment_to_event_car_data_collection_item(self, account_id: str, event_car_data_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to event_car_data_collection_item.
        
        :param account_id: str, 
        :param event_car_data_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, event_car_data_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, event_car_data_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_event_car_data_collection_item_attachment(parsed_response, event_car_data_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_event_car_data_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_event_car_data_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_event_car_data_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_event_car_data_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_event_car_data_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_event_car_data_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_event_car_data_attachment(self, account_id: str, event_car_data_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_event_car_data_collection_item_attachment(self, account_id: str, event_car_data_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}EventCarDatas/{event_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_lap_by_id(self, account_id: str, lap_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Laps/{lap_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_bulk_laps(self, account_id: str, event_ids: List[str], car_ids: List[str], lap_filter: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f'{self.api_endpoint}Laps/Bulk'

        param_lookup = {
            "eventIds": ','.join(event_ids),
            "carIds": ','.join(car_ids),
            "filter": lap_filter
        }
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_lap(self, account_id: str, run_sheet_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Laps?runSheetId={run_sheet_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_lap(self, account_id: str, lap_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Laps/{lap_id}", update_model)
        return response.is_success

    async def delete_lap(self, account_id: str, lap_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Laps/{lap_id}")
        return response.is_success

    async def get_lap_attachments_by_id(self, account_id: str, lap_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Laps/{lap_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Laps/{lap_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_attachments_by_name(self, account_id: str, lap_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_collection_item_attachments_by_id(self, account_id: str, lap_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Laps/{lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Laps/{lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_collection_item_attachments_by_name(self, account_id: str, lap_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_lap_attachment(self, account_id: str, lap_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_lap_collection_item_attachment(self, account_id: str, lap_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_lap_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_attachment(
            add_attached_file_response.account_id,
            lap_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_id, None, None)

    async def _set_lap_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_collection_item_attachment(
            add_attached_file_response.account_id,
            lap_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_id, collection_name, collection_item_id, None, None)

    async def _upload_lap_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_id, source_path, file_name)

            return await self._set_lap_attachment_server_state_to_completed(add_attached_file_response, lap_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_id, source_path, file_name, message=e)

    async def _upload_lap_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_lap_collection_item_attachment_server_state_to_completed(add_attached_file_response, lap_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_lap(self, account_id: str, lap_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap.
        
        :param account_id: str, 
        :param lap_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_id, source_path, model.file_name)

        return await self._upload_lap_attachment(parsed_response, lap_id, file, model.file_name)

    async def add_attachment_to_lap_collection_item(self, account_id: str, lap_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_collection_item.
        
        :param account_id: str, 
        :param lap_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_lap_collection_item_attachment(parsed_response, lap_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_lap_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_lap_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_lap_attachment(self, account_id: str, lap_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_lap_collection_item_attachment(self, account_id: str, lap_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Laps/{lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_part_by_id(self, account_id: str, part_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Parts/{part_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_part(self, account_id: str, part_category_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Parts?partCategoryId={part_category_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_part(self, account_id: str, part_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Parts/{part_id}", update_model)
        return response.is_success

    async def delete_part(self, account_id: str, part_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Parts/{part_id}")
        return response.is_success

    async def get_part_attachments_by_id(self, account_id: str, part_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Parts/{part_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Parts/{part_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_attachments_by_name(self, account_id: str, part_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_collection_item_attachments_by_id(self, account_id: str, part_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Parts/{part_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Parts/{part_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_collection_item_attachments_by_name(self, account_id: str, part_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_part_attachment(self, account_id: str, part_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_part_collection_item_attachment(self, account_id: str, part_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_part_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, part_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_part_attachment(
            add_attached_file_response.account_id,
            part_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, part_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, part_id, None, None)

    async def _set_part_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, part_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_part_collection_item_attachment(
            add_attached_file_response.account_id,
            part_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, part_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, part_id, collection_name, collection_item_id, None, None)

    async def _upload_part_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, part_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_id, source_path, file_name)

            return await self._set_part_attachment_server_state_to_completed(add_attached_file_response, part_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_id, source_path, file_name, message=e)

    async def _upload_part_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, part_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_part_collection_item_attachment_server_state_to_completed(add_attached_file_response, part_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_part(self, account_id: str, part_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to part.
        
        :param account_id: str, 
        :param part_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, part_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, part_id, source_path, model.file_name)

        return await self._upload_part_attachment(parsed_response, part_id, file, model.file_name)

    async def add_attachment_to_part_collection_item(self, account_id: str, part_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to part_collection_item.
        
        :param account_id: str, 
        :param part_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, part_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, part_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_part_collection_item_attachment(parsed_response, part_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_part_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_part_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_part_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_part_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_part_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_part_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_part_attachment(self, account_id: str, part_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_part_collection_item_attachment(self, account_id: str, part_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Parts/{part_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_part_category_by_id(self, account_id: str, part_category_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}PartCategories/{part_category_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_part_categories(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}PartCategories"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_part_category(self, account_id: str, part_category_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}", update_model)
        return response.is_success

    async def delete_part_category(self, account_id: str, part_category_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}")
        return response.is_success

    async def get_part_category_attachments_by_id(self, account_id: str, part_category_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PartCategories/{part_category_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PartCategories/{part_category_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_category_attachments_by_name(self, account_id: str, part_category_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_category_collection_item_attachments_by_id(self, account_id: str, part_category_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PartCategories/{part_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PartCategories/{part_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_category_collection_item_attachments_by_name(self, account_id: str, part_category_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_part_category_attachment(self, account_id: str, part_category_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_part_category_collection_item_attachment(self, account_id: str, part_category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_part_category_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, part_category_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_part_category_attachment(
            add_attached_file_response.account_id,
            part_category_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, part_category_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, part_category_id, None, None)

    async def _set_part_category_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, part_category_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_part_category_collection_item_attachment(
            add_attached_file_response.account_id,
            part_category_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, part_category_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, part_category_id, collection_name, collection_item_id, None, None)

    async def _upload_part_category_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, part_category_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_category_id, source_path, file_name)

            return await self._set_part_category_attachment_server_state_to_completed(add_attached_file_response, part_category_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_category_id, source_path, file_name, message=e)

    async def _upload_part_category_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, part_category_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_category_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_part_category_collection_item_attachment_server_state_to_completed(add_attached_file_response, part_category_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_category_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_part_category(self, account_id: str, part_category_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to part_category.
        
        :param account_id: str, 
        :param part_category_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, part_category_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, part_category_id, source_path, model.file_name)

        return await self._upload_part_category_attachment(parsed_response, part_category_id, file, model.file_name)

    async def add_attachment_to_part_category_collection_item(self, account_id: str, part_category_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to part_category_collection_item.
        
        :param account_id: str, 
        :param part_category_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, part_category_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, part_category_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_part_category_collection_item_attachment(parsed_response, part_category_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_part_category_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_part_category_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_part_category_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_part_category_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_part_category_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_part_category_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_part_category_attachment(self, account_id: str, part_category_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_part_category_collection_item_attachment(self, account_id: str, part_category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PartCategories/{part_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_planned_run_by_id(self, account_id: str, planned_run_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}PlannedRuns/{planned_run_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_planned_run(self, account_id: str, run_plan_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}PlannedRuns?runPlanId={run_plan_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_planned_run(self, account_id: str, planned_run_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}", update_model)
        return response.is_success

    async def delete_planned_run(self, account_id: str, planned_run_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}")
        return response.is_success

    async def get_planned_run_attachments_by_id(self, account_id: str, planned_run_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_planned_run_attachments_by_name(self, account_id: str, planned_run_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_planned_run_collection_item_attachments_by_id(self, account_id: str, planned_run_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_planned_run_collection_item_attachments_by_name(self, account_id: str, planned_run_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_planned_run_attachment(self, account_id: str, planned_run_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_planned_run_collection_item_attachment(self, account_id: str, planned_run_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_planned_run_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_run_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_planned_run_attachment(
            add_attached_file_response.account_id,
            planned_run_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, planned_run_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, planned_run_id, None, None)

    async def _set_planned_run_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_run_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_planned_run_collection_item_attachment(
            add_attached_file_response.account_id,
            planned_run_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, planned_run_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, planned_run_id, collection_name, collection_item_id, None, None)

    async def _upload_planned_run_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_run_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_run_id, source_path, file_name)

            return await self._set_planned_run_attachment_server_state_to_completed(add_attached_file_response, planned_run_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_run_id, source_path, file_name, message=e)

    async def _upload_planned_run_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_run_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_run_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_planned_run_collection_item_attachment_server_state_to_completed(add_attached_file_response, planned_run_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_run_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_planned_run(self, account_id: str, planned_run_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to planned_run.
        
        :param account_id: str, 
        :param planned_run_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, planned_run_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, planned_run_id, source_path, model.file_name)

        return await self._upload_planned_run_attachment(parsed_response, planned_run_id, file, model.file_name)

    async def add_attachment_to_planned_run_collection_item(self, account_id: str, planned_run_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to planned_run_collection_item.
        
        :param account_id: str, 
        :param planned_run_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, planned_run_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, planned_run_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_planned_run_collection_item_attachment(parsed_response, planned_run_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_planned_run_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_planned_run_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_planned_run_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_planned_run_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_planned_run_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_planned_run_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_planned_run_attachment(self, account_id: str, planned_run_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_planned_run_collection_item_attachment(self, account_id: str, planned_run_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PlannedRuns/{planned_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_reference_pressure_run_by_id(self, account_id: str, reference_pressure_run_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_reference_pressure_runs_for_event_car(self, account_id: str, event_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}ReferencePressureRuns"

        param_lookup = dict()
        param_lookup["eventId"] = event_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_reference_pressure_run(self, account_id: str, event_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ReferencePressureRuns?eventId={event_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_reference_pressure_run(self, account_id: str, reference_pressure_run_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}", update_model)
        return response.is_success

    async def delete_reference_pressure_run(self, account_id: str, reference_pressure_run_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}")
        return response.is_success

    async def get_reference_pressure_run_attachments_by_id(self, account_id: str, reference_pressure_run_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_reference_pressure_run_attachments_by_name(self, account_id: str, reference_pressure_run_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_reference_pressure_run_collection_item_attachments_by_id(self, account_id: str, reference_pressure_run_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_reference_pressure_run_collection_item_attachments_by_name(self, account_id: str, reference_pressure_run_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_reference_pressure_run_attachment(self, account_id: str, reference_pressure_run_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_reference_pressure_run_collection_item_attachment(self, account_id: str, reference_pressure_run_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_reference_pressure_run_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, reference_pressure_run_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_reference_pressure_run_attachment(
            add_attached_file_response.account_id,
            reference_pressure_run_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, reference_pressure_run_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, reference_pressure_run_id, None, None)

    async def _set_reference_pressure_run_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, reference_pressure_run_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_reference_pressure_run_collection_item_attachment(
            add_attached_file_response.account_id,
            reference_pressure_run_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, reference_pressure_run_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, reference_pressure_run_id, collection_name, collection_item_id, None, None)

    async def _upload_reference_pressure_run_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, reference_pressure_run_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, reference_pressure_run_id, source_path, file_name)

            return await self._set_reference_pressure_run_attachment_server_state_to_completed(add_attached_file_response, reference_pressure_run_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, reference_pressure_run_id, source_path, file_name, message=e)

    async def _upload_reference_pressure_run_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, reference_pressure_run_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, reference_pressure_run_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_reference_pressure_run_collection_item_attachment_server_state_to_completed(add_attached_file_response, reference_pressure_run_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, reference_pressure_run_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_reference_pressure_run(self, account_id: str, reference_pressure_run_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to reference_pressure_run.
        
        :param account_id: str, 
        :param reference_pressure_run_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, reference_pressure_run_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, reference_pressure_run_id, source_path, model.file_name)

        return await self._upload_reference_pressure_run_attachment(parsed_response, reference_pressure_run_id, file, model.file_name)

    async def add_attachment_to_reference_pressure_run_collection_item(self, account_id: str, reference_pressure_run_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to reference_pressure_run_collection_item.
        
        :param account_id: str, 
        :param reference_pressure_run_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, reference_pressure_run_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, reference_pressure_run_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_reference_pressure_run_collection_item_attachment(parsed_response, reference_pressure_run_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_reference_pressure_run_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_reference_pressure_run_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_reference_pressure_run_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_reference_pressure_run_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_reference_pressure_run_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_reference_pressure_run_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_reference_pressure_run_attachment(self, account_id: str, reference_pressure_run_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_reference_pressure_run_collection_item_attachment(self, account_id: str, reference_pressure_run_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ReferencePressureRuns/{reference_pressure_run_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_run_plan_by_id(self, account_id: str, run_plan_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}RunPlans/{run_plan_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_run_plans_for_session_car(self, account_id: str, session_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}RunPlans"

        param_lookup = dict()
        param_lookup["sessionId"] = session_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_run_plan(self, account_id: str, session_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}RunPlans?sessionId={session_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_run_plan(self, account_id: str, run_plan_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}", update_model)
        return response.is_success

    async def delete_run_plan(self, account_id: str, run_plan_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}")
        return response.is_success

    async def get_run_plan_attachments_by_id(self, account_id: str, run_plan_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}RunPlans/{run_plan_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}RunPlans/{run_plan_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_run_plan_attachments_by_name(self, account_id: str, run_plan_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_run_plan_collection_item_attachments_by_id(self, account_id: str, run_plan_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}RunPlans/{run_plan_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}RunPlans/{run_plan_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_run_plan_collection_item_attachments_by_name(self, account_id: str, run_plan_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_run_plan_attachment(self, account_id: str, run_plan_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_run_plan_collection_item_attachment(self, account_id: str, run_plan_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_run_plan_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, run_plan_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_run_plan_attachment(
            add_attached_file_response.account_id,
            run_plan_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, run_plan_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, run_plan_id, None, None)

    async def _set_run_plan_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, run_plan_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_run_plan_collection_item_attachment(
            add_attached_file_response.account_id,
            run_plan_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, run_plan_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, run_plan_id, collection_name, collection_item_id, None, None)

    async def _upload_run_plan_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, run_plan_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_plan_id, source_path, file_name)

            return await self._set_run_plan_attachment_server_state_to_completed(add_attached_file_response, run_plan_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_plan_id, source_path, file_name, message=e)

    async def _upload_run_plan_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, run_plan_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_plan_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_run_plan_collection_item_attachment_server_state_to_completed(add_attached_file_response, run_plan_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_plan_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_run_plan(self, account_id: str, run_plan_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to run_plan.
        
        :param account_id: str, 
        :param run_plan_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, run_plan_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, run_plan_id, source_path, model.file_name)

        return await self._upload_run_plan_attachment(parsed_response, run_plan_id, file, model.file_name)

    async def add_attachment_to_run_plan_collection_item(self, account_id: str, run_plan_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to run_plan_collection_item.
        
        :param account_id: str, 
        :param run_plan_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, run_plan_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, run_plan_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_run_plan_collection_item_attachment(parsed_response, run_plan_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_run_plan_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_run_plan_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_run_plan_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_run_plan_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_run_plan_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_run_plan_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_run_plan_attachment(self, account_id: str, run_plan_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_run_plan_collection_item_attachment(self, account_id: str, run_plan_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}RunPlans/{run_plan_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_run_sheet_by_id(self, account_id: str, run_sheet_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}RunSheets/{run_sheet_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_bulk_run_sheets(self, account_id: str, event_ids: List[str], car_ids: List[str], run_sheet_filter: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f'{self.api_endpoint}RunSheets/Bulk'

        param_lookup = {
            "eventIds": ','.join(event_ids),
            "carIds": ','.join(car_ids),
            "filter": run_sheet_filter
        }
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_run_sheets_for_session_car(self, account_id: str, session_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}RunSheets"

        param_lookup = dict()
        param_lookup["sessionId"] = session_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_run_sheet(self, account_id: str, session_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}RunSheets?sessionId={session_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_run_sheet(self, account_id: str, run_sheet_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}", update_model)
        return response.is_success

    async def delete_run_sheet(self, account_id: str, run_sheet_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}")
        return response.is_success

    async def get_run_sheet_attachments_by_id(self, account_id: str, run_sheet_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}RunSheets/{run_sheet_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}RunSheets/{run_sheet_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_run_sheet_attachments_by_name(self, account_id: str, run_sheet_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_run_sheet_collection_item_attachments_by_id(self, account_id: str, run_sheet_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}RunSheets/{run_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}RunSheets/{run_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_run_sheet_collection_item_attachments_by_name(self, account_id: str, run_sheet_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_run_sheet_attachment(self, account_id: str, run_sheet_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_run_sheet_collection_item_attachment(self, account_id: str, run_sheet_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_run_sheet_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, run_sheet_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_run_sheet_attachment(
            add_attached_file_response.account_id,
            run_sheet_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, run_sheet_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, run_sheet_id, None, None)

    async def _set_run_sheet_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, run_sheet_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_run_sheet_collection_item_attachment(
            add_attached_file_response.account_id,
            run_sheet_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, run_sheet_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, run_sheet_id, collection_name, collection_item_id, None, None)

    async def _upload_run_sheet_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, run_sheet_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_sheet_id, source_path, file_name)

            return await self._set_run_sheet_attachment_server_state_to_completed(add_attached_file_response, run_sheet_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_sheet_id, source_path, file_name, message=e)

    async def _upload_run_sheet_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, run_sheet_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_sheet_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_run_sheet_collection_item_attachment_server_state_to_completed(add_attached_file_response, run_sheet_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, run_sheet_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_run_sheet(self, account_id: str, run_sheet_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to run_sheet.
        
        :param account_id: str, 
        :param run_sheet_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, run_sheet_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, run_sheet_id, source_path, model.file_name)

        return await self._upload_run_sheet_attachment(parsed_response, run_sheet_id, file, model.file_name)

    async def add_attachment_to_run_sheet_collection_item(self, account_id: str, run_sheet_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to run_sheet_collection_item.
        
        :param account_id: str, 
        :param run_sheet_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, run_sheet_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, run_sheet_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_run_sheet_collection_item_attachment(parsed_response, run_sheet_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_run_sheet_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_run_sheet_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_run_sheet_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_run_sheet_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_run_sheet_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_run_sheet_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_run_sheet_attachment(self, account_id: str, run_sheet_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_run_sheet_collection_item_attachment(self, account_id: str, run_sheet_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}RunSheets/{run_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_session_car_data_by_id(self, account_id: str, session_car_data_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_session_car_data_for_session_car(self, account_id: str, session_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}SessionCarDatas"

        param_lookup = dict()
        param_lookup["sessionId"] = session_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def update_session_car_data(self, account_id: str, session_car_data_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}", update_model)
        return response.is_success

    async def get_session_car_data_attachments_by_id(self, account_id: str, session_car_data_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def get_session_car_data_attachments_by_name(self, account_id: str, session_car_data_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def get_session_car_data_collection_item_attachments_by_id(self, account_id: str, session_car_data_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def get_session_car_data_collection_item_attachments_by_name(self, account_id: str, session_car_data_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[Mapping](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = response_json
        return ApiGetResult(response_object, True, None)

    async def update_session_car_data_attachment(self, account_id: str, session_car_data_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_session_car_data_collection_item_attachment(self, account_id: str, session_car_data_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_session_car_data_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_car_data_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_car_data_attachment(
            add_attached_file_response.account_id,
            session_car_data_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_car_data_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_car_data_id, None, None)

    async def _set_session_car_data_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_car_data_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_car_data_collection_item_attachment(
            add_attached_file_response.account_id,
            session_car_data_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_car_data_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_car_data_id, collection_name, collection_item_id, None, None)

    async def _upload_session_car_data_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_car_data_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_car_data_id, source_path, file_name)

            return await self._set_session_car_data_attachment_server_state_to_completed(add_attached_file_response, session_car_data_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_car_data_id, source_path, file_name, message=e)

    async def _upload_session_car_data_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_car_data_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_car_data_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_session_car_data_collection_item_attachment_server_state_to_completed(add_attached_file_response, session_car_data_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_car_data_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_session_car_data(self, account_id: str, session_car_data_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_car_data.
        
        :param account_id: str, 
        :param session_car_data_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_car_data_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_car_data_id, source_path, model.file_name)

        return await self._upload_session_car_data_attachment(parsed_response, session_car_data_id, file, model.file_name)

    async def add_attachment_to_session_car_data_collection_item(self, account_id: str, session_car_data_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_car_data_collection_item.
        
        :param account_id: str, 
        :param session_car_data_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_car_data_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_car_data_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_session_car_data_collection_item_attachment(parsed_response, session_car_data_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_session_car_data_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_car_data_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_car_data_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_session_car_data_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_car_data_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_car_data_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_session_car_data_attachment(self, account_id: str, session_car_data_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_session_car_data_collection_item_attachment(self, account_id: str, session_car_data_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionCarDatas/{session_car_data_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_setup_by_id(self, account_id: str, setup_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Setups/{setup_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_bulk_setups(self, account_id: str, event_ids: List[str], car_ids: List[str], setup_filter: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f'{self.api_endpoint}Setups/Bulk'

        param_lookup = {
            "eventIds": ','.join(event_ids),
            "carIds": ','.join(car_ids),
            "filter": setup_filter
        }
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_setups_for_event_car(self, account_id: str, event_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Setups"

        param_lookup = dict()
        param_lookup["eventId"] = event_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_setup(self, account_id: str, event_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Setups?eventId={event_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_setup(self, account_id: str, setup_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Setups/{setup_id}", update_model)
        return response.is_success

    async def delete_setup(self, account_id: str, setup_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Setups/{setup_id}")
        return response.is_success

    async def get_setup_attachments_by_id(self, account_id: str, setup_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Setups/{setup_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Setups/{setup_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_setup_attachments_by_name(self, account_id: str, setup_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_setup_collection_item_attachments_by_id(self, account_id: str, setup_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Setups/{setup_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Setups/{setup_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_setup_collection_item_attachments_by_name(self, account_id: str, setup_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_setup_attachment(self, account_id: str, setup_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_setup_collection_item_attachment(self, account_id: str, setup_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_setup_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, setup_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_setup_attachment(
            add_attached_file_response.account_id,
            setup_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, setup_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, setup_id, None, None)

    async def _set_setup_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, setup_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_setup_collection_item_attachment(
            add_attached_file_response.account_id,
            setup_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, setup_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, setup_id, collection_name, collection_item_id, None, None)

    async def _upload_setup_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, setup_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, setup_id, source_path, file_name)

            return await self._set_setup_attachment_server_state_to_completed(add_attached_file_response, setup_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, setup_id, source_path, file_name, message=e)

    async def _upload_setup_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, setup_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, setup_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_setup_collection_item_attachment_server_state_to_completed(add_attached_file_response, setup_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, setup_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_setup(self, account_id: str, setup_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to setup.
        
        :param account_id: str, 
        :param setup_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, setup_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, setup_id, source_path, model.file_name)

        return await self._upload_setup_attachment(parsed_response, setup_id, file, model.file_name)

    async def add_attachment_to_setup_collection_item(self, account_id: str, setup_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to setup_collection_item.
        
        :param account_id: str, 
        :param setup_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, setup_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, setup_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_setup_collection_item_attachment(parsed_response, setup_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_setup_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_setup_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_setup_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_setup_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_setup_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_setup_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_setup_attachment(self, account_id: str, setup_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_setup_collection_item_attachment(self, account_id: str, setup_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Setups/{setup_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_track_by_id(self, account_id: str, track_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Tracks/{track_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_tracks(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Tracks"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_track(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Tracks?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_track(self, account_id: str, track_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Tracks/{track_id}", update_model)
        return response.is_success

    async def delete_track(self, account_id: str, track_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Tracks/{track_id}")
        return response.is_success

    async def get_track_attachments_by_id(self, account_id: str, track_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Tracks/{track_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Tracks/{track_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_attachments_by_name(self, account_id: str, track_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_collection_item_attachments_by_id(self, account_id: str, track_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Tracks/{track_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Tracks/{track_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_collection_item_attachments_by_name(self, account_id: str, track_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_track_attachment(self, account_id: str, track_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_track_collection_item_attachment(self, account_id: str, track_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_track_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_attachment(
            add_attached_file_response.account_id,
            track_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_id, None, None)

    async def _set_track_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_collection_item_attachment(
            add_attached_file_response.account_id,
            track_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_id, collection_name, collection_item_id, None, None)

    async def _upload_track_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_id, source_path, file_name)

            return await self._set_track_attachment_server_state_to_completed(add_attached_file_response, track_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_id, source_path, file_name, message=e)

    async def _upload_track_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_track_collection_item_attachment_server_state_to_completed(add_attached_file_response, track_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_track(self, account_id: str, track_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track.
        
        :param account_id: str, 
        :param track_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_id, source_path, model.file_name)

        return await self._upload_track_attachment(parsed_response, track_id, file, model.file_name)

    async def add_attachment_to_track_collection_item(self, account_id: str, track_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_collection_item.
        
        :param account_id: str, 
        :param track_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_track_collection_item_attachment(parsed_response, track_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_track_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_track_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_track_attachment(self, account_id: str, track_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_track_collection_item_attachment(self, account_id: str, track_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Tracks/{track_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_tyre_by_id(self, account_id: str, tyre_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Tyres/{tyre_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_tyres(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Tyres/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_tyre(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}Tyres?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre(self, account_id: str, tyre_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}", update_model)
        return response.is_success

    async def delete_tyre(self, account_id: str, tyre_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}")
        return response.is_success

    async def get_tyre_attachments_by_id(self, account_id: str, tyre_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Tyres/{tyre_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Tyres/{tyre_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_attachments_by_name(self, account_id: str, tyre_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_collection_item_attachments_by_id(self, account_id: str, tyre_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Tyres/{tyre_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Tyres/{tyre_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_collection_item_attachments_by_name(self, account_id: str, tyre_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_tyre_attachment(self, account_id: str, tyre_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_tyre_collection_item_attachment(self, account_id: str, tyre_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_tyre_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_attachment(
            add_attached_file_response.account_id,
            tyre_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_id, None, None)

    async def _set_tyre_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_collection_item_attachment(
            add_attached_file_response.account_id,
            tyre_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_id, collection_name, collection_item_id, None, None)

    async def _upload_tyre_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_id, source_path, file_name)

            return await self._set_tyre_attachment_server_state_to_completed(add_attached_file_response, tyre_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_id, source_path, file_name, message=e)

    async def _upload_tyre_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_tyre_collection_item_attachment_server_state_to_completed(add_attached_file_response, tyre_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_tyre(self, account_id: str, tyre_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre.
        
        :param account_id: str, 
        :param tyre_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_id, source_path, model.file_name)

        return await self._upload_tyre_attachment(parsed_response, tyre_id, file, model.file_name)

    async def add_attachment_to_tyre_collection_item(self, account_id: str, tyre_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_collection_item.
        
        :param account_id: str, 
        :param tyre_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_tyre_collection_item_attachment(parsed_response, tyre_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_tyre_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_tyre_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_tyre_attachment(self, account_id: str, tyre_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_tyre_collection_item_attachment(self, account_id: str, tyre_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Tyres/{tyre_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_tyre_set_by_id(self, account_id: str, tyre_set_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TyreSets/{tyre_set_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_tyre_sets_for_event_car(self, account_id: str, event_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}TyreSets"

        param_lookup = dict()
        param_lookup["eventId"] = event_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_tyre_set(self, account_id: str, event_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSets?eventId={event_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre_set(self, account_id: str, tyre_set_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}", update_model)
        return response.is_success

    async def delete_tyre_set(self, account_id: str, tyre_set_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}")
        return response.is_success

    async def get_tyre_set_attachments_by_id(self, account_id: str, tyre_set_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreSets/{tyre_set_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreSets/{tyre_set_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_set_attachments_by_name(self, account_id: str, tyre_set_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_set_collection_item_attachments_by_id(self, account_id: str, tyre_set_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreSets/{tyre_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreSets/{tyre_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_set_collection_item_attachments_by_name(self, account_id: str, tyre_set_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_tyre_set_attachment(self, account_id: str, tyre_set_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_tyre_set_collection_item_attachment(self, account_id: str, tyre_set_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_tyre_set_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_set_attachment(
            add_attached_file_response.account_id,
            tyre_set_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_set_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_set_id, None, None)

    async def _set_tyre_set_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_set_collection_item_attachment(
            add_attached_file_response.account_id,
            tyre_set_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_set_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_set_id, collection_name, collection_item_id, None, None)

    async def _upload_tyre_set_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_id, source_path, file_name)

            return await self._set_tyre_set_attachment_server_state_to_completed(add_attached_file_response, tyre_set_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_id, source_path, file_name, message=e)

    async def _upload_tyre_set_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_tyre_set_collection_item_attachment_server_state_to_completed(add_attached_file_response, tyre_set_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_tyre_set(self, account_id: str, tyre_set_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_set.
        
        :param account_id: str, 
        :param tyre_set_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_set_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_set_id, source_path, model.file_name)

        return await self._upload_tyre_set_attachment(parsed_response, tyre_set_id, file, model.file_name)

    async def add_attachment_to_tyre_set_collection_item(self, account_id: str, tyre_set_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_set_collection_item.
        
        :param account_id: str, 
        :param tyre_set_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_set_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_set_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_tyre_set_collection_item_attachment(parsed_response, tyre_set_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_tyre_set_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_set_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_set_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_tyre_set_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_set_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_set_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_tyre_set_attachment(self, account_id: str, tyre_set_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_tyre_set_collection_item_attachment(self, account_id: str, tyre_set_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSets/{tyre_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_tyre_set_pressure_adjustment_by_id(self, account_id: str, tyre_set_pressure_adjustment_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_tyre_set_pressure_adjustment(self, account_id: str, tyre_set_id: str, pressure_adjust_type: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments?tyreSetId={tyre_set_id}&pressureAdjustType={pressure_adjust_type}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre_set_pressure_adjustment(self, account_id: str, tyre_set_pressure_adjustment_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}", update_model)
        return response.is_success

    async def delete_tyre_set_pressure_adjustment(self, account_id: str, tyre_set_pressure_adjustment_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}")
        return response.is_success

    async def get_tyre_set_pressure_adjustment_attachments_by_id(self, account_id: str, tyre_set_pressure_adjustment_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_set_pressure_adjustment_attachments_by_name(self, account_id: str, tyre_set_pressure_adjustment_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_set_pressure_adjustment_collection_item_attachments_by_id(self, account_id: str, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_set_pressure_adjustment_collection_item_attachments_by_name(self, account_id: str, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_tyre_set_pressure_adjustment_attachment(self, account_id: str, tyre_set_pressure_adjustment_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_tyre_set_pressure_adjustment_collection_item_attachment(self, account_id: str, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_tyre_set_pressure_adjustment_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_pressure_adjustment_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_set_pressure_adjustment_attachment(
            add_attached_file_response.account_id,
            tyre_set_pressure_adjustment_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_set_pressure_adjustment_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_set_pressure_adjustment_id, None, None)

    async def _set_tyre_set_pressure_adjustment_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_set_pressure_adjustment_collection_item_attachment(
            add_attached_file_response.account_id,
            tyre_set_pressure_adjustment_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, None, None)

    async def _upload_tyre_set_pressure_adjustment_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_pressure_adjustment_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_pressure_adjustment_id, source_path, file_name)

            return await self._set_tyre_set_pressure_adjustment_attachment_server_state_to_completed(add_attached_file_response, tyre_set_pressure_adjustment_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_pressure_adjustment_id, source_path, file_name, message=e)

    async def _upload_tyre_set_pressure_adjustment_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_tyre_set_pressure_adjustment_collection_item_attachment_server_state_to_completed(add_attached_file_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_tyre_set_pressure_adjustment(self, account_id: str, tyre_set_pressure_adjustment_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_set_pressure_adjustment.
        
        :param account_id: str, 
        :param tyre_set_pressure_adjustment_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_set_pressure_adjustment_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_set_pressure_adjustment_id, source_path, model.file_name)

        return await self._upload_tyre_set_pressure_adjustment_attachment(parsed_response, tyre_set_pressure_adjustment_id, file, model.file_name)

    async def add_attachment_to_tyre_set_pressure_adjustment_collection_item(self, account_id: str, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_set_pressure_adjustment_collection_item.
        
        :param account_id: str, 
        :param tyre_set_pressure_adjustment_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_tyre_set_pressure_adjustment_collection_item_attachment(parsed_response, tyre_set_pressure_adjustment_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_tyre_set_pressure_adjustment_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_set_pressure_adjustment_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_set_pressure_adjustment_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_tyre_set_pressure_adjustment_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_set_pressure_adjustment_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_set_pressure_adjustment_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_tyre_set_pressure_adjustment_attachment(self, account_id: str, tyre_set_pressure_adjustment_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_tyre_set_pressure_adjustment_collection_item_attachment(self, account_id: str, tyre_set_pressure_adjustment_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSetPressureAdjustments/{tyre_set_pressure_adjustment_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_tyre_specification_by_id(self, account_id: str, tyre_specification_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_tyre_specifications(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}TyreSpecifications"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_tyre_specification(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSpecifications?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre_specification(self, account_id: str, tyre_specification_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}", update_model)
        return response.is_success

    async def delete_tyre_specification(self, account_id: str, tyre_specification_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}")
        return response.is_success

    async def get_tyre_specification_attachments_by_id(self, account_id: str, tyre_specification_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_specification_attachments_by_name(self, account_id: str, tyre_specification_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_specification_collection_item_attachments_by_id(self, account_id: str, tyre_specification_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_specification_collection_item_attachments_by_name(self, account_id: str, tyre_specification_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_tyre_specification_attachment(self, account_id: str, tyre_specification_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_tyre_specification_collection_item_attachment(self, account_id: str, tyre_specification_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_tyre_specification_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_specification_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_specification_attachment(
            add_attached_file_response.account_id,
            tyre_specification_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_specification_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_specification_id, None, None)

    async def _set_tyre_specification_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_specification_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_specification_collection_item_attachment(
            add_attached_file_response.account_id,
            tyre_specification_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_specification_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_specification_id, collection_name, collection_item_id, None, None)

    async def _upload_tyre_specification_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_specification_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_specification_id, source_path, file_name)

            return await self._set_tyre_specification_attachment_server_state_to_completed(add_attached_file_response, tyre_specification_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_specification_id, source_path, file_name, message=e)

    async def _upload_tyre_specification_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_specification_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_specification_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_tyre_specification_collection_item_attachment_server_state_to_completed(add_attached_file_response, tyre_specification_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_specification_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_tyre_specification(self, account_id: str, tyre_specification_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_specification.
        
        :param account_id: str, 
        :param tyre_specification_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_specification_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_specification_id, source_path, model.file_name)

        return await self._upload_tyre_specification_attachment(parsed_response, tyre_specification_id, file, model.file_name)

    async def add_attachment_to_tyre_specification_collection_item(self, account_id: str, tyre_specification_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_specification_collection_item.
        
        :param account_id: str, 
        :param tyre_specification_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_specification_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_specification_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_tyre_specification_collection_item_attachment(parsed_response, tyre_specification_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_tyre_specification_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_specification_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_specification_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_tyre_specification_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_specification_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_specification_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_tyre_specification_attachment(self, account_id: str, tyre_specification_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_tyre_specification_collection_item_attachment(self, account_id: str, tyre_specification_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreSpecifications/{tyre_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_tyre_wear_sheet_by_id(self, account_id: str, tyre_wear_sheet_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_tyre_wear_sheets_for_event_car(self, account_id: str, event_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}TyreWearSheets"

        param_lookup = dict()
        param_lookup["eventId"] = event_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_tyre_wear_sheet(self, account_id: str, event_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TyreWearSheets?eventId={event_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre_wear_sheet(self, account_id: str, tyre_wear_sheet_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}", update_model)
        return response.is_success

    async def delete_tyre_wear_sheet(self, account_id: str, tyre_wear_sheet_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}")
        return response.is_success

    async def get_tyre_wear_sheet_attachments_by_id(self, account_id: str, tyre_wear_sheet_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_wear_sheet_attachments_by_name(self, account_id: str, tyre_wear_sheet_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_wear_sheet_collection_item_attachments_by_id(self, account_id: str, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_wear_sheet_collection_item_attachments_by_name(self, account_id: str, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_tyre_wear_sheet_attachment(self, account_id: str, tyre_wear_sheet_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_tyre_wear_sheet_collection_item_attachment(self, account_id: str, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_tyre_wear_sheet_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_sheet_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_wear_sheet_attachment(
            add_attached_file_response.account_id,
            tyre_wear_sheet_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_wear_sheet_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_wear_sheet_id, None, None)

    async def _set_tyre_wear_sheet_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_wear_sheet_collection_item_attachment(
            add_attached_file_response.account_id,
            tyre_wear_sheet_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_wear_sheet_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_wear_sheet_id, collection_name, collection_item_id, None, None)

    async def _upload_tyre_wear_sheet_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_sheet_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_sheet_id, source_path, file_name)

            return await self._set_tyre_wear_sheet_attachment_server_state_to_completed(add_attached_file_response, tyre_wear_sheet_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_sheet_id, source_path, file_name, message=e)

    async def _upload_tyre_wear_sheet_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_sheet_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_tyre_wear_sheet_collection_item_attachment_server_state_to_completed(add_attached_file_response, tyre_wear_sheet_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_sheet_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_tyre_wear_sheet(self, account_id: str, tyre_wear_sheet_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_wear_sheet.
        
        :param account_id: str, 
        :param tyre_wear_sheet_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_wear_sheet_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_wear_sheet_id, source_path, model.file_name)

        return await self._upload_tyre_wear_sheet_attachment(parsed_response, tyre_wear_sheet_id, file, model.file_name)

    async def add_attachment_to_tyre_wear_sheet_collection_item(self, account_id: str, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_wear_sheet_collection_item.
        
        :param account_id: str, 
        :param tyre_wear_sheet_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_wear_sheet_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_wear_sheet_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_tyre_wear_sheet_collection_item_attachment(parsed_response, tyre_wear_sheet_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_tyre_wear_sheet_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_wear_sheet_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_wear_sheet_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_tyre_wear_sheet_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_wear_sheet_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_wear_sheet_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_tyre_wear_sheet_attachment(self, account_id: str, tyre_wear_sheet_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_tyre_wear_sheet_collection_item_attachment(self, account_id: str, tyre_wear_sheet_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreWearSheets/{tyre_wear_sheet_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_account_options_by_id(self, account_id: str, account_options_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}AccountOptions/{account_options_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_account_options(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}AccountOptions"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_account_options(self, account_id: str, account_options_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AccountOptions/{account_options_id}", update_model)
        return response.is_success

    async def get_account_options_attachments_by_id(self, account_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AccountOptions/{account_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AccountOptions/{account_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_account_options_attachments_by_name(self, account_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_account_options_collection_item_attachments_by_id(self, account_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AccountOptions/{account_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AccountOptions/{account_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_account_options_collection_item_attachments_by_name(self, account_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_account_options_attachment(self, account_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_account_options_collection_item_attachment(self, account_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_account_options_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_account_options_attachment(
            add_attached_file_response.account_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, add_attached_file_response.account_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, add_attached_file_response.account_id, None, None)

    async def _set_account_options_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_account_options_collection_item_attachment(
            add_attached_file_response.account_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, add_attached_file_response.account_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, add_attached_file_response.account_id, collection_name, collection_item_id, None, None)

    async def _upload_account_options_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, add_attached_file_response.account_id, source_path, file_name)

            return await self._set_account_options_attachment_server_state_to_completed(add_attached_file_response)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, add_attached_file_response.account_id, source_path, file_name, message=e)

    async def _upload_account_options_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, add_attached_file_response.account_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_account_options_collection_item_attachment_server_state_to_completed(add_attached_file_response, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, add_attached_file_response.account_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_account_options(self, account_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to account_options.
        
        :param account_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, account_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, account_id, source_path, model.file_name)

        return await self._upload_account_options_attachment(parsed_response, file, model.file_name)

    async def add_attachment_to_account_options_collection_item(self, account_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to account_options_collection_item.
        
        :param account_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, account_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, account_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_account_options_collection_item_attachment(parsed_response, collection_name, collection_item_id, file, model.file_name)

    async def retry_account_options_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_account_options_attachment(add_attachment_result.add_attached_file_response, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_account_options_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_account_options_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_account_options_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_account_options_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_account_options_attachment(self, account_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_account_options_collection_item_attachment(self, account_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AccountOptions/{account_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_driver_by_id(self, account_id: str, driver_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Drivers/{driver_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_drivers(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Drivers"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_driver(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Drivers?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_driver(self, account_id: str, driver_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}", update_model)
        return response.is_success

    async def delete_driver(self, account_id: str, driver_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}")
        return response.is_success

    async def get_driver_attachments_by_id(self, account_id: str, driver_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Drivers/{driver_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Drivers/{driver_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_driver_attachments_by_name(self, account_id: str, driver_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_driver_collection_item_attachments_by_id(self, account_id: str, driver_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Drivers/{driver_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Drivers/{driver_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_driver_collection_item_attachments_by_name(self, account_id: str, driver_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_driver_attachment(self, account_id: str, driver_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_driver_collection_item_attachment(self, account_id: str, driver_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_driver_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, driver_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_driver_attachment(
            add_attached_file_response.account_id,
            driver_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, driver_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, driver_id, None, None)

    async def _set_driver_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, driver_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_driver_collection_item_attachment(
            add_attached_file_response.account_id,
            driver_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, driver_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, driver_id, collection_name, collection_item_id, None, None)

    async def _upload_driver_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, driver_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, driver_id, source_path, file_name)

            return await self._set_driver_attachment_server_state_to_completed(add_attached_file_response, driver_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, driver_id, source_path, file_name, message=e)

    async def _upload_driver_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, driver_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, driver_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_driver_collection_item_attachment_server_state_to_completed(add_attached_file_response, driver_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, driver_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_driver(self, account_id: str, driver_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to driver.
        
        :param account_id: str, 
        :param driver_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, driver_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, driver_id, source_path, model.file_name)

        return await self._upload_driver_attachment(parsed_response, driver_id, file, model.file_name)

    async def add_attachment_to_driver_collection_item(self, account_id: str, driver_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to driver_collection_item.
        
        :param account_id: str, 
        :param driver_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, driver_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, driver_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_driver_collection_item_attachment(parsed_response, driver_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_driver_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_driver_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_driver_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_driver_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_driver_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_driver_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_driver_attachment(self, account_id: str, driver_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_driver_collection_item_attachment(self, account_id: str, driver_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Drivers/{driver_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_xml_export_profile_by_id(self, account_id: str, xml_export_profile_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}XmlExportProfiles/{xml_export_profile_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_xml_export_profiles(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}XmlExportProfiles"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_xml_export_profile(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}XmlExportProfiles?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_xml_export_profile(self, account_id: str, xml_export_profile_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}XmlExportProfiles/{xml_export_profile_id}", update_model)
        return response.is_success

    async def get_xml_export_file_by_id(self, account_id: str, xml_export_file_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}XmlExportFiles/{xml_export_file_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_xml_export_file(self, account_id: str, xml_export_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}XmlExportFiles/{xml_export_file_id}", update_model)
        return response.is_success

    async def get_xml_export_node_by_id(self, account_id: str, xml_export_node_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}XmlExportNodes/{xml_export_node_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_xml_export_node(self, account_id: str, xml_export_file_id: str, xml_value_type: int, is_scope_change_node: bool, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}XmlExportNodes?xmlExportFileId={xml_export_file_id}&xmlValueType={xml_value_type}&isScopeChangeNode={is_scope_change_node}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_xml_export_node(self, account_id: str, xml_export_node_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}XmlExportNodes/{xml_export_node_id}", update_model)
        return response.is_success

    async def delete_xml_export_node(self, account_id: str, xml_export_node_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}XmlExportNodes/{xml_export_node_id}")
        return response.is_success

    async def get_xml_export_attribute_by_id(self, account_id: str, xml_export_attribute_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}XmlExportAttributes/{xml_export_attribute_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_xml_export_attribute(self, account_id: str, xml_export_node_id: str, xml_value_type: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}XmlExportAttributes?xmlExportNodeId={xml_export_node_id}&xmlValueType={xml_value_type}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_xml_export_attribute(self, account_id: str, xml_export_attribute_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}XmlExportAttributes/{xml_export_attribute_id}", update_model)
        return response.is_success

    async def delete_xml_export_attribute(self, account_id: str, xml_export_attribute_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}XmlExportAttributes/{xml_export_attribute_id}")
        return response.is_success

    async def get_excel_export_profile_by_id(self, account_id: str, excel_export_profile_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ExcelExportProfiles/{excel_export_profile_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_excel_export_profiles(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}ExcelExportProfiles"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_excel_export_profile(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ExcelExportProfiles?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_excel_export_profile(self, account_id: str, excel_export_profile_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ExcelExportProfiles/{excel_export_profile_id}", update_model)
        return response.is_success

    async def get_excel_export_file_by_id(self, account_id: str, excel_export_file_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ExcelExportFiles/{excel_export_file_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_excel_export_file(self, account_id: str, excel_export_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ExcelExportFiles/{excel_export_file_id}", update_model)
        return response.is_success

    async def get_excel_export_worksheet_by_id(self, account_id: str, excel_export_worksheet_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ExcelExportWorksheets/{excel_export_worksheet_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_excel_export_worksheet(self, account_id: str, excel_export_worksheet_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ExcelExportWorksheets/{excel_export_worksheet_id}", update_model)
        return response.is_success

    async def delete_excel_export_worksheet(self, account_id: str, excel_export_worksheet_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ExcelExportWorksheets/{excel_export_worksheet_id}")
        return response.is_success

    async def get_excel_export_cell_by_id(self, account_id: str, excel_export_cell_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ExcelExportCells/{excel_export_cell_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_excel_export_cell(self, account_id: str, excel_export_worksheet_id: str, row_index: int, column_index: int, row_linear_term: int, column_linear_term: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ExcelExportCells?excelExportWorksheetId={excel_export_worksheet_id}&rowIndex={row_index}&columnIndex={column_index}&rowLinearTerm={row_linear_term}&columnLinearTerm={column_linear_term}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_excel_export_cell(self, account_id: str, excel_export_cell_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ExcelExportCells/{excel_export_cell_id}", update_model)
        return response.is_success

    async def delete_excel_export_cell(self, account_id: str, excel_export_cell_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ExcelExportCells/{excel_export_cell_id}")
        return response.is_success

    async def get_lap_sector_by_id(self, account_id: str, lap_sector_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}LapSectors/{lap_sector_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_lap_sector(self, account_id: str, lap_sector_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}", update_model)
        return response.is_success

    async def get_lap_sector_attachments_by_id(self, account_id: str, lap_sector_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapSectors/{lap_sector_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapSectors/{lap_sector_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_sector_attachments_by_name(self, account_id: str, lap_sector_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_sector_collection_item_attachments_by_id(self, account_id: str, lap_sector_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapSectors/{lap_sector_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapSectors/{lap_sector_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_sector_collection_item_attachments_by_name(self, account_id: str, lap_sector_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_lap_sector_attachment(self, account_id: str, lap_sector_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_lap_sector_collection_item_attachment(self, account_id: str, lap_sector_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_lap_sector_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_sector_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_sector_attachment(
            add_attached_file_response.account_id,
            lap_sector_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_sector_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_sector_id, None, None)

    async def _set_lap_sector_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_sector_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_sector_collection_item_attachment(
            add_attached_file_response.account_id,
            lap_sector_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_sector_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_sector_id, collection_name, collection_item_id, None, None)

    async def _upload_lap_sector_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_sector_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_sector_id, source_path, file_name)

            return await self._set_lap_sector_attachment_server_state_to_completed(add_attached_file_response, lap_sector_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_sector_id, source_path, file_name, message=e)

    async def _upload_lap_sector_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_sector_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_sector_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_lap_sector_collection_item_attachment_server_state_to_completed(add_attached_file_response, lap_sector_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_sector_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_lap_sector(self, account_id: str, lap_sector_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_sector.
        
        :param account_id: str, 
        :param lap_sector_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_sector_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_sector_id, source_path, model.file_name)

        return await self._upload_lap_sector_attachment(parsed_response, lap_sector_id, file, model.file_name)

    async def add_attachment_to_lap_sector_collection_item(self, account_id: str, lap_sector_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_sector_collection_item.
        
        :param account_id: str, 
        :param lap_sector_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_sector_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_sector_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_lap_sector_collection_item_attachment(parsed_response, lap_sector_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_lap_sector_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_sector_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_sector_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_lap_sector_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_sector_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_sector_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_lap_sector_attachment(self, account_id: str, lap_sector_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_lap_sector_collection_item_attachment(self, account_id: str, lap_sector_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapSectors/{lap_sector_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_car_manufacturer_by_id(self, account_id: str, car_manufacturer_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_car_manufacturers(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}CarManufacturers"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_car_manufacturer(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}CarManufacturers?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_car_manufacturer(self, account_id: str, car_manufacturer_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}", update_model)
        return response.is_success

    async def delete_car_manufacturer(self, account_id: str, car_manufacturer_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}")
        return response.is_success

    async def get_car_manufacturer_attachments_by_id(self, account_id: str, car_manufacturer_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_manufacturer_attachments_by_name(self, account_id: str, car_manufacturer_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_manufacturer_collection_item_attachments_by_id(self, account_id: str, car_manufacturer_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_manufacturer_collection_item_attachments_by_name(self, account_id: str, car_manufacturer_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_car_manufacturer_attachment(self, account_id: str, car_manufacturer_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_car_manufacturer_collection_item_attachment(self, account_id: str, car_manufacturer_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_car_manufacturer_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, car_manufacturer_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_car_manufacturer_attachment(
            add_attached_file_response.account_id,
            car_manufacturer_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, car_manufacturer_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, car_manufacturer_id, None, None)

    async def _set_car_manufacturer_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, car_manufacturer_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_car_manufacturer_collection_item_attachment(
            add_attached_file_response.account_id,
            car_manufacturer_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, car_manufacturer_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, car_manufacturer_id, collection_name, collection_item_id, None, None)

    async def _upload_car_manufacturer_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, car_manufacturer_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_manufacturer_id, source_path, file_name)

            return await self._set_car_manufacturer_attachment_server_state_to_completed(add_attached_file_response, car_manufacturer_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_manufacturer_id, source_path, file_name, message=e)

    async def _upload_car_manufacturer_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, car_manufacturer_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_manufacturer_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_car_manufacturer_collection_item_attachment_server_state_to_completed(add_attached_file_response, car_manufacturer_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_manufacturer_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_car_manufacturer(self, account_id: str, car_manufacturer_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to car_manufacturer.
        
        :param account_id: str, 
        :param car_manufacturer_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, car_manufacturer_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, car_manufacturer_id, source_path, model.file_name)

        return await self._upload_car_manufacturer_attachment(parsed_response, car_manufacturer_id, file, model.file_name)

    async def add_attachment_to_car_manufacturer_collection_item(self, account_id: str, car_manufacturer_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to car_manufacturer_collection_item.
        
        :param account_id: str, 
        :param car_manufacturer_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, car_manufacturer_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, car_manufacturer_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_car_manufacturer_collection_item_attachment(parsed_response, car_manufacturer_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_car_manufacturer_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_car_manufacturer_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_car_manufacturer_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_car_manufacturer_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_car_manufacturer_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_car_manufacturer_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_car_manufacturer_attachment(self, account_id: str, car_manufacturer_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_car_manufacturer_collection_item_attachment(self, account_id: str, car_manufacturer_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}CarManufacturers/{car_manufacturer_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_car_model_by_id(self, account_id: str, car_model_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}CarModels/{car_model_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_car_model(self, account_id: str, car_manufacturer_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}CarModels?carManufacturerId={car_manufacturer_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_car_model(self, account_id: str, car_model_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}", update_model)
        return response.is_success

    async def delete_car_model(self, account_id: str, car_model_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}")
        return response.is_success

    async def get_car_model_attachments_by_id(self, account_id: str, car_model_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}CarModels/{car_model_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}CarModels/{car_model_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_model_attachments_by_name(self, account_id: str, car_model_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_model_collection_item_attachments_by_id(self, account_id: str, car_model_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}CarModels/{car_model_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}CarModels/{car_model_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_car_model_collection_item_attachments_by_name(self, account_id: str, car_model_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_car_model_attachment(self, account_id: str, car_model_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_car_model_collection_item_attachment(self, account_id: str, car_model_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_car_model_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, car_model_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_car_model_attachment(
            add_attached_file_response.account_id,
            car_model_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, car_model_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, car_model_id, None, None)

    async def _set_car_model_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, car_model_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_car_model_collection_item_attachment(
            add_attached_file_response.account_id,
            car_model_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, car_model_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, car_model_id, collection_name, collection_item_id, None, None)

    async def _upload_car_model_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, car_model_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_model_id, source_path, file_name)

            return await self._set_car_model_attachment_server_state_to_completed(add_attached_file_response, car_model_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_model_id, source_path, file_name, message=e)

    async def _upload_car_model_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, car_model_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_model_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_car_model_collection_item_attachment_server_state_to_completed(add_attached_file_response, car_model_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, car_model_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_car_model(self, account_id: str, car_model_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to car_model.
        
        :param account_id: str, 
        :param car_model_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, car_model_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, car_model_id, source_path, model.file_name)

        return await self._upload_car_model_attachment(parsed_response, car_model_id, file, model.file_name)

    async def add_attachment_to_car_model_collection_item(self, account_id: str, car_model_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to car_model_collection_item.
        
        :param account_id: str, 
        :param car_model_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, car_model_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, car_model_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_car_model_collection_item_attachment(parsed_response, car_model_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_car_model_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_car_model_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_car_model_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_car_model_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_car_model_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_car_model_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_car_model_attachment(self, account_id: str, car_model_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_car_model_collection_item_attachment(self, account_id: str, car_model_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}CarModels/{car_model_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_category_by_id(self, account_id: str, category_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Categories/{category_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_categories(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Categories"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_category(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Categories?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_category(self, account_id: str, category_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Categories/{category_id}", update_model)
        return response.is_success

    async def delete_category(self, account_id: str, category_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Categories/{category_id}")
        return response.is_success

    async def get_category_attachments_by_id(self, account_id: str, category_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Categories/{category_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Categories/{category_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_category_attachments_by_name(self, account_id: str, category_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_category_collection_item_attachments_by_id(self, account_id: str, category_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Categories/{category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Categories/{category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_category_collection_item_attachments_by_name(self, account_id: str, category_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_category_attachment(self, account_id: str, category_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_category_collection_item_attachment(self, account_id: str, category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_category_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, category_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_category_attachment(
            add_attached_file_response.account_id,
            category_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, category_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, category_id, None, None)

    async def _set_category_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, category_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_category_collection_item_attachment(
            add_attached_file_response.account_id,
            category_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, category_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, category_id, collection_name, collection_item_id, None, None)

    async def _upload_category_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, category_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, category_id, source_path, file_name)

            return await self._set_category_attachment_server_state_to_completed(add_attached_file_response, category_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, category_id, source_path, file_name, message=e)

    async def _upload_category_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, category_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, category_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_category_collection_item_attachment_server_state_to_completed(add_attached_file_response, category_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, category_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_category(self, account_id: str, category_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to category.
        
        :param account_id: str, 
        :param category_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, category_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, category_id, source_path, model.file_name)

        return await self._upload_category_attachment(parsed_response, category_id, file, model.file_name)

    async def add_attachment_to_category_collection_item(self, account_id: str, category_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to category_collection_item.
        
        :param account_id: str, 
        :param category_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, category_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, category_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_category_collection_item_attachment(parsed_response, category_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_category_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_category_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_category_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_category_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_category_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_category_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_category_attachment(self, account_id: str, category_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_category_collection_item_attachment(self, account_id: str, category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Categories/{category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_category_by_id(self, account_id: str, issue_list_category_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_issue_list_categories(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}IssueListCategories"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_category(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListCategories?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_category(self, account_id: str, issue_list_category_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}", update_model)
        return response.is_success

    async def delete_issue_list_category(self, account_id: str, issue_list_category_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}")
        return response.is_success

    async def get_issue_list_category_attachments_by_id(self, account_id: str, issue_list_category_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_category_attachments_by_name(self, account_id: str, issue_list_category_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_category_collection_item_attachments_by_id(self, account_id: str, issue_list_category_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_category_collection_item_attachments_by_name(self, account_id: str, issue_list_category_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_category_attachment(self, account_id: str, issue_list_category_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_category_collection_item_attachment(self, account_id: str, issue_list_category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_category_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_category_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_category_attachment(
            add_attached_file_response.account_id,
            issue_list_category_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_category_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_category_id, None, None)

    async def _set_issue_list_category_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_category_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_category_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_category_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_category_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_category_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_category_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_category_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_category_id, source_path, file_name)

            return await self._set_issue_list_category_attachment_server_state_to_completed(add_attached_file_response, issue_list_category_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_category_id, source_path, file_name, message=e)

    async def _upload_issue_list_category_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_category_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_category_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_category_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_category_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_category_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_category(self, account_id: str, issue_list_category_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_category.
        
        :param account_id: str, 
        :param issue_list_category_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_category_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_category_id, source_path, model.file_name)

        return await self._upload_issue_list_category_attachment(parsed_response, issue_list_category_id, file, model.file_name)

    async def add_attachment_to_issue_list_category_collection_item(self, account_id: str, issue_list_category_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_category_collection_item.
        
        :param account_id: str, 
        :param issue_list_category_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_category_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_category_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_category_collection_item_attachment(parsed_response, issue_list_category_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_category_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_category_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_category_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_category_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_category_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_category_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_category_attachment(self, account_id: str, issue_list_category_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_category_collection_item_attachment(self, account_id: str, issue_list_category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListCategories/{issue_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_job_list_category_by_id(self, account_id: str, job_list_category_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}JobListCategories/{job_list_category_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_job_list_categories(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}JobListCategories"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_job_list_category(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}JobListCategories?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_job_list_category(self, account_id: str, job_list_category_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}", update_model)
        return response.is_success

    async def delete_job_list_category(self, account_id: str, job_list_category_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}")
        return response.is_success

    async def get_job_list_category_attachments_by_id(self, account_id: str, job_list_category_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_category_attachments_by_name(self, account_id: str, job_list_category_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_category_collection_item_attachments_by_id(self, account_id: str, job_list_category_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_category_collection_item_attachments_by_name(self, account_id: str, job_list_category_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_job_list_category_attachment(self, account_id: str, job_list_category_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_job_list_category_collection_item_attachment(self, account_id: str, job_list_category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_job_list_category_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_category_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_job_list_category_attachment(
            add_attached_file_response.account_id,
            job_list_category_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, job_list_category_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, job_list_category_id, None, None)

    async def _set_job_list_category_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_category_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_job_list_category_collection_item_attachment(
            add_attached_file_response.account_id,
            job_list_category_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, job_list_category_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, job_list_category_id, collection_name, collection_item_id, None, None)

    async def _upload_job_list_category_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_category_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_category_id, source_path, file_name)

            return await self._set_job_list_category_attachment_server_state_to_completed(add_attached_file_response, job_list_category_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_category_id, source_path, file_name, message=e)

    async def _upload_job_list_category_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_category_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_category_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_job_list_category_collection_item_attachment_server_state_to_completed(add_attached_file_response, job_list_category_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_category_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_job_list_category(self, account_id: str, job_list_category_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to job_list_category.
        
        :param account_id: str, 
        :param job_list_category_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, job_list_category_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, job_list_category_id, source_path, model.file_name)

        return await self._upload_job_list_category_attachment(parsed_response, job_list_category_id, file, model.file_name)

    async def add_attachment_to_job_list_category_collection_item(self, account_id: str, job_list_category_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to job_list_category_collection_item.
        
        :param account_id: str, 
        :param job_list_category_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, job_list_category_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, job_list_category_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_job_list_category_collection_item_attachment(parsed_response, job_list_category_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_job_list_category_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_job_list_category_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_job_list_category_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_job_list_category_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_job_list_category_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_job_list_category_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_job_list_category_attachment(self, account_id: str, job_list_category_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_job_list_category_collection_item_attachment(self, account_id: str, job_list_category_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListCategories/{job_list_category_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_job_list_template_by_id(self, account_id: str, job_list_template_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}JobListTemplates/{job_list_template_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_job_list_templates(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}JobListTemplates"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_job_list_template(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}JobListTemplates?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_job_list_template(self, account_id: str, job_list_template_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}", update_model)
        return response.is_success

    async def delete_job_list_template(self, account_id: str, job_list_template_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}")
        return response.is_success

    async def get_job_list_template_attachments_by_id(self, account_id: str, job_list_template_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_template_attachments_by_name(self, account_id: str, job_list_template_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_template_collection_item_attachments_by_id(self, account_id: str, job_list_template_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_template_collection_item_attachments_by_name(self, account_id: str, job_list_template_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_job_list_template_attachment(self, account_id: str, job_list_template_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_job_list_template_collection_item_attachment(self, account_id: str, job_list_template_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_job_list_template_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_job_list_template_attachment(
            add_attached_file_response.account_id,
            job_list_template_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, job_list_template_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, job_list_template_id, None, None)

    async def _set_job_list_template_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_job_list_template_collection_item_attachment(
            add_attached_file_response.account_id,
            job_list_template_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, job_list_template_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, job_list_template_id, collection_name, collection_item_id, None, None)

    async def _upload_job_list_template_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_id, source_path, file_name)

            return await self._set_job_list_template_attachment_server_state_to_completed(add_attached_file_response, job_list_template_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_id, source_path, file_name, message=e)

    async def _upload_job_list_template_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_job_list_template_collection_item_attachment_server_state_to_completed(add_attached_file_response, job_list_template_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_job_list_template(self, account_id: str, job_list_template_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to job_list_template.
        
        :param account_id: str, 
        :param job_list_template_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, job_list_template_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, job_list_template_id, source_path, model.file_name)

        return await self._upload_job_list_template_attachment(parsed_response, job_list_template_id, file, model.file_name)

    async def add_attachment_to_job_list_template_collection_item(self, account_id: str, job_list_template_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to job_list_template_collection_item.
        
        :param account_id: str, 
        :param job_list_template_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, job_list_template_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, job_list_template_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_job_list_template_collection_item_attachment(parsed_response, job_list_template_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_job_list_template_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_job_list_template_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_job_list_template_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_job_list_template_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_job_list_template_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_job_list_template_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_job_list_template_attachment(self, account_id: str, job_list_template_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_job_list_template_collection_item_attachment(self, account_id: str, job_list_template_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListTemplates/{job_list_template_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_job_list_template_item_by_id(self, account_id: str, job_list_template_item_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_job_list_template_item(self, account_id: str, job_list_template_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}JobListTemplateItems?jobListTemplateId={job_list_template_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_job_list_template_item(self, account_id: str, job_list_template_item_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}", update_model)
        return response.is_success

    async def delete_job_list_template_item(self, account_id: str, job_list_template_item_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}")
        return response.is_success

    async def get_job_list_template_item_attachments_by_id(self, account_id: str, job_list_template_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_template_item_attachments_by_name(self, account_id: str, job_list_template_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_template_item_collection_item_attachments_by_id(self, account_id: str, job_list_template_item_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_job_list_template_item_collection_item_attachments_by_name(self, account_id: str, job_list_template_item_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_job_list_template_item_attachment(self, account_id: str, job_list_template_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_job_list_template_item_collection_item_attachment(self, account_id: str, job_list_template_item_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_job_list_template_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_job_list_template_item_attachment(
            add_attached_file_response.account_id,
            job_list_template_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, job_list_template_item_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, job_list_template_item_id, None, None)

    async def _set_job_list_template_item_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_item_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_job_list_template_item_collection_item_attachment(
            add_attached_file_response.account_id,
            job_list_template_item_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, job_list_template_item_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, job_list_template_item_id, collection_name, collection_item_id, None, None)

    async def _upload_job_list_template_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_item_id, source_path, file_name)

            return await self._set_job_list_template_item_attachment_server_state_to_completed(add_attached_file_response, job_list_template_item_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_item_id, source_path, file_name, message=e)

    async def _upload_job_list_template_item_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, job_list_template_item_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_item_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_job_list_template_item_collection_item_attachment_server_state_to_completed(add_attached_file_response, job_list_template_item_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, job_list_template_item_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_job_list_template_item(self, account_id: str, job_list_template_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to job_list_template_item.
        
        :param account_id: str, 
        :param job_list_template_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, job_list_template_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, job_list_template_item_id, source_path, model.file_name)

        return await self._upload_job_list_template_item_attachment(parsed_response, job_list_template_item_id, file, model.file_name)

    async def add_attachment_to_job_list_template_item_collection_item(self, account_id: str, job_list_template_item_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to job_list_template_item_collection_item.
        
        :param account_id: str, 
        :param job_list_template_item_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, job_list_template_item_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, job_list_template_item_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_job_list_template_item_collection_item_attachment(parsed_response, job_list_template_item_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_job_list_template_item_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_job_list_template_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_job_list_template_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_job_list_template_item_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_job_list_template_item_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_job_list_template_item_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_job_list_template_item_attachment(self, account_id: str, job_list_template_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_job_list_template_item_collection_item_attachment(self, account_id: str, job_list_template_item_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JobListTemplateItems/{job_list_template_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_session_by_id(self, account_id: str, session_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Sessions/{session_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_session(self, account_id: str, event_id: str, session_type_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Sessions?eventId={event_id}&sessionTypeId={session_type_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_session(self, account_id: str, session_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Sessions/{session_id}", update_model)
        return response.is_success

    async def delete_session(self, account_id: str, session_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Sessions/{session_id}")
        return response.is_success

    async def get_session_attachments_by_id(self, account_id: str, session_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Sessions/{session_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Sessions/{session_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_attachments_by_name(self, account_id: str, session_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_collection_item_attachments_by_id(self, account_id: str, session_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Sessions/{session_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Sessions/{session_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_collection_item_attachments_by_name(self, account_id: str, session_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_session_attachment(self, account_id: str, session_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_session_collection_item_attachment(self, account_id: str, session_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_session_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_attachment(
            add_attached_file_response.account_id,
            session_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_id, None, None)

    async def _set_session_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_collection_item_attachment(
            add_attached_file_response.account_id,
            session_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_id, collection_name, collection_item_id, None, None)

    async def _upload_session_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_id, source_path, file_name)

            return await self._set_session_attachment_server_state_to_completed(add_attached_file_response, session_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_id, source_path, file_name, message=e)

    async def _upload_session_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_session_collection_item_attachment_server_state_to_completed(add_attached_file_response, session_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_session(self, account_id: str, session_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session.
        
        :param account_id: str, 
        :param session_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_id, source_path, model.file_name)

        return await self._upload_session_attachment(parsed_response, session_id, file, model.file_name)

    async def add_attachment_to_session_collection_item(self, account_id: str, session_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_collection_item.
        
        :param account_id: str, 
        :param session_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_session_collection_item_attachment(parsed_response, session_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_session_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_session_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_session_attachment(self, account_id: str, session_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_session_collection_item_attachment(self, account_id: str, session_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Sessions/{session_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_team_by_id(self, account_id: str, team_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Teams/{team_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_teams(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Teams"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_team(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}Teams?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_team(self, account_id: str, team_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Teams/{team_id}", update_model)
        return response.is_success

    async def delete_team(self, account_id: str, team_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Teams/{team_id}")
        return response.is_success

    async def get_team_attachments_by_id(self, account_id: str, team_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Teams/{team_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Teams/{team_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_team_attachments_by_name(self, account_id: str, team_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_team_collection_item_attachments_by_id(self, account_id: str, team_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Teams/{team_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Teams/{team_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_team_collection_item_attachments_by_name(self, account_id: str, team_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_team_attachment(self, account_id: str, team_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_team_collection_item_attachment(self, account_id: str, team_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_team_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, team_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_team_attachment(
            add_attached_file_response.account_id,
            team_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, team_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, team_id, None, None)

    async def _set_team_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, team_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_team_collection_item_attachment(
            add_attached_file_response.account_id,
            team_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, team_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, team_id, collection_name, collection_item_id, None, None)

    async def _upload_team_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, team_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, team_id, source_path, file_name)

            return await self._set_team_attachment_server_state_to_completed(add_attached_file_response, team_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, team_id, source_path, file_name, message=e)

    async def _upload_team_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, team_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, team_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_team_collection_item_attachment_server_state_to_completed(add_attached_file_response, team_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, team_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_team(self, account_id: str, team_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to team.
        
        :param account_id: str, 
        :param team_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, team_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, team_id, source_path, model.file_name)

        return await self._upload_team_attachment(parsed_response, team_id, file, model.file_name)

    async def add_attachment_to_team_collection_item(self, account_id: str, team_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to team_collection_item.
        
        :param account_id: str, 
        :param team_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, team_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, team_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_team_collection_item_attachment(parsed_response, team_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_team_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_team_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_team_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_team_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_team_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_team_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_team_attachment(self, account_id: str, team_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_team_collection_item_attachment(self, account_id: str, team_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Teams/{team_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_track_sector_definition_by_id(self, account_id: str, track_sector_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_track_sector_definition(self, account_id: str, track_configuration_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions?trackConfigurationId={track_configuration_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_track_sector_definition(self, account_id: str, track_sector_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}", update_model)
        return response.is_success

    async def delete_track_sector_definition(self, account_id: str, track_sector_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}")
        return response.is_success

    async def get_track_sector_definition_attachments_by_id(self, account_id: str, track_sector_definition_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_sector_definition_attachments_by_name(self, account_id: str, track_sector_definition_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_sector_definition_collection_item_attachments_by_id(self, account_id: str, track_sector_definition_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_sector_definition_collection_item_attachments_by_name(self, account_id: str, track_sector_definition_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_track_sector_definition_attachment(self, account_id: str, track_sector_definition_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_track_sector_definition_collection_item_attachment(self, account_id: str, track_sector_definition_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_track_sector_definition_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_sector_definition_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_sector_definition_attachment(
            add_attached_file_response.account_id,
            track_sector_definition_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_sector_definition_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_sector_definition_id, None, None)

    async def _set_track_sector_definition_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_sector_definition_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_sector_definition_collection_item_attachment(
            add_attached_file_response.account_id,
            track_sector_definition_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_sector_definition_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_sector_definition_id, collection_name, collection_item_id, None, None)

    async def _upload_track_sector_definition_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_sector_definition_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_sector_definition_id, source_path, file_name)

            return await self._set_track_sector_definition_attachment_server_state_to_completed(add_attached_file_response, track_sector_definition_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_sector_definition_id, source_path, file_name, message=e)

    async def _upload_track_sector_definition_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_sector_definition_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_sector_definition_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_track_sector_definition_collection_item_attachment_server_state_to_completed(add_attached_file_response, track_sector_definition_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_sector_definition_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_track_sector_definition(self, account_id: str, track_sector_definition_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_sector_definition.
        
        :param account_id: str, 
        :param track_sector_definition_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_sector_definition_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_sector_definition_id, source_path, model.file_name)

        return await self._upload_track_sector_definition_attachment(parsed_response, track_sector_definition_id, file, model.file_name)

    async def add_attachment_to_track_sector_definition_collection_item(self, account_id: str, track_sector_definition_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_sector_definition_collection_item.
        
        :param account_id: str, 
        :param track_sector_definition_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_sector_definition_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_sector_definition_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_track_sector_definition_collection_item_attachment(parsed_response, track_sector_definition_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_track_sector_definition_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_sector_definition_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_sector_definition_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_track_sector_definition_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_sector_definition_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_sector_definition_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_track_sector_definition_attachment(self, account_id: str, track_sector_definition_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_track_sector_definition_collection_item_attachment(self, account_id: str, track_sector_definition_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackSectorDefinitions/{track_sector_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_session_object_issue_by_id(self, account_id: str, session_object_issue_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_session_object_issues_for_session_car(self, account_id: str, session_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}SessionObjectIssues"

        param_lookup = dict()
        param_lookup["sessionId"] = session_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_session_object_issue(self, account_id: str, session_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}SessionObjectIssues?sessionId={session_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_session_object_issue(self, account_id: str, session_object_issue_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}", update_model)
        return response.is_success

    async def delete_session_object_issue(self, account_id: str, session_object_issue_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}")
        return response.is_success

    async def get_session_object_issue_attachments_by_id(self, account_id: str, session_object_issue_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_object_issue_attachments_by_name(self, account_id: str, session_object_issue_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_object_issue_collection_item_attachments_by_id(self, account_id: str, session_object_issue_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_object_issue_collection_item_attachments_by_name(self, account_id: str, session_object_issue_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_session_object_issue_attachment(self, account_id: str, session_object_issue_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_session_object_issue_collection_item_attachment(self, account_id: str, session_object_issue_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_session_object_issue_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_issue_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_object_issue_attachment(
            add_attached_file_response.account_id,
            session_object_issue_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_object_issue_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_object_issue_id, None, None)

    async def _set_session_object_issue_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_issue_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_object_issue_collection_item_attachment(
            add_attached_file_response.account_id,
            session_object_issue_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_object_issue_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_object_issue_id, collection_name, collection_item_id, None, None)

    async def _upload_session_object_issue_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_issue_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_issue_id, source_path, file_name)

            return await self._set_session_object_issue_attachment_server_state_to_completed(add_attached_file_response, session_object_issue_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_issue_id, source_path, file_name, message=e)

    async def _upload_session_object_issue_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_issue_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_issue_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_session_object_issue_collection_item_attachment_server_state_to_completed(add_attached_file_response, session_object_issue_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_issue_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_session_object_issue(self, account_id: str, session_object_issue_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_object_issue.
        
        :param account_id: str, 
        :param session_object_issue_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_object_issue_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_object_issue_id, source_path, model.file_name)

        return await self._upload_session_object_issue_attachment(parsed_response, session_object_issue_id, file, model.file_name)

    async def add_attachment_to_session_object_issue_collection_item(self, account_id: str, session_object_issue_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_object_issue_collection_item.
        
        :param account_id: str, 
        :param session_object_issue_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_object_issue_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_object_issue_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_session_object_issue_collection_item_attachment(parsed_response, session_object_issue_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_session_object_issue_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_object_issue_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_object_issue_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_session_object_issue_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_object_issue_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_object_issue_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_session_object_issue_attachment(self, account_id: str, session_object_issue_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_session_object_issue_collection_item_attachment(self, account_id: str, session_object_issue_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionObjectIssues/{session_object_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_session_object_job_by_id(self, account_id: str, session_object_job_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_session_object_jobs_for_session_car(self, account_id: str, session_id: str, car_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}SessionObjectJobs"

        param_lookup = dict()
        param_lookup["sessionId"] = session_id
        param_lookup["carId"] = car_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_session_object_job(self, account_id: str, session_id: str, car_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}SessionObjectJobs?sessionId={session_id}&carId={car_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_session_object_job(self, account_id: str, session_object_job_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}", update_model)
        return response.is_success

    async def delete_session_object_job(self, account_id: str, session_object_job_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}")
        return response.is_success

    async def get_session_object_job_attachments_by_id(self, account_id: str, session_object_job_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_object_job_attachments_by_name(self, account_id: str, session_object_job_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_object_job_collection_item_attachments_by_id(self, account_id: str, session_object_job_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_object_job_collection_item_attachments_by_name(self, account_id: str, session_object_job_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_session_object_job_attachment(self, account_id: str, session_object_job_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_session_object_job_collection_item_attachment(self, account_id: str, session_object_job_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_session_object_job_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_job_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_object_job_attachment(
            add_attached_file_response.account_id,
            session_object_job_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_object_job_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_object_job_id, None, None)

    async def _set_session_object_job_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_job_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_object_job_collection_item_attachment(
            add_attached_file_response.account_id,
            session_object_job_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_object_job_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_object_job_id, collection_name, collection_item_id, None, None)

    async def _upload_session_object_job_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_job_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_job_id, source_path, file_name)

            return await self._set_session_object_job_attachment_server_state_to_completed(add_attached_file_response, session_object_job_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_job_id, source_path, file_name, message=e)

    async def _upload_session_object_job_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_object_job_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_job_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_session_object_job_collection_item_attachment_server_state_to_completed(add_attached_file_response, session_object_job_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_object_job_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_session_object_job(self, account_id: str, session_object_job_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_object_job.
        
        :param account_id: str, 
        :param session_object_job_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_object_job_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_object_job_id, source_path, model.file_name)

        return await self._upload_session_object_job_attachment(parsed_response, session_object_job_id, file, model.file_name)

    async def add_attachment_to_session_object_job_collection_item(self, account_id: str, session_object_job_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_object_job_collection_item.
        
        :param account_id: str, 
        :param session_object_job_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_object_job_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_object_job_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_session_object_job_collection_item_attachment(parsed_response, session_object_job_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_session_object_job_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_object_job_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_object_job_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_session_object_job_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_object_job_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_object_job_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_session_object_job_attachment(self, account_id: str, session_object_job_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_session_object_job_collection_item_attachment(self, account_id: str, session_object_job_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionObjectJobs/{session_object_job_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_data_analysis_profile_by_id(self, account_id: str, data_analysis_profile_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}DataAnalysisProfiles/{data_analysis_profile_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_data_analysis_profiles(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}DataAnalysisProfiles"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_data_analysis_profile(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}DataAnalysisProfiles?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_data_analysis_profile(self, account_id: str, data_analysis_profile_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}DataAnalysisProfiles/{data_analysis_profile_id}", update_model)
        return response.is_success

    async def delete_data_analysis_profile(self, account_id: str, data_analysis_profile_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}DataAnalysisProfiles/{data_analysis_profile_id}")
        return response.is_success

    async def get_data_analysis_folder_by_id(self, account_id: str, data_analysis_folder_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}DataAnalysisFolders/{data_analysis_folder_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_data_analysis_folder(self, account_id: str, data_analysis_profile_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}DataAnalysisFolders?dataAnalysisProfileId={data_analysis_profile_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_data_analysis_folder(self, account_id: str, data_analysis_folder_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}DataAnalysisFolders/{data_analysis_folder_id}", update_model)
        return response.is_success

    async def delete_data_analysis_folder(self, account_id: str, data_analysis_folder_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}DataAnalysisFolders/{data_analysis_folder_id}")
        return response.is_success

    async def get_data_channel_by_id(self, account_id: str, data_channel_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}DataChannels/{data_channel_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_data_channel(self, account_id: str, data_analysis_folder_id: str, dimension: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}DataChannels?dataAnalysisFolderId={data_analysis_folder_id}&dimension={dimension}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_data_channel(self, account_id: str, data_channel_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}DataChannels/{data_channel_id}", update_model)
        return response.is_success

    async def delete_data_channel(self, account_id: str, data_channel_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}DataChannels/{data_channel_id}")
        return response.is_success

    async def get_data_channel_alias_by_id(self, account_id: str, data_channel_alias_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}DataChannelAliases/{data_channel_alias_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_data_channel_alias(self, account_id: str, data_channel_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}DataChannelAliases?dataChannelId={data_channel_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_data_channel_alias(self, account_id: str, data_channel_alias_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}DataChannelAliases/{data_channel_alias_id}", update_model)
        return response.is_success

    async def delete_data_channel_alias(self, account_id: str, data_channel_alias_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}DataChannelAliases/{data_channel_alias_id}")
        return response.is_success

    async def get_math_channel_by_id(self, account_id: str, math_channel_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}MathChannels/{math_channel_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_math_channel(self, account_id: str, data_analysis_folder_id: str, dimension: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}MathChannels?dataAnalysisFolderId={data_analysis_folder_id}&dimension={dimension}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_math_channel(self, account_id: str, math_channel_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}MathChannels/{math_channel_id}", update_model)
        return response.is_success

    async def delete_math_channel(self, account_id: str, math_channel_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}MathChannels/{math_channel_id}")
        return response.is_success

    async def get_math_channel_constant_by_id(self, account_id: str, math_channel_constant_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}MathChannelConstants/{math_channel_constant_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_math_channel_constant(self, account_id: str, data_analysis_folder_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}MathChannelConstants?dataAnalysisFolderId={data_analysis_folder_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_math_channel_constant(self, account_id: str, math_channel_constant_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}MathChannelConstants/{math_channel_constant_id}", update_model)
        return response.is_success

    async def delete_math_channel_constant(self, account_id: str, math_channel_constant_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}MathChannelConstants/{math_channel_constant_id}")
        return response.is_success

    async def get_brake_disc_specification_by_id(self, account_id: str, brake_disc_specification_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_brake_disc_specifications(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}BrakeDiscSpecifications"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_brake_disc_specification(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_brake_disc_specification(self, account_id: str, brake_disc_specification_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}", update_model)
        return response.is_success

    async def delete_brake_disc_specification(self, account_id: str, brake_disc_specification_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}")
        return response.is_success

    async def get_brake_disc_specification_attachments_by_id(self, account_id: str, brake_disc_specification_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_disc_specification_attachments_by_name(self, account_id: str, brake_disc_specification_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_disc_specification_collection_item_attachments_by_id(self, account_id: str, brake_disc_specification_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_disc_specification_collection_item_attachments_by_name(self, account_id: str, brake_disc_specification_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_brake_disc_specification_attachment(self, account_id: str, brake_disc_specification_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_brake_disc_specification_collection_item_attachment(self, account_id: str, brake_disc_specification_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_brake_disc_specification_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_specification_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_disc_specification_attachment(
            add_attached_file_response.account_id,
            brake_disc_specification_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_disc_specification_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_disc_specification_id, None, None)

    async def _set_brake_disc_specification_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_specification_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_disc_specification_collection_item_attachment(
            add_attached_file_response.account_id,
            brake_disc_specification_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_disc_specification_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_disc_specification_id, collection_name, collection_item_id, None, None)

    async def _upload_brake_disc_specification_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_specification_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_specification_id, source_path, file_name)

            return await self._set_brake_disc_specification_attachment_server_state_to_completed(add_attached_file_response, brake_disc_specification_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_specification_id, source_path, file_name, message=e)

    async def _upload_brake_disc_specification_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_specification_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_specification_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_brake_disc_specification_collection_item_attachment_server_state_to_completed(add_attached_file_response, brake_disc_specification_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_specification_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_brake_disc_specification(self, account_id: str, brake_disc_specification_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_disc_specification.
        
        :param account_id: str, 
        :param brake_disc_specification_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_disc_specification_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_disc_specification_id, source_path, model.file_name)

        return await self._upload_brake_disc_specification_attachment(parsed_response, brake_disc_specification_id, file, model.file_name)

    async def add_attachment_to_brake_disc_specification_collection_item(self, account_id: str, brake_disc_specification_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_disc_specification_collection_item.
        
        :param account_id: str, 
        :param brake_disc_specification_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_disc_specification_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_disc_specification_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_brake_disc_specification_collection_item_attachment(parsed_response, brake_disc_specification_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_brake_disc_specification_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_disc_specification_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_disc_specification_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_brake_disc_specification_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_disc_specification_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_disc_specification_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_brake_disc_specification_attachment(self, account_id: str, brake_disc_specification_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_brake_disc_specification_collection_item_attachment(self, account_id: str, brake_disc_specification_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeDiscSpecifications/{brake_disc_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_brake_pad_specification_by_id(self, account_id: str, brake_pad_specification_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_brake_pad_specifications(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}BrakePadSpecifications"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_brake_pad_specification(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}BrakePadSpecifications?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_brake_pad_specification(self, account_id: str, brake_pad_specification_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}", update_model)
        return response.is_success

    async def delete_brake_pad_specification(self, account_id: str, brake_pad_specification_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}")
        return response.is_success

    async def get_brake_pad_specification_attachments_by_id(self, account_id: str, brake_pad_specification_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_pad_specification_attachments_by_name(self, account_id: str, brake_pad_specification_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_pad_specification_collection_item_attachments_by_id(self, account_id: str, brake_pad_specification_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_pad_specification_collection_item_attachments_by_name(self, account_id: str, brake_pad_specification_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_brake_pad_specification_attachment(self, account_id: str, brake_pad_specification_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_brake_pad_specification_collection_item_attachment(self, account_id: str, brake_pad_specification_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_brake_pad_specification_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_specification_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_pad_specification_attachment(
            add_attached_file_response.account_id,
            brake_pad_specification_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_pad_specification_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_pad_specification_id, None, None)

    async def _set_brake_pad_specification_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_specification_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_pad_specification_collection_item_attachment(
            add_attached_file_response.account_id,
            brake_pad_specification_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_pad_specification_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_pad_specification_id, collection_name, collection_item_id, None, None)

    async def _upload_brake_pad_specification_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_specification_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_specification_id, source_path, file_name)

            return await self._set_brake_pad_specification_attachment_server_state_to_completed(add_attached_file_response, brake_pad_specification_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_specification_id, source_path, file_name, message=e)

    async def _upload_brake_pad_specification_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_specification_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_specification_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_brake_pad_specification_collection_item_attachment_server_state_to_completed(add_attached_file_response, brake_pad_specification_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_specification_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_brake_pad_specification(self, account_id: str, brake_pad_specification_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_pad_specification.
        
        :param account_id: str, 
        :param brake_pad_specification_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_pad_specification_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_pad_specification_id, source_path, model.file_name)

        return await self._upload_brake_pad_specification_attachment(parsed_response, brake_pad_specification_id, file, model.file_name)

    async def add_attachment_to_brake_pad_specification_collection_item(self, account_id: str, brake_pad_specification_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_pad_specification_collection_item.
        
        :param account_id: str, 
        :param brake_pad_specification_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_pad_specification_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_pad_specification_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_brake_pad_specification_collection_item_attachment(parsed_response, brake_pad_specification_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_brake_pad_specification_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_pad_specification_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_pad_specification_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_brake_pad_specification_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_pad_specification_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_pad_specification_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_brake_pad_specification_attachment(self, account_id: str, brake_pad_specification_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_brake_pad_specification_collection_item_attachment(self, account_id: str, brake_pad_specification_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakePadSpecifications/{brake_pad_specification_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_brake_disc_by_id(self, account_id: str, brake_disc_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_brake_discs(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}BrakeDiscs/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_brake_disc(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeDiscs?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_brake_disc(self, account_id: str, brake_disc_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}", update_model)
        return response.is_success

    async def delete_brake_disc(self, account_id: str, brake_disc_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}")
        return response.is_success

    async def get_brake_disc_attachments_by_id(self, account_id: str, brake_disc_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_disc_attachments_by_name(self, account_id: str, brake_disc_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_disc_collection_item_attachments_by_id(self, account_id: str, brake_disc_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_disc_collection_item_attachments_by_name(self, account_id: str, brake_disc_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_brake_disc_attachment(self, account_id: str, brake_disc_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_brake_disc_collection_item_attachment(self, account_id: str, brake_disc_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_brake_disc_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_disc_attachment(
            add_attached_file_response.account_id,
            brake_disc_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_disc_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_disc_id, None, None)

    async def _set_brake_disc_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_disc_collection_item_attachment(
            add_attached_file_response.account_id,
            brake_disc_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_disc_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_disc_id, collection_name, collection_item_id, None, None)

    async def _upload_brake_disc_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_id, source_path, file_name)

            return await self._set_brake_disc_attachment_server_state_to_completed(add_attached_file_response, brake_disc_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_id, source_path, file_name, message=e)

    async def _upload_brake_disc_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_disc_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_brake_disc_collection_item_attachment_server_state_to_completed(add_attached_file_response, brake_disc_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_disc_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_brake_disc(self, account_id: str, brake_disc_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_disc.
        
        :param account_id: str, 
        :param brake_disc_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_disc_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_disc_id, source_path, model.file_name)

        return await self._upload_brake_disc_attachment(parsed_response, brake_disc_id, file, model.file_name)

    async def add_attachment_to_brake_disc_collection_item(self, account_id: str, brake_disc_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_disc_collection_item.
        
        :param account_id: str, 
        :param brake_disc_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_disc_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_disc_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_brake_disc_collection_item_attachment(parsed_response, brake_disc_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_brake_disc_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_disc_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_disc_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_brake_disc_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_disc_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_disc_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_brake_disc_attachment(self, account_id: str, brake_disc_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_brake_disc_collection_item_attachment(self, account_id: str, brake_disc_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeDiscs/{brake_disc_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_brake_pad_by_id(self, account_id: str, brake_pad_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}BrakePads/{brake_pad_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_brake_pads(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}BrakePads/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_brake_pad(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}BrakePads?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_brake_pad(self, account_id: str, brake_pad_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}", update_model)
        return response.is_success

    async def delete_brake_pad(self, account_id: str, brake_pad_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}")
        return response.is_success

    async def get_brake_pad_attachments_by_id(self, account_id: str, brake_pad_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakePads/{brake_pad_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakePads/{brake_pad_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_pad_attachments_by_name(self, account_id: str, brake_pad_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_pad_collection_item_attachments_by_id(self, account_id: str, brake_pad_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakePads/{brake_pad_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakePads/{brake_pad_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_pad_collection_item_attachments_by_name(self, account_id: str, brake_pad_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_brake_pad_attachment(self, account_id: str, brake_pad_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_brake_pad_collection_item_attachment(self, account_id: str, brake_pad_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_brake_pad_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_pad_attachment(
            add_attached_file_response.account_id,
            brake_pad_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_pad_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_pad_id, None, None)

    async def _set_brake_pad_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_pad_collection_item_attachment(
            add_attached_file_response.account_id,
            brake_pad_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_pad_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_pad_id, collection_name, collection_item_id, None, None)

    async def _upload_brake_pad_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_id, source_path, file_name)

            return await self._set_brake_pad_attachment_server_state_to_completed(add_attached_file_response, brake_pad_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_id, source_path, file_name, message=e)

    async def _upload_brake_pad_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_pad_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_brake_pad_collection_item_attachment_server_state_to_completed(add_attached_file_response, brake_pad_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_pad_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_brake_pad(self, account_id: str, brake_pad_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_pad.
        
        :param account_id: str, 
        :param brake_pad_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_pad_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_pad_id, source_path, model.file_name)

        return await self._upload_brake_pad_attachment(parsed_response, brake_pad_id, file, model.file_name)

    async def add_attachment_to_brake_pad_collection_item(self, account_id: str, brake_pad_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_pad_collection_item.
        
        :param account_id: str, 
        :param brake_pad_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_pad_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_pad_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_brake_pad_collection_item_attachment(parsed_response, brake_pad_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_brake_pad_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_pad_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_pad_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_brake_pad_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_pad_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_pad_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_brake_pad_attachment(self, account_id: str, brake_pad_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_brake_pad_collection_item_attachment(self, account_id: str, brake_pad_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakePads/{brake_pad_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_brake_set_by_id(self, account_id: str, brake_set_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}BrakeSets/{brake_set_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_brake_sets(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}BrakeSets/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_brake_set(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeSets?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_brake_set(self, account_id: str, brake_set_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}", update_model)
        return response.is_success

    async def delete_brake_set(self, account_id: str, brake_set_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}")
        return response.is_success

    async def get_brake_set_attachments_by_id(self, account_id: str, brake_set_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakeSets/{brake_set_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakeSets/{brake_set_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_set_attachments_by_name(self, account_id: str, brake_set_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_set_collection_item_attachments_by_id(self, account_id: str, brake_set_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}BrakeSets/{brake_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}BrakeSets/{brake_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_brake_set_collection_item_attachments_by_name(self, account_id: str, brake_set_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_brake_set_attachment(self, account_id: str, brake_set_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_brake_set_collection_item_attachment(self, account_id: str, brake_set_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_brake_set_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_set_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_set_attachment(
            add_attached_file_response.account_id,
            brake_set_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_set_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_set_id, None, None)

    async def _set_brake_set_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_set_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_brake_set_collection_item_attachment(
            add_attached_file_response.account_id,
            brake_set_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, brake_set_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, brake_set_id, collection_name, collection_item_id, None, None)

    async def _upload_brake_set_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_set_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_set_id, source_path, file_name)

            return await self._set_brake_set_attachment_server_state_to_completed(add_attached_file_response, brake_set_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_set_id, source_path, file_name, message=e)

    async def _upload_brake_set_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, brake_set_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_set_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_brake_set_collection_item_attachment_server_state_to_completed(add_attached_file_response, brake_set_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, brake_set_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_brake_set(self, account_id: str, brake_set_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_set.
        
        :param account_id: str, 
        :param brake_set_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_set_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_set_id, source_path, model.file_name)

        return await self._upload_brake_set_attachment(parsed_response, brake_set_id, file, model.file_name)

    async def add_attachment_to_brake_set_collection_item(self, account_id: str, brake_set_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to brake_set_collection_item.
        
        :param account_id: str, 
        :param brake_set_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, brake_set_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, brake_set_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_brake_set_collection_item_attachment(parsed_response, brake_set_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_brake_set_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_set_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_set_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_brake_set_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_brake_set_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_brake_set_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_brake_set_attachment(self, account_id: str, brake_set_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_brake_set_collection_item_attachment(self, account_id: str, brake_set_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}BrakeSets/{brake_set_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_user_by_id(self, account_id: str, user_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}Users/{user_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_users(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}Users"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_user(self, account_id: str, user_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Users/{user_id}", update_model)
        return response.is_success

    async def get_user_attachments_by_id(self, account_id: str, user_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Users/{user_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Users/{user_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_user_attachments_by_name(self, account_id: str, user_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Users/{user_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_user_collection_item_attachments_by_id(self, account_id: str, user_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}Users/{user_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}Users/{user_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_user_collection_item_attachments_by_name(self, account_id: str, user_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}Users/{user_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_user_attachment(self, account_id: str, user_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Users/{user_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_user_collection_item_attachment(self, account_id: str, user_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}Users/{user_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_user_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, user_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_user_attachment(
            add_attached_file_response.account_id,
            user_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, user_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, user_id, None, None)

    async def _set_user_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, user_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_user_collection_item_attachment(
            add_attached_file_response.account_id,
            user_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, user_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, user_id, collection_name, collection_item_id, None, None)

    async def _upload_user_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, user_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, user_id, source_path, file_name)

            return await self._set_user_attachment_server_state_to_completed(add_attached_file_response, user_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, user_id, source_path, file_name, message=e)

    async def _upload_user_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, user_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, user_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_user_collection_item_attachment_server_state_to_completed(add_attached_file_response, user_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, user_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_user(self, account_id: str, user_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to user.
        
        :param account_id: str, 
        :param user_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Users/{user_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, user_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, user_id, source_path, model.file_name)

        return await self._upload_user_attachment(parsed_response, user_id, file, model.file_name)

    async def add_attachment_to_user_collection_item(self, account_id: str, user_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to user_collection_item.
        
        :param account_id: str, 
        :param user_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}Users/{user_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, user_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, user_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_user_collection_item_attachment(parsed_response, user_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_user_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_user_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_user_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_user_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_user_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_user_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_user_attachment(self, account_id: str, user_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Users/{user_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_user_collection_item_attachment(self, account_id: str, user_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}Users/{user_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_part_item_by_id(self, account_id: str, part_item_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}PartItems/{part_item_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_part_item(self, account_id: str, part_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}PartItems?partId={part_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_part_item(self, account_id: str, part_item_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}", update_model)
        return response.is_success

    async def delete_part_item(self, account_id: str, part_item_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}")
        return response.is_success

    async def get_part_item_attachments_by_id(self, account_id: str, part_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PartItems/{part_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PartItems/{part_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_item_attachments_by_name(self, account_id: str, part_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_item_collection_item_attachments_by_id(self, account_id: str, part_item_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PartItems/{part_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PartItems/{part_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_part_item_collection_item_attachments_by_name(self, account_id: str, part_item_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_part_item_attachment(self, account_id: str, part_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_part_item_collection_item_attachment(self, account_id: str, part_item_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_part_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, part_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_part_item_attachment(
            add_attached_file_response.account_id,
            part_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, part_item_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, part_item_id, None, None)

    async def _set_part_item_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, part_item_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_part_item_collection_item_attachment(
            add_attached_file_response.account_id,
            part_item_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, part_item_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, part_item_id, collection_name, collection_item_id, None, None)

    async def _upload_part_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, part_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_item_id, source_path, file_name)

            return await self._set_part_item_attachment_server_state_to_completed(add_attached_file_response, part_item_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_item_id, source_path, file_name, message=e)

    async def _upload_part_item_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, part_item_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_item_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_part_item_collection_item_attachment_server_state_to_completed(add_attached_file_response, part_item_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, part_item_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_part_item(self, account_id: str, part_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to part_item.
        
        :param account_id: str, 
        :param part_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, part_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, part_item_id, source_path, model.file_name)

        return await self._upload_part_item_attachment(parsed_response, part_item_id, file, model.file_name)

    async def add_attachment_to_part_item_collection_item(self, account_id: str, part_item_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to part_item_collection_item.
        
        :param account_id: str, 
        :param part_item_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, part_item_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, part_item_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_part_item_collection_item_attachment(parsed_response, part_item_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_part_item_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_part_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_part_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_part_item_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_part_item_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_part_item_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_part_item_attachment(self, account_id: str, part_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_part_item_collection_item_attachment(self, account_id: str, part_item_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PartItems/{part_item_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_view_custom_column_profile_by_id(self, account_id: str, view_custom_column_profile_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ViewCustomColumnProfiles/{view_custom_column_profile_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_view_custom_column_profiles(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}ViewCustomColumnProfiles"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_view_custom_column_profile(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ViewCustomColumnProfiles?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_view_custom_column_profile(self, account_id: str, view_custom_column_profile_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ViewCustomColumnProfiles/{view_custom_column_profile_id}", update_model)
        return response.is_success

    async def delete_view_custom_column_profile(self, account_id: str, view_custom_column_profile_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ViewCustomColumnProfiles/{view_custom_column_profile_id}")
        return response.is_success

    async def get_view_custom_column_column_definition_by_id(self, account_id: str, view_custom_column_column_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ViewCustomColumnColumnDefinitions/{view_custom_column_column_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_view_custom_column_column_definition(self, account_id: str, view_custom_column_profile_id: str, column_type: int, width: int, show_multi_header: bool, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ViewCustomColumnColumnDefinitions?viewCustomColumnProfileId={view_custom_column_profile_id}&columnType={column_type}&width={width}&showMultiHeader={show_multi_header}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_view_custom_column_column_definition(self, account_id: str, view_custom_column_column_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ViewCustomColumnColumnDefinitions/{view_custom_column_column_definition_id}", update_model)
        return response.is_success

    async def delete_view_custom_column_column_definition(self, account_id: str, view_custom_column_column_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ViewCustomColumnColumnDefinitions/{view_custom_column_column_definition_id}")
        return response.is_success

    async def get_tyre_wear_measurement_by_id(self, account_id: str, tyre_wear_measurement_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_tyre_wear_measurement(self, account_id: str, tyre_id: str, position: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TyreWearMeasurements?tyreId={tyre_id}&position={position}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre_wear_measurement(self, account_id: str, tyre_wear_measurement_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}", update_model)
        return response.is_success

    async def delete_tyre_wear_measurement(self, account_id: str, tyre_wear_measurement_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}")
        return response.is_success

    async def get_tyre_wear_measurement_attachments_by_id(self, account_id: str, tyre_wear_measurement_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_wear_measurement_attachments_by_name(self, account_id: str, tyre_wear_measurement_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_wear_measurement_collection_item_attachments_by_id(self, account_id: str, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_tyre_wear_measurement_collection_item_attachments_by_name(self, account_id: str, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_tyre_wear_measurement_attachment(self, account_id: str, tyre_wear_measurement_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_tyre_wear_measurement_collection_item_attachment(self, account_id: str, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_tyre_wear_measurement_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_measurement_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_wear_measurement_attachment(
            add_attached_file_response.account_id,
            tyre_wear_measurement_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_wear_measurement_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_wear_measurement_id, None, None)

    async def _set_tyre_wear_measurement_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_tyre_wear_measurement_collection_item_attachment(
            add_attached_file_response.account_id,
            tyre_wear_measurement_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, tyre_wear_measurement_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, tyre_wear_measurement_id, collection_name, collection_item_id, None, None)

    async def _upload_tyre_wear_measurement_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_measurement_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_measurement_id, source_path, file_name)

            return await self._set_tyre_wear_measurement_attachment_server_state_to_completed(add_attached_file_response, tyre_wear_measurement_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_measurement_id, source_path, file_name, message=e)

    async def _upload_tyre_wear_measurement_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_measurement_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_tyre_wear_measurement_collection_item_attachment_server_state_to_completed(add_attached_file_response, tyre_wear_measurement_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, tyre_wear_measurement_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_tyre_wear_measurement(self, account_id: str, tyre_wear_measurement_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_wear_measurement.
        
        :param account_id: str, 
        :param tyre_wear_measurement_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_wear_measurement_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_wear_measurement_id, source_path, model.file_name)

        return await self._upload_tyre_wear_measurement_attachment(parsed_response, tyre_wear_measurement_id, file, model.file_name)

    async def add_attachment_to_tyre_wear_measurement_collection_item(self, account_id: str, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to tyre_wear_measurement_collection_item.
        
        :param account_id: str, 
        :param tyre_wear_measurement_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, tyre_wear_measurement_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, tyre_wear_measurement_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_tyre_wear_measurement_collection_item_attachment(parsed_response, tyre_wear_measurement_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_tyre_wear_measurement_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_wear_measurement_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_wear_measurement_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_tyre_wear_measurement_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_tyre_wear_measurement_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_tyre_wear_measurement_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_tyre_wear_measurement_attachment(self, account_id: str, tyre_wear_measurement_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_tyre_wear_measurement_collection_item_attachment(self, account_id: str, tyre_wear_measurement_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TyreWearMeasurements/{tyre_wear_measurement_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_tyre_wear_measurement_item_by_id(self, account_id: str, tyre_wear_measurement_item_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TyreWearMeasurementItems/{tyre_wear_measurement_item_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_tyre_wear_measurement_item(self, account_id: str, tyre_wear_measurement_item_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TyreWearMeasurementItems/{tyre_wear_measurement_item_id}", update_model)
        return response.is_success

    async def get_track_configuration_by_id(self, account_id: str, track_configuration_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_track_configuration(self, account_id: str, track_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TrackConfigurations?trackId={track_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_track_configuration(self, account_id: str, track_configuration_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}", update_model)
        return response.is_success

    async def delete_track_configuration(self, account_id: str, track_configuration_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}")
        return response.is_success

    async def get_track_configuration_attachments_by_id(self, account_id: str, track_configuration_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_configuration_attachments_by_name(self, account_id: str, track_configuration_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_configuration_collection_item_attachments_by_id(self, account_id: str, track_configuration_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_configuration_collection_item_attachments_by_name(self, account_id: str, track_configuration_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_track_configuration_attachment(self, account_id: str, track_configuration_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_track_configuration_collection_item_attachment(self, account_id: str, track_configuration_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_track_configuration_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_configuration_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_configuration_attachment(
            add_attached_file_response.account_id,
            track_configuration_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_configuration_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_configuration_id, None, None)

    async def _set_track_configuration_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_configuration_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_configuration_collection_item_attachment(
            add_attached_file_response.account_id,
            track_configuration_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_configuration_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_configuration_id, collection_name, collection_item_id, None, None)

    async def _upload_track_configuration_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_configuration_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_configuration_id, source_path, file_name)

            return await self._set_track_configuration_attachment_server_state_to_completed(add_attached_file_response, track_configuration_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_configuration_id, source_path, file_name, message=e)

    async def _upload_track_configuration_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_configuration_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_configuration_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_track_configuration_collection_item_attachment_server_state_to_completed(add_attached_file_response, track_configuration_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_configuration_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_track_configuration(self, account_id: str, track_configuration_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_configuration.
        
        :param account_id: str, 
        :param track_configuration_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_configuration_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_configuration_id, source_path, model.file_name)

        return await self._upload_track_configuration_attachment(parsed_response, track_configuration_id, file, model.file_name)

    async def add_attachment_to_track_configuration_collection_item(self, account_id: str, track_configuration_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_configuration_collection_item.
        
        :param account_id: str, 
        :param track_configuration_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_configuration_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_configuration_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_track_configuration_collection_item_attachment(parsed_response, track_configuration_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_track_configuration_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_configuration_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_configuration_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_track_configuration_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_configuration_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_configuration_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_track_configuration_attachment(self, account_id: str, track_configuration_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_track_configuration_collection_item_attachment(self, account_id: str, track_configuration_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackConfigurations/{track_configuration_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_track_speed_trap_definition_by_id(self, account_id: str, track_speed_trap_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_track_speed_trap_definition(self, account_id: str, track_configuration_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions?trackConfigurationId={track_configuration_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_track_speed_trap_definition(self, account_id: str, track_speed_trap_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}", update_model)
        return response.is_success

    async def delete_track_speed_trap_definition(self, account_id: str, track_speed_trap_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}")
        return response.is_success

    async def get_track_speed_trap_definition_attachments_by_id(self, account_id: str, track_speed_trap_definition_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_speed_trap_definition_attachments_by_name(self, account_id: str, track_speed_trap_definition_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_speed_trap_definition_collection_item_attachments_by_id(self, account_id: str, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_track_speed_trap_definition_collection_item_attachments_by_name(self, account_id: str, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_track_speed_trap_definition_attachment(self, account_id: str, track_speed_trap_definition_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_track_speed_trap_definition_collection_item_attachment(self, account_id: str, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_track_speed_trap_definition_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_speed_trap_definition_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_speed_trap_definition_attachment(
            add_attached_file_response.account_id,
            track_speed_trap_definition_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_speed_trap_definition_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_speed_trap_definition_id, None, None)

    async def _set_track_speed_trap_definition_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_track_speed_trap_definition_collection_item_attachment(
            add_attached_file_response.account_id,
            track_speed_trap_definition_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, track_speed_trap_definition_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, track_speed_trap_definition_id, collection_name, collection_item_id, None, None)

    async def _upload_track_speed_trap_definition_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_speed_trap_definition_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_speed_trap_definition_id, source_path, file_name)

            return await self._set_track_speed_trap_definition_attachment_server_state_to_completed(add_attached_file_response, track_speed_trap_definition_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_speed_trap_definition_id, source_path, file_name, message=e)

    async def _upload_track_speed_trap_definition_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_speed_trap_definition_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_track_speed_trap_definition_collection_item_attachment_server_state_to_completed(add_attached_file_response, track_speed_trap_definition_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, track_speed_trap_definition_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_track_speed_trap_definition(self, account_id: str, track_speed_trap_definition_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_speed_trap_definition.
        
        :param account_id: str, 
        :param track_speed_trap_definition_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_speed_trap_definition_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_speed_trap_definition_id, source_path, model.file_name)

        return await self._upload_track_speed_trap_definition_attachment(parsed_response, track_speed_trap_definition_id, file, model.file_name)

    async def add_attachment_to_track_speed_trap_definition_collection_item(self, account_id: str, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to track_speed_trap_definition_collection_item.
        
        :param account_id: str, 
        :param track_speed_trap_definition_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, track_speed_trap_definition_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, track_speed_trap_definition_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_track_speed_trap_definition_collection_item_attachment(parsed_response, track_speed_trap_definition_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_track_speed_trap_definition_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_speed_trap_definition_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_speed_trap_definition_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_track_speed_trap_definition_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_track_speed_trap_definition_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_track_speed_trap_definition_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_track_speed_trap_definition_attachment(self, account_id: str, track_speed_trap_definition_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_track_speed_trap_definition_collection_item_attachment(self, account_id: str, track_speed_trap_definition_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}TrackSpeedTrapDefinitions/{track_speed_trap_definition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_lap_speed_trap_by_id(self, account_id: str, lap_speed_trap_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_lap_speed_trap(self, account_id: str, lap_speed_trap_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}", update_model)
        return response.is_success

    async def get_lap_speed_trap_attachments_by_id(self, account_id: str, lap_speed_trap_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_speed_trap_attachments_by_name(self, account_id: str, lap_speed_trap_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_speed_trap_collection_item_attachments_by_id(self, account_id: str, lap_speed_trap_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_speed_trap_collection_item_attachments_by_name(self, account_id: str, lap_speed_trap_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_lap_speed_trap_attachment(self, account_id: str, lap_speed_trap_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_lap_speed_trap_collection_item_attachment(self, account_id: str, lap_speed_trap_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_lap_speed_trap_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_speed_trap_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_speed_trap_attachment(
            add_attached_file_response.account_id,
            lap_speed_trap_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_speed_trap_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_speed_trap_id, None, None)

    async def _set_lap_speed_trap_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_speed_trap_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_speed_trap_collection_item_attachment(
            add_attached_file_response.account_id,
            lap_speed_trap_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_speed_trap_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_speed_trap_id, collection_name, collection_item_id, None, None)

    async def _upload_lap_speed_trap_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_speed_trap_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_speed_trap_id, source_path, file_name)

            return await self._set_lap_speed_trap_attachment_server_state_to_completed(add_attached_file_response, lap_speed_trap_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_speed_trap_id, source_path, file_name, message=e)

    async def _upload_lap_speed_trap_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_speed_trap_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_speed_trap_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_lap_speed_trap_collection_item_attachment_server_state_to_completed(add_attached_file_response, lap_speed_trap_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_speed_trap_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_lap_speed_trap(self, account_id: str, lap_speed_trap_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_speed_trap.
        
        :param account_id: str, 
        :param lap_speed_trap_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_speed_trap_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_speed_trap_id, source_path, model.file_name)

        return await self._upload_lap_speed_trap_attachment(parsed_response, lap_speed_trap_id, file, model.file_name)

    async def add_attachment_to_lap_speed_trap_collection_item(self, account_id: str, lap_speed_trap_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_speed_trap_collection_item.
        
        :param account_id: str, 
        :param lap_speed_trap_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_speed_trap_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_speed_trap_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_lap_speed_trap_collection_item_attachment(parsed_response, lap_speed_trap_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_lap_speed_trap_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_speed_trap_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_speed_trap_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_lap_speed_trap_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_speed_trap_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_speed_trap_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_lap_speed_trap_attachment(self, account_id: str, lap_speed_trap_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_lap_speed_trap_collection_item_attachment(self, account_id: str, lap_speed_trap_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapSpeedTraps/{lap_speed_trap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_lap_marker_by_id(self, account_id: str, lap_marker_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}LapMarkers/{lap_marker_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_lap_markers(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}LapMarkers"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_lap_marker(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}LapMarkers?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_lap_marker(self, account_id: str, lap_marker_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}", update_model)
        return response.is_success

    async def delete_lap_marker(self, account_id: str, lap_marker_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}")
        return response.is_success

    async def get_lap_marker_attachments_by_id(self, account_id: str, lap_marker_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_marker_attachments_by_name(self, account_id: str, lap_marker_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_marker_collection_item_attachments_by_id(self, account_id: str, lap_marker_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_marker_collection_item_attachments_by_name(self, account_id: str, lap_marker_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_lap_marker_attachment(self, account_id: str, lap_marker_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_lap_marker_collection_item_attachment(self, account_id: str, lap_marker_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_lap_marker_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_marker_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_marker_attachment(
            add_attached_file_response.account_id,
            lap_marker_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_marker_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_marker_id, None, None)

    async def _set_lap_marker_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_marker_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_marker_collection_item_attachment(
            add_attached_file_response.account_id,
            lap_marker_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_marker_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_marker_id, collection_name, collection_item_id, None, None)

    async def _upload_lap_marker_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_marker_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_marker_id, source_path, file_name)

            return await self._set_lap_marker_attachment_server_state_to_completed(add_attached_file_response, lap_marker_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_marker_id, source_path, file_name, message=e)

    async def _upload_lap_marker_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_marker_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_marker_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_lap_marker_collection_item_attachment_server_state_to_completed(add_attached_file_response, lap_marker_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_marker_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_lap_marker(self, account_id: str, lap_marker_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_marker.
        
        :param account_id: str, 
        :param lap_marker_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_marker_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_marker_id, source_path, model.file_name)

        return await self._upload_lap_marker_attachment(parsed_response, lap_marker_id, file, model.file_name)

    async def add_attachment_to_lap_marker_collection_item(self, account_id: str, lap_marker_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_marker_collection_item.
        
        :param account_id: str, 
        :param lap_marker_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_marker_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_marker_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_lap_marker_collection_item_attachment(parsed_response, lap_marker_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_lap_marker_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_marker_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_marker_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_lap_marker_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_marker_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_marker_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_lap_marker_attachment(self, account_id: str, lap_marker_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_lap_marker_collection_item_attachment(self, account_id: str, lap_marker_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapMarkers/{lap_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_lap_track_status_marker_by_id(self, account_id: str, lap_track_status_marker_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_lap_track_status_markers(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}LapTrackStatusMarkers"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_lap_track_status_marker(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_lap_track_status_marker(self, account_id: str, lap_track_status_marker_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}", update_model)
        return response.is_success

    async def delete_lap_track_status_marker(self, account_id: str, lap_track_status_marker_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}")
        return response.is_success

    async def get_lap_track_status_marker_attachments_by_id(self, account_id: str, lap_track_status_marker_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_track_status_marker_attachments_by_name(self, account_id: str, lap_track_status_marker_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_track_status_marker_collection_item_attachments_by_id(self, account_id: str, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_lap_track_status_marker_collection_item_attachments_by_name(self, account_id: str, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_lap_track_status_marker_attachment(self, account_id: str, lap_track_status_marker_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_lap_track_status_marker_collection_item_attachment(self, account_id: str, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_lap_track_status_marker_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_track_status_marker_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_track_status_marker_attachment(
            add_attached_file_response.account_id,
            lap_track_status_marker_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_track_status_marker_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_track_status_marker_id, None, None)

    async def _set_lap_track_status_marker_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_lap_track_status_marker_collection_item_attachment(
            add_attached_file_response.account_id,
            lap_track_status_marker_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, lap_track_status_marker_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, lap_track_status_marker_id, collection_name, collection_item_id, None, None)

    async def _upload_lap_track_status_marker_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_track_status_marker_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_track_status_marker_id, source_path, file_name)

            return await self._set_lap_track_status_marker_attachment_server_state_to_completed(add_attached_file_response, lap_track_status_marker_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_track_status_marker_id, source_path, file_name, message=e)

    async def _upload_lap_track_status_marker_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_track_status_marker_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_lap_track_status_marker_collection_item_attachment_server_state_to_completed(add_attached_file_response, lap_track_status_marker_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, lap_track_status_marker_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_lap_track_status_marker(self, account_id: str, lap_track_status_marker_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_track_status_marker.
        
        :param account_id: str, 
        :param lap_track_status_marker_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_track_status_marker_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_track_status_marker_id, source_path, model.file_name)

        return await self._upload_lap_track_status_marker_attachment(parsed_response, lap_track_status_marker_id, file, model.file_name)

    async def add_attachment_to_lap_track_status_marker_collection_item(self, account_id: str, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to lap_track_status_marker_collection_item.
        
        :param account_id: str, 
        :param lap_track_status_marker_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, lap_track_status_marker_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, lap_track_status_marker_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_lap_track_status_marker_collection_item_attachment(parsed_response, lap_track_status_marker_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_lap_track_status_marker_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_track_status_marker_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_track_status_marker_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_lap_track_status_marker_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_lap_track_status_marker_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_lap_track_status_marker_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_lap_track_status_marker_attachment(self, account_id: str, lap_track_status_marker_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_lap_track_status_marker_collection_item_attachment(self, account_id: str, lap_track_status_marker_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}LapTrackStatusMarkers/{lap_track_status_marker_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_planned_lap_by_id(self, account_id: str, planned_lap_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}PlannedLaps/{planned_lap_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_planned_lap(self, account_id: str, planned_run_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}PlannedLaps?plannedRunId={planned_run_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_planned_lap(self, account_id: str, planned_lap_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}", update_model)
        return response.is_success

    async def delete_planned_lap(self, account_id: str, planned_lap_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}")
        return response.is_success

    async def get_planned_lap_attachments_by_id(self, account_id: str, planned_lap_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_planned_lap_attachments_by_name(self, account_id: str, planned_lap_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_planned_lap_collection_item_attachments_by_id(self, account_id: str, planned_lap_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_planned_lap_collection_item_attachments_by_name(self, account_id: str, planned_lap_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_planned_lap_attachment(self, account_id: str, planned_lap_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_planned_lap_collection_item_attachment(self, account_id: str, planned_lap_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_planned_lap_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_lap_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_planned_lap_attachment(
            add_attached_file_response.account_id,
            planned_lap_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, planned_lap_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, planned_lap_id, None, None)

    async def _set_planned_lap_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_lap_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_planned_lap_collection_item_attachment(
            add_attached_file_response.account_id,
            planned_lap_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, planned_lap_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, planned_lap_id, collection_name, collection_item_id, None, None)

    async def _upload_planned_lap_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_lap_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_lap_id, source_path, file_name)

            return await self._set_planned_lap_attachment_server_state_to_completed(add_attached_file_response, planned_lap_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_lap_id, source_path, file_name, message=e)

    async def _upload_planned_lap_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, planned_lap_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_lap_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_planned_lap_collection_item_attachment_server_state_to_completed(add_attached_file_response, planned_lap_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, planned_lap_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_planned_lap(self, account_id: str, planned_lap_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to planned_lap.
        
        :param account_id: str, 
        :param planned_lap_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, planned_lap_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, planned_lap_id, source_path, model.file_name)

        return await self._upload_planned_lap_attachment(parsed_response, planned_lap_id, file, model.file_name)

    async def add_attachment_to_planned_lap_collection_item(self, account_id: str, planned_lap_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to planned_lap_collection_item.
        
        :param account_id: str, 
        :param planned_lap_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, planned_lap_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, planned_lap_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_planned_lap_collection_item_attachment(parsed_response, planned_lap_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_planned_lap_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_planned_lap_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_planned_lap_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_planned_lap_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_planned_lap_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_planned_lap_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_planned_lap_attachment(self, account_id: str, planned_lap_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_planned_lap_collection_item_attachment(self, account_id: str, planned_lap_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}PlannedLaps/{planned_lap_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_state_by_id(self, account_id: str, issue_list_state_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListStates/{issue_list_state_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_state(self, account_id: str, issue_list_workflow_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListStates?issueListWorkflowId={issue_list_workflow_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_state(self, account_id: str, issue_list_state_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}", update_model)
        return response.is_success

    async def delete_issue_list_state(self, account_id: str, issue_list_state_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}")
        return response.is_success

    async def get_issue_list_state_attachments_by_id(self, account_id: str, issue_list_state_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_state_attachments_by_name(self, account_id: str, issue_list_state_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_state_collection_item_attachments_by_id(self, account_id: str, issue_list_state_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_state_collection_item_attachments_by_name(self, account_id: str, issue_list_state_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_state_attachment(self, account_id: str, issue_list_state_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_state_collection_item_attachment(self, account_id: str, issue_list_state_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_state_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_state_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_state_attachment(
            add_attached_file_response.account_id,
            issue_list_state_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_state_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_state_id, None, None)

    async def _set_issue_list_state_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_state_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_state_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_state_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_state_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_state_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_state_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_state_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_state_id, source_path, file_name)

            return await self._set_issue_list_state_attachment_server_state_to_completed(add_attached_file_response, issue_list_state_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_state_id, source_path, file_name, message=e)

    async def _upload_issue_list_state_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_state_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_state_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_state_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_state_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_state_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_state(self, account_id: str, issue_list_state_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_state.
        
        :param account_id: str, 
        :param issue_list_state_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_state_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_state_id, source_path, model.file_name)

        return await self._upload_issue_list_state_attachment(parsed_response, issue_list_state_id, file, model.file_name)

    async def add_attachment_to_issue_list_state_collection_item(self, account_id: str, issue_list_state_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_state_collection_item.
        
        :param account_id: str, 
        :param issue_list_state_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_state_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_state_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_state_collection_item_attachment(parsed_response, issue_list_state_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_state_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_state_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_state_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_state_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_state_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_state_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_state_attachment(self, account_id: str, issue_list_state_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_state_collection_item_attachment(self, account_id: str, issue_list_state_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListStates/{issue_list_state_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_transition_by_id(self, account_id: str, issue_list_transition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_transition(self, account_id: str, issue_list_workflow_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListTransitions?issueListWorkflowId={issue_list_workflow_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_transition(self, account_id: str, issue_list_transition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}", update_model)
        return response.is_success

    async def delete_issue_list_transition(self, account_id: str, issue_list_transition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}")
        return response.is_success

    async def get_issue_list_transition_attachments_by_id(self, account_id: str, issue_list_transition_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_transition_attachments_by_name(self, account_id: str, issue_list_transition_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_transition_collection_item_attachments_by_id(self, account_id: str, issue_list_transition_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_transition_collection_item_attachments_by_name(self, account_id: str, issue_list_transition_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_transition_attachment(self, account_id: str, issue_list_transition_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_transition_collection_item_attachment(self, account_id: str, issue_list_transition_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_transition_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_transition_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_transition_attachment(
            add_attached_file_response.account_id,
            issue_list_transition_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_transition_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_transition_id, None, None)

    async def _set_issue_list_transition_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_transition_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_transition_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_transition_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_transition_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_transition_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_transition_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_transition_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_transition_id, source_path, file_name)

            return await self._set_issue_list_transition_attachment_server_state_to_completed(add_attached_file_response, issue_list_transition_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_transition_id, source_path, file_name, message=e)

    async def _upload_issue_list_transition_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_transition_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_transition_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_transition_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_transition_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_transition_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_transition(self, account_id: str, issue_list_transition_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_transition.
        
        :param account_id: str, 
        :param issue_list_transition_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_transition_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_transition_id, source_path, model.file_name)

        return await self._upload_issue_list_transition_attachment(parsed_response, issue_list_transition_id, file, model.file_name)

    async def add_attachment_to_issue_list_transition_collection_item(self, account_id: str, issue_list_transition_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_transition_collection_item.
        
        :param account_id: str, 
        :param issue_list_transition_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_transition_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_transition_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_transition_collection_item_attachment(parsed_response, issue_list_transition_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_transition_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_transition_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_transition_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_transition_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_transition_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_transition_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_transition_attachment(self, account_id: str, issue_list_transition_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_transition_collection_item_attachment(self, account_id: str, issue_list_transition_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListTransitions/{issue_list_transition_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_workflow_by_id(self, account_id: str, issue_list_workflow_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_issue_list_workflows(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}IssueListWorkflows"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_workflow(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListWorkflows?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_workflow(self, account_id: str, issue_list_workflow_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}", update_model)
        return response.is_success

    async def delete_issue_list_workflow(self, account_id: str, issue_list_workflow_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}")
        return response.is_success

    async def get_issue_list_workflow_attachments_by_id(self, account_id: str, issue_list_workflow_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_workflow_attachments_by_name(self, account_id: str, issue_list_workflow_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_workflow_collection_item_attachments_by_id(self, account_id: str, issue_list_workflow_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_workflow_collection_item_attachments_by_name(self, account_id: str, issue_list_workflow_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_workflow_attachment(self, account_id: str, issue_list_workflow_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_workflow_collection_item_attachment(self, account_id: str, issue_list_workflow_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_workflow_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_workflow_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_workflow_attachment(
            add_attached_file_response.account_id,
            issue_list_workflow_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_workflow_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_workflow_id, None, None)

    async def _set_issue_list_workflow_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_workflow_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_workflow_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_workflow_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_workflow_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_workflow_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_workflow_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_workflow_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_workflow_id, source_path, file_name)

            return await self._set_issue_list_workflow_attachment_server_state_to_completed(add_attached_file_response, issue_list_workflow_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_workflow_id, source_path, file_name, message=e)

    async def _upload_issue_list_workflow_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_workflow_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_workflow_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_workflow_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_workflow_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_workflow_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_workflow(self, account_id: str, issue_list_workflow_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_workflow.
        
        :param account_id: str, 
        :param issue_list_workflow_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_workflow_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_workflow_id, source_path, model.file_name)

        return await self._upload_issue_list_workflow_attachment(parsed_response, issue_list_workflow_id, file, model.file_name)

    async def add_attachment_to_issue_list_workflow_collection_item(self, account_id: str, issue_list_workflow_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_workflow_collection_item.
        
        :param account_id: str, 
        :param issue_list_workflow_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_workflow_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_workflow_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_workflow_collection_item_attachment(parsed_response, issue_list_workflow_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_workflow_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_workflow_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_workflow_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_workflow_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_workflow_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_workflow_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_workflow_attachment(self, account_id: str, issue_list_workflow_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_workflow_collection_item_attachment(self, account_id: str, issue_list_workflow_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListWorkflows/{issue_list_workflow_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_issue_type_by_id(self, account_id: str, issue_list_issue_type_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_issue_list_issue_types(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}IssueListIssueTypes"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_issue_type(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListIssueTypes?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_issue_type(self, account_id: str, issue_list_issue_type_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}", update_model)
        return response.is_success

    async def delete_issue_list_issue_type(self, account_id: str, issue_list_issue_type_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}")
        return response.is_success

    async def get_issue_list_issue_type_attachments_by_id(self, account_id: str, issue_list_issue_type_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_issue_type_attachments_by_name(self, account_id: str, issue_list_issue_type_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_issue_type_collection_item_attachments_by_id(self, account_id: str, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_issue_type_collection_item_attachments_by_name(self, account_id: str, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_issue_type_attachment(self, account_id: str, issue_list_issue_type_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_issue_type_collection_item_attachment(self, account_id: str, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_issue_type_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_type_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_issue_type_attachment(
            add_attached_file_response.account_id,
            issue_list_issue_type_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_issue_type_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_issue_type_id, None, None)

    async def _set_issue_list_issue_type_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_issue_type_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_issue_type_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_issue_type_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_issue_type_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_issue_type_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_type_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_type_id, source_path, file_name)

            return await self._set_issue_list_issue_type_attachment_server_state_to_completed(add_attached_file_response, issue_list_issue_type_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_type_id, source_path, file_name, message=e)

    async def _upload_issue_list_issue_type_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_type_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_issue_type_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_issue_type_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_type_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_issue_type(self, account_id: str, issue_list_issue_type_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_issue_type.
        
        :param account_id: str, 
        :param issue_list_issue_type_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_issue_type_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_issue_type_id, source_path, model.file_name)

        return await self._upload_issue_list_issue_type_attachment(parsed_response, issue_list_issue_type_id, file, model.file_name)

    async def add_attachment_to_issue_list_issue_type_collection_item(self, account_id: str, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_issue_type_collection_item.
        
        :param account_id: str, 
        :param issue_list_issue_type_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_issue_type_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_issue_type_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_issue_type_collection_item_attachment(parsed_response, issue_list_issue_type_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_issue_type_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_issue_type_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_issue_type_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_issue_type_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_issue_type_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_issue_type_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_issue_type_attachment(self, account_id: str, issue_list_issue_type_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_issue_type_collection_item_attachment(self, account_id: str, issue_list_issue_type_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListIssueTypes/{issue_list_issue_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_math_channel_flat_model_expression_by_id(self, account_id: str, math_channel_flat_model_expression_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}MathChannelFlatModelExpressions/{math_channel_flat_model_expression_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_math_channel_flat_model_expression(self, account_id: str, data_analysis_folder_id: str, dimension: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}MathChannelFlatModelExpressions?dataAnalysisFolderId={data_analysis_folder_id}&dimension={dimension}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_math_channel_flat_model_expression(self, account_id: str, math_channel_flat_model_expression_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}MathChannelFlatModelExpressions/{math_channel_flat_model_expression_id}", update_model)
        return response.is_success

    async def delete_math_channel_flat_model_expression(self, account_id: str, math_channel_flat_model_expression_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}MathChannelFlatModelExpressions/{math_channel_flat_model_expression_id}")
        return response.is_success

    async def get_issue_list_issue_by_id(self, account_id: str, issue_list_issue_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_issue_list_issues(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}IssueListIssues/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_issue(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListIssues?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_issue(self, account_id: str, issue_list_issue_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}", update_model)
        return response.is_success

    async def delete_issue_list_issue(self, account_id: str, issue_list_issue_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}")
        return response.is_success

    async def get_issue_list_issue_attachments_by_id(self, account_id: str, issue_list_issue_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_issue_attachments_by_name(self, account_id: str, issue_list_issue_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_issue_collection_item_attachments_by_id(self, account_id: str, issue_list_issue_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_issue_collection_item_attachments_by_name(self, account_id: str, issue_list_issue_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_issue_attachment(self, account_id: str, issue_list_issue_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_issue_collection_item_attachment(self, account_id: str, issue_list_issue_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_issue_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_issue_attachment(
            add_attached_file_response.account_id,
            issue_list_issue_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_issue_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_issue_id, None, None)

    async def _set_issue_list_issue_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_issue_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_issue_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_issue_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_issue_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_issue_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_id, source_path, file_name)

            return await self._set_issue_list_issue_attachment_server_state_to_completed(add_attached_file_response, issue_list_issue_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_id, source_path, file_name, message=e)

    async def _upload_issue_list_issue_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_issue_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_issue_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_issue_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_issue_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_issue(self, account_id: str, issue_list_issue_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_issue.
        
        :param account_id: str, 
        :param issue_list_issue_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_issue_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_issue_id, source_path, model.file_name)

        return await self._upload_issue_list_issue_attachment(parsed_response, issue_list_issue_id, file, model.file_name)

    async def add_attachment_to_issue_list_issue_collection_item(self, account_id: str, issue_list_issue_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_issue_collection_item.
        
        :param account_id: str, 
        :param issue_list_issue_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_issue_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_issue_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_issue_collection_item_attachment(parsed_response, issue_list_issue_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_issue_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_issue_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_issue_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_issue_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_issue_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_issue_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_issue_attachment(self, account_id: str, issue_list_issue_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_issue_collection_item_attachment(self, account_id: str, issue_list_issue_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListIssues/{issue_list_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_assembly_iteration_by_id(self, account_id: str, assembly_iteration_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_assembly_iterations(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}AssemblyIterations/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_assembly_iteration(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}AssemblyIterations?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_assembly_iteration(self, account_id: str, assembly_iteration_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}", update_model)
        return response.is_success

    async def delete_assembly_iteration(self, account_id: str, assembly_iteration_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}")
        return response.is_success

    async def get_assembly_iteration_attachments_by_id(self, account_id: str, assembly_iteration_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_assembly_iteration_attachments_by_name(self, account_id: str, assembly_iteration_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_assembly_iteration_collection_item_attachments_by_id(self, account_id: str, assembly_iteration_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_assembly_iteration_collection_item_attachments_by_name(self, account_id: str, assembly_iteration_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_assembly_iteration_attachment(self, account_id: str, assembly_iteration_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_assembly_iteration_collection_item_attachment(self, account_id: str, assembly_iteration_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_assembly_iteration_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_assembly_iteration_attachment(
            add_attached_file_response.account_id,
            assembly_iteration_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, assembly_iteration_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, assembly_iteration_id, None, None)

    async def _set_assembly_iteration_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_assembly_iteration_collection_item_attachment(
            add_attached_file_response.account_id,
            assembly_iteration_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, assembly_iteration_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, assembly_iteration_id, collection_name, collection_item_id, None, None)

    async def _upload_assembly_iteration_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_id, source_path, file_name)

            return await self._set_assembly_iteration_attachment_server_state_to_completed(add_attached_file_response, assembly_iteration_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_id, source_path, file_name, message=e)

    async def _upload_assembly_iteration_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_assembly_iteration_collection_item_attachment_server_state_to_completed(add_attached_file_response, assembly_iteration_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_assembly_iteration(self, account_id: str, assembly_iteration_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to assembly_iteration.
        
        :param account_id: str, 
        :param assembly_iteration_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, assembly_iteration_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, assembly_iteration_id, source_path, model.file_name)

        return await self._upload_assembly_iteration_attachment(parsed_response, assembly_iteration_id, file, model.file_name)

    async def add_attachment_to_assembly_iteration_collection_item(self, account_id: str, assembly_iteration_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to assembly_iteration_collection_item.
        
        :param account_id: str, 
        :param assembly_iteration_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, assembly_iteration_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, assembly_iteration_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_assembly_iteration_collection_item_attachment(parsed_response, assembly_iteration_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_assembly_iteration_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_assembly_iteration_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_assembly_iteration_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_assembly_iteration_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_assembly_iteration_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_assembly_iteration_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_assembly_iteration_attachment(self, account_id: str, assembly_iteration_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_assembly_iteration_collection_item_attachment(self, account_id: str, assembly_iteration_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AssemblyIterations/{assembly_iteration_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_session_type_by_id(self, account_id: str, session_type_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}SessionTypes/{session_type_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_session_types(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}SessionTypes"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_session_type(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}SessionTypes?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_session_type(self, account_id: str, session_type_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}", update_model)
        return response.is_success

    async def delete_session_type(self, account_id: str, session_type_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}")
        return response.is_success

    async def get_session_type_attachments_by_id(self, account_id: str, session_type_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionTypes/{session_type_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionTypes/{session_type_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_type_attachments_by_name(self, account_id: str, session_type_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_type_collection_item_attachments_by_id(self, account_id: str, session_type_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionTypes/{session_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionTypes/{session_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_type_collection_item_attachments_by_name(self, account_id: str, session_type_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_session_type_attachment(self, account_id: str, session_type_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_session_type_collection_item_attachment(self, account_id: str, session_type_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_session_type_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_type_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_type_attachment(
            add_attached_file_response.account_id,
            session_type_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_type_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_type_id, None, None)

    async def _set_session_type_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_type_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_type_collection_item_attachment(
            add_attached_file_response.account_id,
            session_type_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_type_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_type_id, collection_name, collection_item_id, None, None)

    async def _upload_session_type_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_type_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_type_id, source_path, file_name)

            return await self._set_session_type_attachment_server_state_to_completed(add_attached_file_response, session_type_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_type_id, source_path, file_name, message=e)

    async def _upload_session_type_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_type_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_type_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_session_type_collection_item_attachment_server_state_to_completed(add_attached_file_response, session_type_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_type_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_session_type(self, account_id: str, session_type_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_type.
        
        :param account_id: str, 
        :param session_type_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_type_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_type_id, source_path, model.file_name)

        return await self._upload_session_type_attachment(parsed_response, session_type_id, file, model.file_name)

    async def add_attachment_to_session_type_collection_item(self, account_id: str, session_type_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_type_collection_item.
        
        :param account_id: str, 
        :param session_type_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_type_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_type_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_session_type_collection_item_attachment(parsed_response, session_type_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_session_type_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_type_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_type_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_session_type_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_type_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_type_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_session_type_attachment(self, account_id: str, session_type_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_session_type_collection_item_attachment(self, account_id: str, session_type_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionTypes/{session_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_json_export_profile_by_id(self, account_id: str, json_export_profile_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}JsonExportProfiles/{json_export_profile_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_json_export_profiles(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}JsonExportProfiles"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_json_export_profile(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}JsonExportProfiles?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_json_export_profile(self, account_id: str, json_export_profile_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JsonExportProfiles/{json_export_profile_id}", update_model)
        return response.is_success

    async def get_json_export_file_by_id(self, account_id: str, json_export_file_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}JsonExportFiles/{json_export_file_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_json_export_file(self, account_id: str, json_export_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JsonExportFiles/{json_export_file_id}", update_model)
        return response.is_success

    async def get_json_export_node_by_id(self, account_id: str, json_export_node_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}JsonExportNodes/{json_export_node_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_json_export_node(self, account_id: str, json_export_file_id: str, is_scope_change_node: bool, mode: int, is_custom_scope: bool, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}JsonExportNodes?jsonExportFileId={json_export_file_id}&isScopeChangeNode={is_scope_change_node}&mode={mode}&isCustomScope={is_custom_scope}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_json_export_node(self, account_id: str, json_export_node_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}JsonExportNodes/{json_export_node_id}", update_model)
        return response.is_success

    async def delete_json_export_node(self, account_id: str, json_export_node_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}JsonExportNodes/{json_export_node_id}")
        return response.is_success

    async def get_column_item_display_definition_by_id(self, account_id: str, column_item_display_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ColumnItemDisplayDefinitions/{column_item_display_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_column_item_display_definitions(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}ColumnItemDisplayDefinitions"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_column_item_display_definition(self, account_id: str, column_item_display_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ColumnItemDisplayDefinitions/{column_item_display_definition_id}", update_model)
        return response.is_success

    async def get_column_item_display_section_definition_by_id(self, account_id: str, column_item_display_section_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ColumnItemDisplaySectionDefinitions/{column_item_display_section_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_column_item_display_section_definition(self, account_id: str, column_item_display_definition_id: str, hide_title: bool, horizontal_content_alignment: int, vertical_content_alignment: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ColumnItemDisplaySectionDefinitions?columnItemDisplayDefinitionId={column_item_display_definition_id}&hideTitle={hide_title}&horizontalContentAlignment={horizontal_content_alignment}&verticalContentAlignment={vertical_content_alignment}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_column_item_display_section_definition(self, account_id: str, column_item_display_section_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ColumnItemDisplaySectionDefinitions/{column_item_display_section_definition_id}", update_model)
        return response.is_success

    async def delete_column_item_display_section_definition(self, account_id: str, column_item_display_section_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ColumnItemDisplaySectionDefinitions/{column_item_display_section_definition_id}")
        return response.is_success

    async def get_column_item_display_block_definition_by_id(self, account_id: str, column_item_display_block_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ColumnItemDisplayBlockDefinitions/{column_item_display_block_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_column_item_display_block_definition(self, account_id: str, column_item_display_section_definition_id: str, horizontal_content_alignment: int, vertical_content_alignment: int, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ColumnItemDisplayBlockDefinitions?columnItemDisplaySectionDefinitionId={column_item_display_section_definition_id}&horizontalContentAlignment={horizontal_content_alignment}&verticalContentAlignment={vertical_content_alignment}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_column_item_display_block_definition(self, account_id: str, column_item_display_block_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ColumnItemDisplayBlockDefinitions/{column_item_display_block_definition_id}", update_model)
        return response.is_success

    async def delete_column_item_display_block_definition(self, account_id: str, column_item_display_block_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ColumnItemDisplayBlockDefinitions/{column_item_display_block_definition_id}")
        return response.is_success

    async def get_column_item_display_line_definition_by_id(self, account_id: str, column_item_display_line_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ColumnItemDisplayLineDefinitions/{column_item_display_line_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_column_item_display_line_definition(self, account_id: str, column_item_display_block_definition_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ColumnItemDisplayLineDefinitions?columnItemDisplayBlockDefinitionId={column_item_display_block_definition_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_column_item_display_line_definition(self, account_id: str, column_item_display_line_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ColumnItemDisplayLineDefinitions/{column_item_display_line_definition_id}", update_model)
        return response.is_success

    async def delete_column_item_display_line_definition(self, account_id: str, column_item_display_line_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ColumnItemDisplayLineDefinitions/{column_item_display_line_definition_id}")
        return response.is_success

    async def get_column_item_display_cell_definition_by_id(self, account_id: str, column_item_display_cell_definition_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}ColumnItemDisplayCellDefinitions/{column_item_display_cell_definition_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_column_item_display_cell_definition(self, account_id: str, column_item_display_line_definition_id: str, json_str: str, cell_type: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}ColumnItemDisplayCellDefinitions?columnItemDisplayLineDefinitionId={column_item_display_line_definition_id}&json={json_str}&cellType={cell_type}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_column_item_display_cell_definition(self, account_id: str, column_item_display_cell_definition_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}ColumnItemDisplayCellDefinitions/{column_item_display_cell_definition_id}", update_model)
        return response.is_success

    async def delete_column_item_display_cell_definition(self, account_id: str, column_item_display_cell_definition_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}ColumnItemDisplayCellDefinitions/{column_item_display_cell_definition_id}")
        return response.is_success

    async def get_named_assembly_by_id(self, account_id: str, named_assembly_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def search_for_named_assemblies(self, account_id: str, search_info: AssociatedModelSeachObject, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}NamedAssemblies/Search"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url, search_info)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_named_assembly(self, account_id: str, create_model: AssociationCreateModel, url_params: MutableMapping[str, str]={}) -> ApiGetResult[Mapping | None]:
        url_params["accountId"] = account_id
        response = await self.post_request(account_id, f"{self.api_endpoint}NamedAssemblies?{'&'.join(f'{k}={v}' for k, v in url_params.items())}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_named_assembly(self, account_id: str, named_assembly_id: str, update_model: AssociationUpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}", update_model)
        return response.is_success

    async def delete_named_assembly(self, account_id: str, named_assembly_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}")
        return response.is_success

    async def get_named_assembly_attachments_by_id(self, account_id: str, named_assembly_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_named_assembly_attachments_by_name(self, account_id: str, named_assembly_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_named_assembly_collection_item_attachments_by_id(self, account_id: str, named_assembly_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_named_assembly_collection_item_attachments_by_name(self, account_id: str, named_assembly_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_named_assembly_attachment(self, account_id: str, named_assembly_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_named_assembly_collection_item_attachment(self, account_id: str, named_assembly_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_named_assembly_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, named_assembly_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_named_assembly_attachment(
            add_attached_file_response.account_id,
            named_assembly_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, named_assembly_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, named_assembly_id, None, None)

    async def _set_named_assembly_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, named_assembly_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_named_assembly_collection_item_attachment(
            add_attached_file_response.account_id,
            named_assembly_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, named_assembly_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, named_assembly_id, collection_name, collection_item_id, None, None)

    async def _upload_named_assembly_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, named_assembly_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, named_assembly_id, source_path, file_name)

            return await self._set_named_assembly_attachment_server_state_to_completed(add_attached_file_response, named_assembly_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, named_assembly_id, source_path, file_name, message=e)

    async def _upload_named_assembly_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, named_assembly_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, named_assembly_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_named_assembly_collection_item_attachment_server_state_to_completed(add_attached_file_response, named_assembly_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, named_assembly_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_named_assembly(self, account_id: str, named_assembly_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to named_assembly.
        
        :param account_id: str, 
        :param named_assembly_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, named_assembly_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, named_assembly_id, source_path, model.file_name)

        return await self._upload_named_assembly_attachment(parsed_response, named_assembly_id, file, model.file_name)

    async def add_attachment_to_named_assembly_collection_item(self, account_id: str, named_assembly_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to named_assembly_collection_item.
        
        :param account_id: str, 
        :param named_assembly_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, named_assembly_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, named_assembly_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_named_assembly_collection_item_attachment(parsed_response, named_assembly_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_named_assembly_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_named_assembly_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_named_assembly_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_named_assembly_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_named_assembly_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_named_assembly_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_named_assembly_attachment(self, account_id: str, named_assembly_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_named_assembly_collection_item_attachment(self, account_id: str, named_assembly_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}NamedAssemblies/{named_assembly_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_session_status_by_id(self, account_id: str, session_status_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}SessionStatuses/{session_status_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_session_statuses_for_session(self, account_id: str, session_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}SessionStatuses"

        param_lookup = dict()
        param_lookup["sessionId"] = session_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_session_status(self, account_id: str, session_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}SessionStatuses?sessionId={session_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_session_status(self, account_id: str, session_status_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}", update_model)
        return response.is_success

    async def delete_session_status(self, account_id: str, session_status_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}")
        return response.is_success

    async def get_session_status_attachments_by_id(self, account_id: str, session_status_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionStatuses/{session_status_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionStatuses/{session_status_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_status_attachments_by_name(self, account_id: str, session_status_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_status_collection_item_attachments_by_id(self, account_id: str, session_status_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}SessionStatuses/{session_status_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}SessionStatuses/{session_status_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_session_status_collection_item_attachments_by_name(self, account_id: str, session_status_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_session_status_attachment(self, account_id: str, session_status_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_session_status_collection_item_attachment(self, account_id: str, session_status_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_session_status_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_status_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_status_attachment(
            add_attached_file_response.account_id,
            session_status_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_status_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_status_id, None, None)

    async def _set_session_status_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, session_status_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_session_status_collection_item_attachment(
            add_attached_file_response.account_id,
            session_status_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, session_status_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, session_status_id, collection_name, collection_item_id, None, None)

    async def _upload_session_status_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_status_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_status_id, source_path, file_name)

            return await self._set_session_status_attachment_server_state_to_completed(add_attached_file_response, session_status_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_status_id, source_path, file_name, message=e)

    async def _upload_session_status_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, session_status_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_status_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_session_status_collection_item_attachment_server_state_to_completed(add_attached_file_response, session_status_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, session_status_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_session_status(self, account_id: str, session_status_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_status.
        
        :param account_id: str, 
        :param session_status_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_status_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_status_id, source_path, model.file_name)

        return await self._upload_session_status_attachment(parsed_response, session_status_id, file, model.file_name)

    async def add_attachment_to_session_status_collection_item(self, account_id: str, session_status_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to session_status_collection_item.
        
        :param account_id: str, 
        :param session_status_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, session_status_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, session_status_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_session_status_collection_item_attachment(parsed_response, session_status_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_session_status_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_status_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_status_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_session_status_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_session_status_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_session_status_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_session_status_attachment(self, account_id: str, session_status_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_session_status_collection_item_attachment(self, account_id: str, session_status_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}SessionStatuses/{session_status_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_by_id(self, account_id: str, issue_list_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueLists/{issue_list_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_issue_lists(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}IssueLists"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_issue_list(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueLists?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list(self, account_id: str, issue_list_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}", update_model)
        return response.is_success

    async def get_issue_list_attachments_by_id(self, account_id: str, issue_list_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueLists/{issue_list_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueLists/{issue_list_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_attachments_by_name(self, account_id: str, issue_list_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_collection_item_attachments_by_id(self, account_id: str, issue_list_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueLists/{issue_list_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueLists/{issue_list_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_collection_item_attachments_by_name(self, account_id: str, issue_list_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_attachment(self, account_id: str, issue_list_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_collection_item_attachment(self, account_id: str, issue_list_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_attachment(
            add_attached_file_response.account_id,
            issue_list_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_id, None, None)

    async def _set_issue_list_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_id, source_path, file_name)

            return await self._set_issue_list_attachment_server_state_to_completed(add_attached_file_response, issue_list_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_id, source_path, file_name, message=e)

    async def _upload_issue_list_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list(self, account_id: str, issue_list_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list.
        
        :param account_id: str, 
        :param issue_list_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_id, source_path, model.file_name)

        return await self._upload_issue_list_attachment(parsed_response, issue_list_id, file, model.file_name)

    async def add_attachment_to_issue_list_collection_item(self, account_id: str, issue_list_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_collection_item.
        
        :param account_id: str, 
        :param issue_list_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_collection_item_attachment(parsed_response, issue_list_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_attachment(self, account_id: str, issue_list_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_collection_item_attachment(self, account_id: str, issue_list_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueLists/{issue_list_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_component_by_id(self, account_id: str, issue_list_component_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_component(self, account_id: str, issue_list_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListComponents?issueListId={issue_list_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_component(self, account_id: str, issue_list_component_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}", update_model)
        return response.is_success

    async def delete_issue_list_component(self, account_id: str, issue_list_component_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}")
        return response.is_success

    async def get_issue_list_component_attachments_by_id(self, account_id: str, issue_list_component_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_component_attachments_by_name(self, account_id: str, issue_list_component_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_component_collection_item_attachments_by_id(self, account_id: str, issue_list_component_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_component_collection_item_attachments_by_name(self, account_id: str, issue_list_component_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_component_attachment(self, account_id: str, issue_list_component_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_component_collection_item_attachment(self, account_id: str, issue_list_component_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_component_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_component_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_component_attachment(
            add_attached_file_response.account_id,
            issue_list_component_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_component_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_component_id, None, None)

    async def _set_issue_list_component_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_component_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_component_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_component_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_component_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_component_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_component_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_component_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_component_id, source_path, file_name)

            return await self._set_issue_list_component_attachment_server_state_to_completed(add_attached_file_response, issue_list_component_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_component_id, source_path, file_name, message=e)

    async def _upload_issue_list_component_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_component_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_component_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_component_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_component_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_component_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_component(self, account_id: str, issue_list_component_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_component.
        
        :param account_id: str, 
        :param issue_list_component_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_component_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_component_id, source_path, model.file_name)

        return await self._upload_issue_list_component_attachment(parsed_response, issue_list_component_id, file, model.file_name)

    async def add_attachment_to_issue_list_component_collection_item(self, account_id: str, issue_list_component_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_component_collection_item.
        
        :param account_id: str, 
        :param issue_list_component_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_component_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_component_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_component_collection_item_attachment(parsed_response, issue_list_component_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_component_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_component_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_component_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_component_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_component_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_component_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_component_attachment(self, account_id: str, issue_list_component_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_component_collection_item_attachment(self, account_id: str, issue_list_component_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListComponents/{issue_list_component_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_issue_list_linked_issue_by_id(self, account_id: str, issue_list_linked_issue_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def add_issue_list_linked_issue(self, account_id: str, issue_list_issue_id: str, target_type: int, target_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues?issueListIssueId={issue_list_issue_id}&targetType={target_type}&targetId={target_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_linked_issue(self, account_id: str, issue_list_linked_issue_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}", update_model)
        return response.is_success

    async def delete_issue_list_linked_issue(self, account_id: str, issue_list_linked_issue_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}")
        return response.is_success

    async def get_issue_list_linked_issue_attachments_by_id(self, account_id: str, issue_list_linked_issue_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_linked_issue_attachments_by_name(self, account_id: str, issue_list_linked_issue_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_linked_issue_collection_item_attachments_by_id(self, account_id: str, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_issue_list_linked_issue_collection_item_attachments_by_name(self, account_id: str, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_issue_list_linked_issue_attachment(self, account_id: str, issue_list_linked_issue_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_issue_list_linked_issue_collection_item_attachment(self, account_id: str, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_issue_list_linked_issue_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_linked_issue_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_linked_issue_attachment(
            add_attached_file_response.account_id,
            issue_list_linked_issue_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_linked_issue_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_linked_issue_id, None, None)

    async def _set_issue_list_linked_issue_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_issue_list_linked_issue_collection_item_attachment(
            add_attached_file_response.account_id,
            issue_list_linked_issue_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, issue_list_linked_issue_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, issue_list_linked_issue_id, collection_name, collection_item_id, None, None)

    async def _upload_issue_list_linked_issue_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_linked_issue_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_linked_issue_id, source_path, file_name)

            return await self._set_issue_list_linked_issue_attachment_server_state_to_completed(add_attached_file_response, issue_list_linked_issue_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_linked_issue_id, source_path, file_name, message=e)

    async def _upload_issue_list_linked_issue_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_linked_issue_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_issue_list_linked_issue_collection_item_attachment_server_state_to_completed(add_attached_file_response, issue_list_linked_issue_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, issue_list_linked_issue_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_issue_list_linked_issue(self, account_id: str, issue_list_linked_issue_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_linked_issue.
        
        :param account_id: str, 
        :param issue_list_linked_issue_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_linked_issue_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_linked_issue_id, source_path, model.file_name)

        return await self._upload_issue_list_linked_issue_attachment(parsed_response, issue_list_linked_issue_id, file, model.file_name)

    async def add_attachment_to_issue_list_linked_issue_collection_item(self, account_id: str, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to issue_list_linked_issue_collection_item.
        
        :param account_id: str, 
        :param issue_list_linked_issue_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, issue_list_linked_issue_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, issue_list_linked_issue_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_issue_list_linked_issue_collection_item_attachment(parsed_response, issue_list_linked_issue_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_issue_list_linked_issue_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_linked_issue_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_linked_issue_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_issue_list_linked_issue_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_issue_list_linked_issue_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_issue_list_linked_issue_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_issue_list_linked_issue_attachment(self, account_id: str, issue_list_linked_issue_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_issue_list_linked_issue_collection_item_attachment(self, account_id: str, issue_list_linked_issue_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}IssueListLinkedIssues/{issue_list_linked_issue_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def get_assembly_iteration_history_type_by_id(self, account_id: str, assembly_iteration_history_type_id: str, options: ApiGetOptions) -> ApiGetResult[Mapping | None]:
        url = f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}"

        param_lookup = dict()
        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def get_all_assembly_iteration_history_types(self, account_id: str, options: ApiGetOptions) -> ApiGetResult[List[Mapping] | None]:
        url = f"{self.api_endpoint}AssemblyIterationHistoryTypes"

        param_lookup = dict()
        if account_id is not None and len(account_id) > 0:
            param_lookup["accountId"] = account_id

        url_parameters = self.build_url_parameters(options, param_lookup)

        if url_parameters is not None and len(url_parameters) > 0:
            url += "?" + url_parameters

        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def add_assembly_iteration_history_type(self, account_id: str, create_model: CreateModel) -> ApiGetResult[Mapping | None]:
        response = await self.post_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes?accountId={account_id}", create_model)
        
        if not response.is_success:
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        return ApiGetResult(response_object, True, None)

    async def update_assembly_iteration_history_type(self, account_id: str, assembly_iteration_history_type_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}", update_model)
        return response.is_success

    async def delete_assembly_iteration_history_type(self, account_id: str, assembly_iteration_history_type_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}")
        return response.is_success

    async def get_assembly_iteration_history_type_attachments_by_id(self, account_id: str, assembly_iteration_history_type_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_assembly_iteration_history_type_attachments_by_name(self, account_id: str, assembly_iteration_history_type_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_assembly_iteration_history_type_collection_item_attachments_by_id(self, account_id: str, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str, attachment_ids: List[str]) -> ApiGetResult[List[Mapping] | None]:
        # We check this because even though we are suggesting a type in the function definition, in python this is never enforced.
        if isinstance(attachment_ids, str):
            url = f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={attachment_ids}"
        elif isinstance(attachment_ids, List):
            url = f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments?attachmentsIds={','.join(attachment_ids)}"
        else:
            raise TypeError("attachment_ids must be either a list of ids or a string containing a single id")
        
        response = await self.get_request(account_id, url)
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def get_assembly_iteration_history_type_collection_item_attachments_by_name(self, account_id: str, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str, group_name: str) -> ApiGetResult[List[Mapping] | None]:
        response = await self.get_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{group_name}")
        
        if not response.is_success:
            # return ApiGetResult[List[Mapping]](None, False, response.reason_phrase)
            return ApiGetResult(None, False, response.reason_phrase)

        response_string = response.content.decode()
        response_json = json.loads(response_string)
        
        response_object = [o for o in response_json]
        return ApiGetResult(response_object, True, None)

    async def update_assembly_iteration_history_type_attachment(self, account_id: str, assembly_iteration_history_type_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def update_assembly_iteration_history_type_collection_item_attachment(self, account_id: str, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str, attached_file_id: str, update_model: UpdateModel) -> bool:
        response = await self.put_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}", update_model)
        return response.is_success

    async def _set_assembly_iteration_history_type_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_history_type_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_assembly_iteration_history_type_attachment(
            add_attached_file_response.account_id,
            assembly_iteration_history_type_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, assembly_iteration_history_type_id, None, None)
        return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, assembly_iteration_history_type_id, None, None)

    async def _set_assembly_iteration_history_type_collection_item_attachment_server_state_to_completed(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str) -> AddAttachmentResult:
        # update the server attached file state to AvailableOnServer = 2
        update_result = await self.update_assembly_iteration_history_type_collection_item_attachment(
            add_attached_file_response.account_id,
            assembly_iteration_history_type_id,
            collection_name,
            collection_item_id,
            add_attached_file_response.attached_file_id,
            UpdateModel(None, [ParameterUpdateModel("ServerAttachedFileState", "2")])
        )

        if update_result:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.SUCCESS, add_attached_file_response, assembly_iteration_history_type_id, collection_name, collection_item_id, None, None)
        return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS, add_attached_file_response, assembly_iteration_history_type_id, collection_name, collection_item_id, None, None)

    async def _upload_assembly_iteration_history_type_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_history_type_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_history_type_id, source_path, file_name)

            return await self._set_assembly_iteration_history_type_attachment_server_state_to_completed(add_attached_file_response, assembly_iteration_history_type_id)
        except Exception as e:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_history_type_id, source_path, file_name, message=e)

    async def _upload_assembly_iteration_history_type_collection_item_attachment(self, add_attached_file_response: ApiAddAttachedFileResponse, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str, file, file_name: str) -> AddAttachmentResult:
        headers = {
            "x-amz-tagging": f"AccountId={add_attached_file_response.account_id}&UserId={add_attached_file_response.user_id}",
            "User-Agent": f"hhdm_apiclient_wrapper (python) {self.get_version()} {add_attached_file_response.user_id}"
        }
        source_path = file if isinstance(file, str) else None

        try:
            if add_attached_file_response.use_compression:
                upload_result = await self.compress_and_upload_file(add_attached_file_response.url, file, headers)
            else:
                upload_result = await self.upload_file(add_attached_file_response.url, file, headers)

            if not upload_result:
                return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_history_type_id, collection_name, collection_item_id, source_path, file_name)

            return await self._set_assembly_iteration_history_type_collection_item_attachment_server_state_to_completed(add_attached_file_response, assembly_iteration_history_type_id, collection_name, collection_item_id)
        except Exception as e:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_UPLOAD, add_attached_file_response, assembly_iteration_history_type_id, collection_name, collection_item_id, source_path, file_name, message=e)

    async def add_attachment_to_assembly_iteration_history_type(self, account_id: str, assembly_iteration_history_type_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to assembly_iteration_history_type.
        
        :param account_id: str, 
        :param assembly_iteration_history_type_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, assembly_iteration_history_type_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, assembly_iteration_history_type_id, source_path, model.file_name)

        return await self._upload_assembly_iteration_history_type_attachment(parsed_response, assembly_iteration_history_type_id, file, model.file_name)

    async def add_attachment_to_assembly_iteration_history_type_collection_item(self, account_id: str, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str, model: ApiPrepareUploadModel, file) -> AddAttachmentResult:
        r"""Add attachment to assembly_iteration_history_type_collection_item.
        
        :param account_id: str, 
        :param assembly_iteration_history_type_id: str,
        :param collection_name: str,
        :param collection_item_id: str,
        :param model: :class:`ApiPrepareUploadModel <ApiPrepareUploadModel>` upload configuration,
        :param file: path of the file to upload on the local filesystem, or stream-like object to upload
        :return: :class:`AddAttachmentResult <AddAttachmentResult>` object
        :rtype: AddAttachmentResult
        """

        response = await self.post_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments", model)
        source_path = file if isinstance(file, str) else None

        if not response.is_success:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, None, assembly_iteration_history_type_id, collection_name, collection_item_id, source_path, model.file_name)

        response_string = response.content.decode()
        response_object = json.loads(response_string)
        parsed_response = ApiAddAttachedFileResponse.deserialize(**response_object)
        
        if not parsed_response.is_valid:
            return AddCollectionItemAttachmentResult(AddAttachmentStatus.FAILED_TO_ADD, parsed_response, assembly_iteration_history_type_id, collection_name, collection_item_id, source_path, model.file_name)

        return await self._upload_assembly_iteration_history_type_collection_item_attachment(parsed_response, assembly_iteration_history_type_id, collection_name, collection_item_id, file, model.file_name)

    async def retry_assembly_iteration_history_type_attachment(self, add_attachment_result: AddAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_assembly_iteration_history_type_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_assembly_iteration_history_type_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def retry_assembly_iteration_history_type_collection_item_attachment(self, add_attachment_result: AddCollectionItemAttachmentResult, file=None) -> AddAttachmentResult:
        match add_attachment_result.add_attachment_status:
            case AddAttachmentStatus.SUCCESS:
                raise ValueError("Cannot retry a successful file attachment")
            case AddAttachmentStatus.FAILED_TO_ADD:
                raise ValueError("Cannot retry a file attachment that failed to add")
            case AddAttachmentStatus.FAILED_TO_UPLOAD:
                return await self._upload_assembly_iteration_history_type_collection_item_attachment(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id, file or add_attachment_result.file_path, add_attachment_result.file_name)
            case AddAttachmentStatus.FAILED_TO_UPDATE_SERVER_STATUS:
                return await self._set_assembly_iteration_history_type_collection_item_attachment_server_state_to_completed(add_attachment_result.add_attached_file_response, add_attachment_result.entity_id, add_attachment_result.collection_name, add_attachment_result.collection_item_id)
            case _:
                raise NotImplementedError(f"Retry for status {add_attachment_result.add_attachment_status} is not implemented.")

    async def delete_assembly_iteration_history_type_attachment(self, account_id: str, assembly_iteration_history_type_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Attachments/{attached_file_id}")
        return response.is_success

    async def delete_assembly_iteration_history_type_collection_item_attachment(self, account_id: str, assembly_iteration_history_type_id: str, collection_name: str, collection_item_id: str, attached_file_id: str) -> bool:
        response = await self.delete_request(account_id, f"{self.api_endpoint}AssemblyIterationHistoryTypes/{assembly_iteration_history_type_id}/Collections/{collection_name}/{collection_item_id}/Attachments/{attached_file_id}")
        return response.is_success
