diff --git a/CMakeLists.txt b/CMakeLists.txt
index 22af45c..6edbcf1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -118,25 +118,41 @@ ELSE() #BUILD_STATIC_LIBRARY
 
 ADD_LIBRARY(${BUILD_TARGET_NAME} STATIC
     src/generator/config/ruleconvert.cpp
+    src/generator/config/nodemanip.cpp
     src/generator/config/subexport.cpp
     src/generator/template/templates.cpp
-    src/lib/wrapper.cpp
+    src/handler/interfaces.cpp
+    src/handler/multithread.cpp
+    src/handler/webget.cpp
+    src/handler/upload.cpp
+    src/handler/settings.cpp
+    # src/lib/wrapper.cpp
     src/parser/subparser.cpp
+    src/parser/infoparser.cpp
     src/utils/base64/base64.cpp
     src/utils/codepage.cpp
+    src/utils/file.cpp
     src/utils/logger.cpp
     src/utils/md5/md5.cpp
     src/utils/network.cpp
     src/utils/regexp.cpp
     src/utils/string.cpp
+    src/utils/system.cpp
     src/utils/urlencode.cpp)
-TARGET_COMPILE_DEFINITIONS(${BUILD_TARGET_NAME} PRIVATE -DNO_JS_RUNTIME -DNO_WEBGET)
 
-TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PUBLIC src)
+TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE src)
+
+FIND_PACKAGE(inja CONFIG REQUIRED)
+TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE pantor::inja)
+
+FIND_PACKAGE(CURL CONFIG REQUIRED)
+TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE ${CURL_INCLUDE_DIRS})
+TARGET_LINK_LIBRARIES(${BUILD_TARGET_NAME} PRIVATE ${CURL_LIBRARIES})
 
 FIND_PACKAGE(Rapidjson REQUIRED)
 TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE ${RAPIDJSON_INCLUDE_DIRS})
 
+if(OFF)
 FIND_PACKAGE(PkgConfig REQUIRED)
 
 PKG_CHECK_MODULES(YAML_CPP yaml-cpp>=0.6.3 REQUIRED)
@@ -145,6 +161,9 @@ TARGET_LINK_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE ${YAML_CPP_LIBRARY_DIRS})
 TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE ${YAML_CPP_INCLUDE_DIRS})
 TARGET_LINK_LIBRARIES(${BUILD_TARGET_NAME} PRIVATE ${YAML_CPP_LIBRARY})
 TARGET_COMPILE_DEFINITIONS(${BUILD_TARGET_NAME} PRIVATE -DYAML_CPP_STATIC_DEFINE)
+endif()
+FIND_PACKAGE(yaml-cpp CONFIG REQUIRED)
+TARGET_LINK_LIBRARIES(${BUILD_TARGET_NAME} PRIVATE yaml-cpp::yaml-cpp)
 
 FIND_PACKAGE(PCRE2 REQUIRED)
 TARGET_INCLUDE_DIRECTORIES(${BUILD_TARGET_NAME} PRIVATE ${PCRE2_INCLUDE_DIRS})
@@ -164,3 +183,32 @@ ENDIF()
 IF(USING_MALLOC_TRIM)
     TARGET_COMPILE_DEFINITIONS(${BUILD_TARGET_NAME} PRIVATE -DMALLOC_TRIM)
 ENDIF()
+
+# Headers under src/ makes relative includes so directory structure must be kept
+target_include_directories(${BUILD_TARGET_NAME} PUBLIC $<INSTALL_INTERFACE:include>/${BUILD_TARGET_NAME})
+# Install the headers
+install(DIRECTORY src/ DESTINATION include/${BUILD_TARGET_NAME} FILES_MATCHING PATTERN "*.h" PATTERN "src/lib" EXCLUDE)
+
+include(CMakePackageConfigHelpers)
+configure_package_config_file(
+  "${CMAKE_CURRENT_SOURCE_DIR}/unofficial-${BUILD_TARGET_NAME}-config.cmake.in"
+  "${CMAKE_CURRENT_BINARY_DIR}/unofficial-${BUILD_TARGET_NAME}-config.cmake"
+  INSTALL_DESTINATION "share/unofficial-${BUILD_TARGET_NAME}"
+)
+install(
+  FILES "${CMAKE_CURRENT_BINARY_DIR}/unofficial-${BUILD_TARGET_NAME}-config.cmake"
+  DESTINATION "share/unofficial-${BUILD_TARGET_NAME}"
+)
+install(DIRECTORY base DESTINATION share/unofficial-${BUILD_TARGET_NAME})
+
+include(GNUInstallDirs)
+install(
+    TARGETS ${BUILD_TARGET_NAME}
+    EXPORT unofficial-${BUILD_TARGET_NAME}-targets
+    COMPONENT ${BUILD_TARGET_NAME}
+    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
+
+install(EXPORT unofficial-${BUILD_TARGET_NAME}-targets FILE unofficial-${BUILD_TARGET_NAME}-targets.cmake NAMESPACE unofficial::${BUILD_TARGET_NAME}:: DESTINATION share/unofficial-${BUILD_TARGET_NAME})
diff --git a/src/generator/config/nodemanip.cpp b/src/generator/config/nodemanip.cpp
index 6f133cb..cece125 100644
--- a/src/generator/config/nodemanip.cpp
+++ b/src/generator/config/nodemanip.cpp
@@ -49,7 +49,7 @@ int addNodes(std::string link, std::vector<Proxy> &allNodes, int groupID, parse_
 
     // TODO: replace with startsWith if appropriate
     link = replaceAllDistinct(link, "\"", "");
-
+#if 0
     /// script:filepath,arg1,arg2,...
     if(authorized) script_safe_runner(parse_set.js_runtime, parse_set.js_context, [&](qjs::Context &ctx)
     {
@@ -89,6 +89,7 @@ int addNodes(std::string link, std::vector<Proxy> &allNodes, int groupID, parse_
             }
         }
     }, global.scriptCleanContext);
+#endif
             /*
             duk_context *ctx = duktape_init();
             defer(duk_destroy_heap(ctx);)
@@ -382,6 +383,7 @@ void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settin
     {
         if(!x.Script.empty() && ext.authorized)
         {
+#if 0
             script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
             {
                 std::string script = x.Script;
@@ -400,6 +402,7 @@ void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settin
                     script_print_stack(ctx);
                 }
             }, global.scriptCleanContext);
+#endif
             continue;
         }
         if(applyMatcher(x.Match, real_rule, node) && real_rule.size())
@@ -435,6 +438,7 @@ std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, ex
         if(!x.Script.empty() && ext.authorized)
         {
             std::string result;
+#if 0
             script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
             {
                 std::string script = x.Script;
@@ -455,6 +459,7 @@ std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, ex
             }, global.scriptCleanContext);
             if(!result.empty())
                 return result;
+#endif
             continue;
         }
         if(x.Replace.empty())
@@ -486,6 +491,7 @@ void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)
             std::string script = ext.sort_script;
             if(startsWith(script, "path:"))
                 script = fileGet(script.substr(5), false);
+#if 0
             script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
             {
                 try
@@ -508,6 +514,7 @@ void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)
                     script_print_stack(ctx);
                 }
             }, global.scriptCleanContext);
+#endif
         }
         if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)
         {
diff --git a/src/generator/config/nodemanip.h b/src/generator/config/nodemanip.h
index 5bce636..32dcdc0 100644
--- a/src/generator/config/nodemanip.h
+++ b/src/generator/config/nodemanip.h
@@ -5,7 +5,7 @@
 #include <vector>
 #include <limits.h>
 
-#ifndef NO_JS_RUNTIME
+#if 0
 #include <quickjspp.hpp>
 #endif // NO_JS_RUNTIME
 
@@ -24,7 +24,7 @@ struct parse_settings
     std::string *sub_info = nullptr;
     bool authorized = false;
     string_icase_map *request_header = nullptr;
-#ifndef NO_JS_RUNTIME
+#if 0
     qjs::Runtime *js_runtime = nullptr;
     qjs::Context *js_context = nullptr;
 #endif // NO_JS_RUNTIME
diff --git a/src/generator/config/subexport.cpp b/src/generator/config/subexport.cpp
index c77e21b..f71c6cc 100644
--- a/src/generator/config/subexport.cpp
+++ b/src/generator/config/subexport.cpp
@@ -199,7 +199,7 @@ void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string
     {
         filtered_nodelist.emplace_back(rule.substr(2));
     }
-#ifndef NO_JS_RUNTIME
+#if 0
     else if(startsWith(rule, "script:") && ext.authorized)
     {
         script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){
@@ -279,6 +279,11 @@ void proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGr
         singleproxy["name"] = x.Remark;
         singleproxy["server"] = x.Hostname;
         singleproxy["port"] = x.Port;
+        if (!x.PublicKey.empty()){
+            singleproxy["reality-opts"]["public-key"] = x.PublicKey;
+            if (!x.ShortId.empty())
+                singleproxy["reality-opts"]["short-id"] = x.ShortId;
+        }
 
         switch(x.Type)
         {
@@ -361,13 +366,73 @@ void proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGr
                 break;
             case "grpc"_hash:
                 singleproxy["network"] = x.TransferProtocol;
-                singleproxy["servername"] = x.Host;
-                singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
+                // singleproxy["servername"] = x.Host;
+                // singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
+                singleproxy["servername"] = x.ServerName;
+                singleproxy["grpc-opts"]["grpc-mode"] = x.GRPCMode;
+                singleproxy["grpc-opts"]["grpc-service-name"]= x.GRPCServiceName;
                 break;
             default:
                 continue;
             }
             break;
+        case ProxyType::Vless:
+            singleproxy["type"] = "vless";
+            singleproxy["uuid"] = x.UserId;
+            singleproxy["tls"] = x.TLSSecure;
+            if(!x.Host.empty())
+                singleproxy["servername"] = x.Host;
+            if (!x.Flow.empty())
+                singleproxy["flow"] = x.Flow;
+            if(!scv.is_undef())
+                singleproxy["skip-cert-verify"] = scv.get();
+            switch(hash_(x.TransferProtocol))
+            {
+                case "tcp"_hash:
+                    break;
+                case "ws"_hash:
+                    singleproxy["network"] = x.TransferProtocol;
+                    if(ext.clash_new_field_name)
+                    {
+                        singleproxy["ws-opts"]["path"] = x.Path;
+                        if(!x.Host.empty())
+                            singleproxy["ws-opts"]["headers"]["Host"] = x.Host;
+                        if(!x.Edge.empty())
+                            singleproxy["ws-opts"]["headers"]["Edge"] = x.Edge;
+                    }
+                    else
+                    {
+                        singleproxy["ws-path"] = x.Path;
+                        if(!x.Host.empty())
+                            singleproxy["ws-headers"]["Host"] = x.Host;
+                        if(!x.Edge.empty())
+                            singleproxy["ws-headers"]["Edge"] = x.Edge;
+                    }
+                    break;
+                case "http"_hash:
+                    singleproxy["network"] = x.TransferProtocol;
+                    singleproxy["http-opts"]["method"] = "GET";
+                    singleproxy["http-opts"]["path"].push_back(x.Path);
+                    if(!x.Host.empty())
+                        singleproxy["http-opts"]["headers"]["Host"].push_back(x.Host);
+                    if(!x.Edge.empty())
+                        singleproxy["http-opts"]["headers"]["Edge"].push_back(x.Edge);
+                    break;
+                case "h2"_hash:
+                    singleproxy["network"] = x.TransferProtocol;
+                    singleproxy["h2-opts"]["path"] = x.Path;
+                    if(!x.Host.empty())
+                        singleproxy["h2-opts"]["host"].push_back(x.Host);
+                    break;
+                case "grpc"_hash:
+                    singleproxy["network"] = x.TransferProtocol;
+                    singleproxy["grpc-opts"]["grpc-mode"] = x.GRPCMode;
+                    singleproxy["grpc-opts"]["grpc-service-name"] = x.GRPCServiceName;
+                    break;
+                default:
+                    continue;
+            }
+            break;
         case ProxyType::ShadowsocksR:
             //ignoring all nodes with unsupported obfs, protocols and encryption
             if(ext.filter_deprecated)
@@ -441,8 +506,8 @@ void proxyToClash(std::vector<Proxy> &nodes, YAML::Node &yamlnode, const ProxyGr
                 break;
             case "grpc"_hash:
                 singleproxy["network"] = x.TransferProtocol;
-                if(!x.Path.empty())
-                    singleproxy["grpc-opts"]["grpc-service-name"] = x.Path;
+                singleproxy["grpc-opts"]["grpc-mode"] = x.GRPCMode;
+                singleproxy["grpc-opts"]["grpc-service-name"] = x.GRPCServiceName;
                 break;
             case "ws"_hash:
                 singleproxy["network"] = x.TransferProtocol;
diff --git a/src/generator/config/subexport.h b/src/generator/config/subexport.h
index fd77055..13c93d6 100644
--- a/src/generator/config/subexport.h
+++ b/src/generator/config/subexport.h
@@ -3,7 +3,7 @@
 
 #include <string>
 
-#ifndef NO_JS_RUNTIME
+#if 0
 #include <quickjspp.hpp>
 #endif // NO_JS_RUNTIME
 
@@ -46,7 +46,7 @@ struct extra_settings
     extra_settings(const extra_settings&) = delete;
     extra_settings(extra_settings&&) = delete;
 
-#ifndef NO_JS_RUNTIME
+#if 0
     qjs::Runtime *js_runtime = nullptr;
     qjs::Context *js_context = nullptr;
 
diff --git a/src/handler/interfaces.cpp b/src/handler/interfaces.cpp
index 61b0945..53053f3 100644
--- a/src/handler/interfaces.cpp
+++ b/src/handler/interfaces.cpp
@@ -535,7 +535,7 @@ std::string subconverter(RESPONSE_CALLBACK_ARGS)
         lIncludeRemarks = string_array{argIncludeRemark};
     if(!argExcludeRemark.empty() && regValid(argExcludeRemark))
         lExcludeRemarks = string_array{argExcludeRemark};
-
+#if 0
     /// initialize script runtime
     if(authorized && !global.scriptCleanContext)
     {
@@ -544,7 +544,7 @@ std::string subconverter(RESPONSE_CALLBACK_ARGS)
         ext.js_context = new qjs::Context(*ext.js_runtime);
         script_context_init(*ext.js_context);
     }
-
+#endif
     //start parsing urls
     RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();
 
@@ -562,9 +562,10 @@ std::string subconverter(RESPONSE_CALLBACK_ARGS)
     parse_set.sub_info = &subInfo;
     parse_set.authorized = authorized;
     parse_set.request_header = &request.headers;
+#if 0
     parse_set.js_runtime = ext.js_runtime;
     parse_set.js_context = ext.js_context;
-
+#endif
     if(!global.insertUrls.empty() && argEnableInsert)
     {
         groupID = -1;
@@ -660,6 +661,7 @@ std::string subconverter(RESPONSE_CALLBACK_ARGS)
             }
         }
         */
+#if 0
         script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)
         {
             try
@@ -673,6 +675,7 @@ std::string subconverter(RESPONSE_CALLBACK_ARGS)
                 script_print_stack(ctx);
             }
         }, global.scriptCleanContext);
+#endif
     }
 
     //check custom group name
diff --git a/src/handler/interfaces.h b/src/handler/interfaces.h
index 8687736..3bba50b 100644
--- a/src/handler/interfaces.h
+++ b/src/handler/interfaces.h
@@ -3,12 +3,21 @@
 
 #include <string>
 #include <map>
-#include <inja.hpp>
 
 #include "config/ruleset.h"
 #include "generator/config/subexport.h"
 #include "server/webserver.h"
-
+#ifdef _WIN32
+#pragma push_macro("min")
+#pragma push_macro("max")
+#undef min
+#undef max
+#endif
+#include <inja/inja.hpp>
+#ifdef _WIN32
+#pragma pop_macro("min")
+#pragma pop_macro("max")
+#endif
 std::string parseProxy(const std::string &source);
 
 void refreshRulesets(RulesetConfigs &ruleset_list, std::vector<RulesetContent> &rca);
diff --git a/src/handler/settings.cpp b/src/handler/settings.cpp
index a90bec7..c3a0d6a 100644
--- a/src/handler/settings.cpp
+++ b/src/handler/settings.cpp
@@ -469,6 +469,7 @@ void readYAMLConf(YAML::Node &node)
 
     if(node["aliases"].IsSequence())
     {
+#if 0
         webServer.reset_redirect();
         for(size_t i = 0; i < node["aliases"].size(); i++)
         {
@@ -477,6 +478,7 @@ void readYAMLConf(YAML::Node &node)
             node["aliases"][i]["target"] >> target;
             webServer.append_redirect(uri, target);
         }
+#endif
     }
 
     if(node["tasks"].IsSequence())
@@ -501,15 +503,19 @@ void readYAMLConf(YAML::Node &node)
         importItems(vArray, false);
         global.enableCron = !vArray.empty();
         global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
+#if 0
         refresh_schedule();
+#endif
     }
 
     if(node["server"].IsDefined())
     {
         node["server"]["listen"] >> global.listenAddress;
         node["server"]["port"] >> global.listenPort;
+#if 0
         node["server"]["serve_file_root"] >>= webServer.serve_file_root;
         webServer.serve_file = !webServer.serve_file_root.empty();
+#endif
     }
 
     if(node["advanced"].IsDefined())
@@ -699,27 +705,31 @@ void readTOMLConf(toml::value &root)
     {
         global.templateVars[key.as_string()] = value.as_string();
     });
-
+#if 0
     webServer.reset_redirect();
+#endif
     operate_toml_kv_table(toml::find_or<std::vector<toml::table>>(root, "aliases", {}), "uri", "target", [&](const toml::value &key, const toml::value &value)
     {
+#if 0
         webServer.append_redirect(key.as_string(), value.as_string());
+#endif
     });
 
     auto tasks = toml::find_or<std::vector<toml::value>>(root, "tasks", {});
     importItems(tasks, "tasks", false);
     global.cronTasks = toml::get<CronTaskConfigs>(toml::value(tasks));
+#if 0
     refresh_schedule();
-
+#endif
     auto section_server = toml::find(root, "server");
-
+#if 0
     find_if_exist(section_server,
                   "listen", global.listenAddress,
                   "port", global.listenPort,
                   "serve_file_root", webServer.serve_file_root
     );
     webServer.serve_file = !webServer.serve_file_root.empty();
-
+#endif
     auto section_advanced = toml::find(root, "advanced");
 
     std::string log_level;
@@ -996,9 +1006,11 @@ void readConf()
     {
         ini.enter_section("aliases");
         ini.get_items(tempmap);
+#if 0
         webServer.reset_redirect();
         for(auto &x : tempmap)
             webServer.append_redirect(x.first, x.second);
+#endif
     }
 
     if(ini.section_exist("tasks"))
@@ -1009,15 +1021,18 @@ void readConf()
         importItems(vArray, false);
         global.enableCron = !vArray.empty();
         global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray);
+#if 0
         refresh_schedule();
+#endif
     }
 
     ini.enter_section("server");
     ini.get_if_exist("listen", global.listenAddress);
     ini.get_int_if_exist("port", global.listenPort);
+#if 0
     webServer.serve_file_root = ini.get("serve_file_root");
     webServer.serve_file = !webServer.serve_file_root.empty();
-
+#endif
     ini.enter_section("advanced");
     std::string log_level;
     ini.get_if_exist("log_level", log_level);
diff --git a/src/handler/webget.cpp b/src/handler/webget.cpp
index 4433536..2482a5c 100644
--- a/src/handler/webget.cpp
+++ b/src/handler/webget.cpp
@@ -1,6 +1,18 @@
 #include <iostream>
+#ifndef _WIN32
 #include <unistd.h>
-#include <sys/stat.h>
+#else
+#include <io.h>       // 提供Unix风格文件操作
+#include <direct.h>   // 添加目录操作支持
+// 添加Windows特有头文件
+#include <windows.h>
+// 定义POSIX兼容宏
+#define stat _stat
+#define mkdir(dir, mode) _mkdir(dir)
+#define access _access
+#define strcasecmp _stricmp
+#define strncasecmp _strnicmp
+#endif
 //#include <mutex>
 #include <thread>
 #include <atomic>
diff --git a/src/parser/config/proxy.h b/src/parser/config/proxy.h
index 80b2ee0..41ae330 100644
--- a/src/parser/config/proxy.h
+++ b/src/parser/config/proxy.h
@@ -15,6 +15,7 @@ enum class ProxyType
     Shadowsocks,
     ShadowsocksR,
     VMess,
+    Vless,
     Trojan,
     Snell,
     HTTP,
@@ -35,6 +36,8 @@ inline String getProxyTypeName(ProxyType type)
         return "SSR";
     case ProxyType::VMess:
         return "VMess";
+    case ProxyType::Vless:
+        return "Vless";
     case ProxyType::Trojan:
         return "Trojan";
     case ProxyType::Snell:
@@ -81,12 +84,17 @@ struct Proxy
     String FakeType;
     bool TLSSecure = false;
 
+    String Flow;
+    bool FlowShow = false;
+
     String Host;
     String Path;
     String Edge;
 
     String QUICSecure;
     String QUICSecret;
+    String GRPCServiceName;
+    String GRPCMode;
 
     tribool UDP;
     tribool TCPFastOpen;
@@ -127,11 +135,15 @@ struct Proxy
     StringArray Alpn;
 
     uint32_t CWND = 0;
+
+    // String PublicKey;
+    String ShortId;
 };
 
 #define SS_DEFAULT_GROUP "SSProvider"
 #define SSR_DEFAULT_GROUP "SSRProvider"
 #define V2RAY_DEFAULT_GROUP "V2RayProvider"
+#define XRAY_DEFAULT_GROUP "XRayProvider"
 #define SOCKS_DEFAULT_GROUP "SocksProvider"
 #define HTTP_DEFAULT_GROUP "HTTPProvider"
 #define TROJAN_DEFAULT_GROUP "TrojanProvider"
diff --git a/src/parser/subparser.cpp b/src/parser/subparser.cpp
index ca29ece..868043e 100644
--- a/src/parser/subparser.cpp
+++ b/src/parser/subparser.cpp
@@ -39,7 +39,7 @@ void commonConstruct(Proxy &node, ProxyType type, const std::string &group, cons
     node.TLS13 = tls13;
 }
 
-void vmessConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &cipher, const std::string &path, const std::string &host, const std::string &edge, const std::string &tls, const std::string &sni, tribool udp, tribool tfo, tribool scv, tribool tls13, const std::string& underlying_proxy)
+void vmessConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &cipher, const std::string &path, const std::string &host, const std::string &edge, const std::string &tls, const std::string &sni, const std::string &alpn, tribool udp, tribool tfo, tribool scv, tribool tls13, const std::string &underlying_proxy)
 {
     commonConstruct(node, ProxyType::VMess, group, remarks, add, port, udp, tfo, scv, tls13, underlying_proxy);
     node.UserId = id.empty() ? "00000000-0000-0000-0000-000000000000" : id;
@@ -48,19 +48,56 @@ void vmessConstruct(Proxy &node, const std::string &group, const std::string &re
     node.TransferProtocol = net.empty() ? "tcp" : net;
     node.Edge = edge;
     node.ServerName = sni;
+    node.FakeType = type;
+    node.TLSSecure = tls == "tls";
 
-    if(net == "quic")
+    switch(hash_(net))
     {
-        node.QUICSecure = host;
-        node.QUICSecret = path;
+        case "grpc"_hash:
+            node.GRPCMode = type.empty() ? "gun" : type;
+            node.GRPCServiceName = path.empty() ? "/" : urlEncode(urlDecode(trim(path)));
+            break;
+        case "quic"_hash:
+            node.QUICSecure = host;
+            node.QUICSecret = path.empty() ? "/" : trim(path);
+            break;
+        default:
+            node.Host = (host.empty() && !isIPv4(add) && !isIPv6(add)) ? add.data() : trim(host);
+            node.Path = path.empty() ? "/" : trim(path);
+            break;
     }
-    else
+}
+
+void vlessConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &cipher, const std::string &flow, const std::string &mode, const std::string &path, const std::string &host, const std::string &edge, const std::string &tls, const std::string &pkd ,const std::string &sid, tribool udp, tribool tfo, tribool scv, tribool tls13, const std::string &underlying_proxy)
+{
+    commonConstruct(node, ProxyType::Vless, group, remarks, add, port, udp, tfo, scv, tls13, underlying_proxy);
+    node.UserId = id.empty() ? "00000000-0000-0000-0000-000000000000" : id;
+    node.AlterId = to_int(aid);
+    node.EncryptMethod = cipher;
+    node.TransferProtocol = net.empty() ? "tcp" : type=="http" ? "http": net;
+    node.Edge = edge;
+    node.Flow = flow;
+    node.FakeType = type;
+    node.TLSSecure = tls == "tls" || tls == "xtls";
+    node.PublicKey = pkd;
+    node.ShortId = sid;
+
+    switch(hash_(net))
     {
-        node.Host = (host.empty() && !isIPv4(add) && !isIPv6(add)) ? add.data() : trim(host);
-        node.Path = path.empty() ? "/" : trim(path);
+        case "grpc"_hash:
+            node.Host = host;
+            node.GRPCMode = mode.empty() ? "gun" : mode;
+            node.GRPCServiceName = path.empty() ? "/" : urlEncode(urlDecode(trim(path)));
+            break;
+        case "quic"_hash:
+            node.QUICSecure = host;
+            node.QUICSecret = path.empty() ? "/" : trim(path);
+            break;
+        default:
+            node.Host = (host.empty() && !isIPv4(add) && !isIPv6(add)) ? add.data() : trim(host);
+            node.Path = path.empty() ? "/" : urlDecode(trim(path));
+            break;
     }
-    node.FakeType = type;
-    node.TLSSecure = tls == "tls";
 }
 
 void ssrConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &protocol, const std::string &method, const std::string &obfs, const std::string &password, const std::string &obfsparam, const std::string &protoparam, tribool udp, tribool tfo, tribool scv,const std::string& underlying_proxy)
@@ -98,14 +135,17 @@ void httpConstruct(Proxy &node, const std::string &group, const std::string &rem
     node.TLSSecure = tls;
 }
 
-void trojanConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &network, const std::string &host, const std::string &path, bool tlssecure, tribool udp, tribool tfo, tribool scv, tribool tls13, const std::string& underlying_proxy)
+void trojanConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &network, const std::string &mode, const std::string &host, const std::string &path, const std::string &flow, const std::string &tls, tribool udp, tribool tfo, tribool scv, tribool tls13, const std::string& underlying_proxy)
 {
     commonConstruct(node, ProxyType::Trojan, group, remarks, server, port, udp, tfo, scv, tls13, underlying_proxy);
     node.Password = password;
     node.Host = host;
-    node.TLSSecure = tlssecure;
+    node.TLSSecure = tls == "tls" || tls == "xtls";;
     node.TransferProtocol = network.empty() ? "tcp" : network;
     node.Path = path;
+    node.Flow = flow;
+    node.GRPCMode = mode.empty() ? "gun" : mode;
+    node.GRPCServiceName = path.empty() ? "/" : urlEncode(urlDecode(trim(path)));
 }
 
 void snellConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &obfs, const std::string &host, uint16_t version, tribool udp, tribool tfo, tribool scv, const std::string& underlying_proxy)
@@ -117,6 +157,7 @@ void snellConstruct(Proxy &node, const std::string &group, const std::string &re
     node.SnellVersion = version;
 }
 
+
 void wireguardConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &selfIp, const std::string &selfIpv6, const std::string &privKey, const std::string &pubKey, const std::string &psk, const string_array &dns, const std::string &mtu, const std::string &keepalive, const std::string &testUrl, const std::string &clientId, const tribool &udp, const std::string& underlying_proxy)
 {
     commonConstruct(node, ProxyType::WireGuard, group, remarks, server, port, udp, tribool(), tribool(), tribool(), underlying_proxy);
@@ -227,9 +268,18 @@ void hysteria2Construct(Proxy &node, const std::string &group, const std::string
 
 }
 
+void explodeVless(std::string vless, Proxy &node)
+{
+    if(regMatch(vless, "vless://(.*?)@(.*)"))
+    {
+        explodeStdVless(vless, node);
+        return;
+    }
+}
+
 void explodeVmess(std::string vmess, Proxy &node)
 {
-    std::string version, ps, add, port, type, id, aid, net, path, host, tls, sni;
+    std::string version, ps, add, port, type, id, aid, net, path, host, tls, sni, alpn;
     Document jsondata;
     std::vector<std::string> vArray;
 
@@ -274,6 +324,8 @@ void explodeVmess(std::string vmess, Proxy &node)
 
     GetMember(jsondata, "host", host);
     GetMember(jsondata, "sni", sni);
+    GetMember(jsondata, "alpn", alpn);
+
     switch(to_int(version))
     {
     case 1:
@@ -294,14 +346,14 @@ void explodeVmess(std::string vmess, Proxy &node)
 
     add = trim(add);
 
-    vmessConstruct(node, V2RAY_DEFAULT_GROUP, ps, add, port, type, id, aid, net, "auto", path, host, "", tls, sni);
+    vmessConstruct(node, V2RAY_DEFAULT_GROUP, ps, add, port, type, id, aid, net, "auto", path, host, "", tls, sni, alpn);
 }
 
 void explodeVmessConf(std::string content, std::vector<Proxy> &nodes)
 {
     Document json;
     rapidjson::Value nodejson, settings;
-    std::string group, ps, add, port, type, id, aid, net, path, host, edge, tls, cipher, subid, sni;
+    std::string group, ps, add, port, type, id, aid, net, path, host, edge, tls, cipher, subid, sni, alpn;
     tribool udp, tfo, scv;
     int configType;
     uint32_t index = nodes.size();
@@ -372,7 +424,7 @@ void explodeVmessConf(std::string content, std::vector<Proxy> &nodes)
                         }
                     }
                 }
-                vmessConstruct(node, V2RAY_DEFAULT_GROUP, add + ":" + port, add, port, type, id, aid, net, cipher, path, host, edge, tls, "", udp, tfo, scv);
+                vmessConstruct(node, V2RAY_DEFAULT_GROUP, add + ":" + port, add, port, type, id, aid, net, cipher, path, host, edge, tls, "", "", udp, tfo, scv);
                 nodes.emplace_back(std::move(node));
             }
             return;
@@ -425,8 +477,8 @@ void explodeVmessConf(std::string content, std::vector<Proxy> &nodes)
             json["vmess"][i]["requestHost"] >> host;
             json["vmess"][i]["streamSecurity"] >> tls;
             json["vmess"][i]["security"] >> cipher;
-            json["vmess"][i]["sni"] >> sni;
-            vmessConstruct(node, V2RAY_DEFAULT_GROUP, ps, add, port, type, id, aid, net, cipher, path, host, "", tls, sni, udp, tfo, scv);
+            json["vmess"][i]["alpn"] >> alpn;
+            vmessConstruct(node, V2RAY_DEFAULT_GROUP, ps, add, port, type, id, aid, net, cipher, path, host, "", tls, sni, alpn, udp, tfo, scv);
             break;
         case 3: //ss config
             json["vmess"][i]["id"] >> id;
@@ -847,9 +899,9 @@ void explodeHTTPSub(std::string link, Proxy &node)
 
 void explodeTrojan(std::string trojan, Proxy &node)
 {
-    std::string server, port, psk, addition, group, remark, host, path, network;
+    std::string server, port, psk, addition, group, remark, host, path, network, mode, flow, tls;
     tribool tfo, scv;
-    trojan.erase(0, 9);
+    trojan.erase(0, trojan.find("://") + 3);
     string_size pos = trojan.rfind('#');
 
     if(pos != std::string::npos)
@@ -869,13 +921,14 @@ void explodeTrojan(std::string trojan, Proxy &node)
     if(port == "0")
         return;
 
-    host = getUrlArg(addition, "sni");
-    if(host.empty())
-        host = getUrlArg(addition, "peer");
+    host = getUrlArg(addition, strFind(addition,"sni") ? "sni" : strFind(addition,"host") ? "host" : "peer");
     tfo = getUrlArg(addition, "tfo");
     scv = getUrlArg(addition, "allowInsecure");
     group = urlDecode(getUrlArg(addition, "group"));
+    tls = getUrlArg(addition,"security");
+    flow = getUrlArg(addition,"flow");
 
+    // Case ws
     if(getUrlArg(addition, "ws") == "1")
     {
         path = getUrlArg(addition, "wspath");
@@ -891,12 +944,20 @@ void explodeTrojan(std::string trojan, Proxy &node)
         network = "ws";
     }
 
+    // Case GRPC
+    if(getUrlArg(addition, "type") == "grpc")
+    {
+        mode = getUrlArg(addition,"mode");
+        path = getUrlArg(addition, "serviceName");
+        network = "grpc";
+    }
+
     if(remark.empty())
         remark = server + ":" + port;
     if(group.empty())
         group = TROJAN_DEFAULT_GROUP;
 
-    trojanConstruct(node, group, remark, server, port, psk, network, host, path, true, tribool(), tfo, scv);
+    trojanConstruct(node, group, remark, server, port, psk, network, mode, host, path, flow, tls, tribool(), tfo, scv);
 }
 
 void explodeQuan(const std::string &quan, Proxy &node)
@@ -962,7 +1023,7 @@ void explodeQuan(const std::string &quan, Proxy &node)
         if(path.empty())
             path = "/";
 
-        vmessConstruct(node, group, ps, add, port, type, id, aid, net, cipher, path, host, edge, tls, "");
+        vmessConstruct(node, group, ps, add, port, type, id, aid, net, cipher, path, host, edge, tls, "", "");
     }
 }
 
@@ -970,7 +1031,7 @@ void explodeNetch(std::string netch, Proxy &node)
 {
     Document json;
     std::string type, group, remark, address, port, username, password, method, plugin, pluginopts;
-    std::string protocol, protoparam, obfs, obfsparam, id, aid, transprot, faketype, host, edge, path, tls, sni;
+    std::string protocol, protoparam, obfs, obfsparam, id, aid, transprot, faketype, host, edge, path, tls, sni, flow, alpn, mode;
     tribool udp, tfo, scv;
     netch = urlSafeBase64Decode(netch.substr(8));
 
@@ -1032,7 +1093,7 @@ void explodeNetch(std::string netch, Proxy &node)
         sni = GetMember(json, "ServerName");
         if(group.empty())
             group = V2RAY_DEFAULT_GROUP;
-        vmessConstruct(node, group, remark, address, port, faketype, id, aid, transprot, method, path, host, edge, tls, sni, udp, tfo, scv);
+        vmessConstruct(node, group, remark, address, port, faketype, id, aid, transprot, method, path, host, edge, tls, sni, alpn, udp, tfo, scv);
         break;
     case "Socks5"_hash:
         username = GetMember(json, "Username");
@@ -1047,13 +1108,15 @@ void explodeNetch(std::string netch, Proxy &node)
         httpConstruct(node, group, remark, address, port, username, password, type == "HTTPS", tfo, scv);
         break;
     case "Trojan"_hash:
-        host = GetMember(json, "Host");
+        host = GetMember(json, "Servername");
+        if (host.empty())
+            host = GetMember(json, "Host");
         path = GetMember(json, "Path");
         transprot = GetMember(json, "TransferProtocol");
         tls = GetMember(json, "TLSSecure");
         if(group.empty())
             group = TROJAN_DEFAULT_GROUP;
-        trojanConstruct(node, group, remark, address, port, password, transprot, host, path, tls == "true", udp, tfo, scv);
+        trojanConstruct(node, group, remark, address, port, password, transprot, mode, host, path, flow, tls, udp, tfo, scv);
         break;
     case "Snell"_hash:
         obfs = GetMember(json, "OBFS");
@@ -1074,6 +1137,7 @@ void explodeClash(Node yamlnode, std::vector<Proxy> &nodes)
     std::string type = "none", id, aid = "0", net = "tcp", path, host, edge, tls, sni; //vmess
     std::string plugin, pluginopts, pluginopts_mode, pluginopts_host, pluginopts_mux; //ss
     std::string protocol, protoparam, obfs, obfsparam; //ssr
+    std::string flow, mode; //trojan
     std::string user; //socks
     std::string ip, ipv6, private_key, public_key, mtu; //wireguard
     std::string ports, obfs_protocol, up, up_speed, down, down_speed, auth, auth_str,/* obfs, sni,*/ fingerprint, ca, ca_str, recv_window_conn, recv_window, disable_mtu_discovery, hop_interval, alpn; //hysteria
@@ -1106,7 +1170,7 @@ void explodeClash(Node yamlnode, std::vector<Proxy> &nodes)
             singleproxy["alterId"] >>= aid;
             singleproxy["cipher"] >>= cipher;
             net = singleproxy["network"].IsDefined() ? safe_as<std::string>(singleproxy["network"]) : "tcp";
-            singleproxy["servername"] >>= sni;
+            sni = singleproxy["servername"].IsDefined() ? safe_as<std::string>(singleproxy["servername"]) : "";
             switch(hash_(net))
             {
             case "http"_hash:
@@ -1141,7 +1205,7 @@ void explodeClash(Node yamlnode, std::vector<Proxy> &nodes)
             }
             tls = safe_as<std::string>(singleproxy["tls"]) == "true" ? "tls" : "";
 
-            vmessConstruct(node, group, ps, server, port, "", id, aid, net, cipher, path, host, edge, tls, sni, udp, tfo, scv, tribool(), underlying_proxy);
+            vmessConstruct(node, group, ps, server, port, "", id, aid, net, cipher, path, host, edge, tls, sni, alpn,  udp, tfo, scv, tribool(), underlying_proxy);
             break;
         case "ss"_hash:
             group = SS_DEFAULT_GROUP;
@@ -1254,9 +1318,11 @@ void explodeClash(Node yamlnode, std::vector<Proxy> &nodes)
             singleproxy["password"] >>= password;
             singleproxy["sni"] >>= host;
             singleproxy["network"] >>= net;
+            singleproxy["flow"] >>= flow;
             switch(hash_(net))
             {
             case "grpc"_hash:
+                singleproxy["grpc-opts"]["grpc-mode"] >>= mode;
                 singleproxy["grpc-opts"]["grpc-service-name"] >>= path;
                 break;
             case "ws"_hash:
@@ -1268,7 +1334,7 @@ void explodeClash(Node yamlnode, std::vector<Proxy> &nodes)
                 break;
             }
 
-            trojanConstruct(node, group, ps, server, port, password, net, host, path, true, udp, tfo, scv, tribool(),  underlying_proxy);
+            trojanConstruct(node, group, ps, server, port, password, net, mode, host, path, flow, tls, udp, tfo, scv,  underlying_proxy);
             break;
         case "snell"_hash:
             group = SNELL_DEFAULT_GROUP;
@@ -1356,7 +1422,7 @@ void explodeClash(Node yamlnode, std::vector<Proxy> &nodes)
 
 void explodeStdVMess(std::string vmess, Proxy &node)
 {
-    std::string add, port, type, id, aid, net, path, host, tls, remarks;
+    std::string add, port, type, id, aid, net, path, host, tls, sni, alpn, remarks;
     std::string addition;
     vmess = vmess.substr(8);
     string_size pos;
@@ -1371,6 +1437,7 @@ void explodeStdVMess(std::string vmess, Proxy &node)
     if(regGetMatch(vmess, stdvmess_matcher, 8, 0, &net, &tls, &id, &aid, &add, &port, &addition))
         return;
 
+    sni = getUrlArg(addition, "servername");
     switch(hash_(net))
     {
     case "tcp"_hash:
@@ -1394,7 +1461,60 @@ void explodeStdVMess(std::string vmess, Proxy &node)
     if(remarks.empty())
         remarks = add + ":" + port;
 
-    vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, "auto", path, host, "", tls, "");
+    vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, "auto", path, host, "", tls, "", "");
+}
+
+void explodeStdVless(std::string vless, Proxy &node)
+{
+    std::string add, port, type, id, aid, net, flow, pbk, sid, mode, path, host, tls, remarks;
+    std::string addition;
+    vless = vless.substr(8);
+    string_size pos;
+
+    pos = vless.rfind("#");
+    if(pos != vless.npos)
+    {
+        remarks = urlDecode(vless.substr(pos + 1));
+        vless.erase(pos);
+    }
+    const std::string stdvless_matcher = R"(^([\da-f]{4}(?:[\da-f]{4}-){4}[\da-f]{12})@\[?([\d\-a-zA-Z:.]+)\]?:(\d+)(?:\/?\?(.*))?$)";
+    if(regGetMatch(vless, stdvless_matcher, 5, 0, &id, &add, &port, &addition))
+        return;
+
+    tls = getUrlArg(addition,"security");
+    net = getUrlArg(addition,"type");
+    flow = getUrlArg(addition,"flow");
+    pbk = getUrlArg(addition,"pbk");
+    sid = getUrlArg(addition,"sid");
+
+    switch(hash_(net))
+    {
+        case "tcp"_hash:
+        case "ws"_hash:
+        case "h2"_hash:
+            type = getUrlArg(addition, "headerType");
+            host = getUrlArg(addition, strFind(addition,"sni") ? "sni" : "host");
+            path = getUrlArg(addition, "path");
+            break;
+        case "grpc"_hash:
+            host = getUrlArg(addition, "sni");
+            path = getUrlArg(addition, "serviceName");
+            mode = getUrlArg(addition, "mode");
+            break;
+        case "quic"_hash:
+            type = getUrlArg(addition, "headerType");
+            host = getUrlArg(addition, strFind(addition,"sni") ? "sni" : "quicSecurity");
+            path = getUrlArg(addition, "key");
+            break;
+        default:
+            return;
+    }
+
+    if(remarks.empty())
+        remarks = add + ":" + port;
+
+    vlessConstruct(node, XRAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, "auto", flow, mode, path, host, "", tls, pbk, sid);
+    return;
 }
 
 void explodeShadowrocket(std::string rocket, Proxy &node)
@@ -1438,7 +1558,7 @@ void explodeShadowrocket(std::string rocket, Proxy &node)
     if(remarks.empty())
         remarks = add + ":" + port;
 
-    vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, cipher, path, host, "", tls, "");
+    vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, cipher, path, host, "", tls, "", "");
 }
 
 void explodeKitsunebi(std::string kit, Proxy &node)
@@ -1476,7 +1596,7 @@ void explodeKitsunebi(std::string kit, Proxy &node)
     if(remarks.empty())
         remarks = add + ":" + port;
 
-    vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, cipher, path, host, "", tls, "");
+    vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, add, port, type, id, aid, net, cipher, path, host, "", tls, "", "");
 }
 
 
@@ -1607,7 +1727,7 @@ bool explodeSurge(std::string surge, std::vector<Proxy> &nodes)
     {
         std::string remarks, server, port, method, username, password; //common
         std::string plugin, pluginopts, pluginopts_mode, pluginopts_host, mod_url, mod_md5; //ss
-        std::string id, net, tls, host, edge, path; //v2
+        std::string id, net, tls, host, edge, path, sni, alpn, mode, flow; //v2
         std::string protocol, protoparam; //ssr
         std::string section, ip, ipv6, private_key, public_key, mtu, test_url, client_id, peer, keepalive; //wireguard
         string_array dns_servers;
@@ -1839,7 +1959,7 @@ bool explodeSurge(std::string surge, std::vector<Proxy> &nodes)
                 }
             }
 
-            vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, server, port, "", id, aead, net, method, path, host, edge, tls, "", udp, tfo, scv, tls13);
+            vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, server, port, "", id, aead, net, method, path, host, edge, tls, "", "", udp, tfo, scv, tls13);
             break;
         case "http"_hash: //http proxy
             server = trim(configs[1]);
@@ -1905,7 +2025,7 @@ bool explodeSurge(std::string surge, std::vector<Proxy> &nodes)
                 }
             }
 
-            trojanConstruct(node, TROJAN_DEFAULT_GROUP, remarks, server, port, password, "", host, "", true, udp, tfo, scv);
+            trojanConstruct(node, TROJAN_DEFAULT_GROUP, remarks, server, port, password, "", mode, host, "", flow, tls, udp, tfo, scv);
             break;
         case "snell"_hash:
             server = trim(configs[1]);
@@ -2179,7 +2299,7 @@ bool explodeSurge(std::string surge, std::vector<Proxy> &nodes)
                 if(remarks.empty())
                     remarks = server + ":" + port;
 
-                vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, server, port, "", id, aead, net, method, path, host, "", tls, "", udp, tfo, scv, tls13);
+                vmessConstruct(node, V2RAY_DEFAULT_GROUP, remarks, server, port, "", id, aead, net, method, path, host, "", tls, "", "", udp, tfo, scv, tls13);
                 break;
             case "trojan"_hash: //quantumult x style trojan link
                 server = trim(configs[0].substr(0, configs[0].rfind(':')));
@@ -2226,8 +2346,10 @@ bool explodeSurge(std::string surge, std::vector<Proxy> &nodes)
                 }
                 if(remarks.empty())
                     remarks = server + ":" + port;
+                if(host.empty() && !isIPv4(server) && !isIPv6(server))
+                    host = server;
 
-                trojanConstruct(node, TROJAN_DEFAULT_GROUP, remarks, server, port, password, "", host, "", tls == "true", udp, tfo, scv, tls13);
+                trojanConstruct(node, TROJAN_DEFAULT_GROUP, remarks, server, port, password, "", mode, host, "", flow, tls, udp, tfo, scv, tls13);
                 break;
             case "http"_hash: //quantumult x style http links
                 server = trim(configs[0].substr(0, configs[0].rfind(':')));
@@ -2426,6 +2548,8 @@ void explode(const std::string &link, Proxy &node)
         explodeSSR(link, node);
     else if(startsWith(link, "vmess://") || startsWith(link, "vmess1://"))
         explodeVmess(link, node);
+    else if(strFind(link, "vless://") || strFind(link, "vless1://"))
+        explodeVless(link, node);
     else if(startsWith(link, "ss://"))
         explodeSS(link, node);
     else if(startsWith(link, "socks://") || startsWith(link, "https://t.me/socks") || startsWith(link, "tg://socks"))
@@ -2434,7 +2558,7 @@ void explode(const std::string &link, Proxy &node)
         explodeHTTP(link, node);
     else if(startsWith(link, "Netch://"))
         explodeNetch(link, node);
-    else if(startsWith(link, "trojan://"))
+    else if(startsWith(link, "trojan://") || strFind(link, "trojan-go://"))
         explodeTrojan(link, node);
     else if (strFind(link, "hysteria2://") || strFind(link, "hy2://"))
         explodeHysteria2(link, node);
@@ -2485,7 +2609,9 @@ void explodeSub(std::string sub, std::vector<Proxy> &nodes)
     //try to parse as normal subscription
     if(!processed)
     {
-        sub = urlSafeBase64Decode(sub);
+        // probably Base64-encoded string
+        if(!regFind(sub, "[^a-zA-Z0-9+/=]")) 
+            sub = urlSafeBase64Decode(sub);
         if(regFind(sub, "(vmess|shadowsocks|http|trojan)\\s*?="))
         {
             if(explodeSurge(sub, nodes))
diff --git a/src/parser/subparser.h b/src/parser/subparser.h
index 53e1d6c..b4f9257 100644
--- a/src/parser/subparser.h
+++ b/src/parser/subparser.h
@@ -20,12 +20,13 @@ enum class ConfType
     Local
 };
 
-void vmessConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &cipher, const std::string &path, const std::string &host, const std::string &edge, const std::string &tls, const std::string &sni, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
+void vmessConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &cipher, const std::string &path, const std::string &host, const std::string &edge, const std::string &tls, const std::string &sni, const std::string &alpn, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
+void vlessConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &add, const std::string &port, const std::string &type, const std::string &id, const std::string &aid, const std::string &net, const std::string &cipher, const std::string &flow, const std::string &mode, const std::string &path, const std::string &host, const std::string &edge, const std::string &tls, const std::string &pkd ,const std::string &sid, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
 void ssrConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &protocol, const std::string &method, const std::string &obfs, const std::string &password, const std::string &obfsparam, const std::string &protoparam, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), const std::string &underlying_proxy = "");
 void ssConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &method, const std::string &plugin, const std::string &pluginopts, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
 void socksConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &username, const std::string &password, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), const std::string &underlying_proxy = "");
 void httpConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &username, const std::string &password, bool tls, tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
-void trojanConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &network, const std::string &host, const std::string &path, bool tlssecure, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
+void trojanConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &network,  const std::string &mode, const std::string &host, const std::string &path, const std::string &flow, const std::string &tls, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), tribool tls13 = tribool(), const std::string &underlying_proxy = "");
 void snellConstruct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port, const std::string &password, const std::string &obfs, const std::string &host, uint16_t version = 0, tribool udp = tribool(), tribool tfo = tribool(), tribool scv = tribool(), const std::string &underlying_proxy = "");
 
 void hysteriaConstruct(
@@ -61,11 +62,13 @@ void hysteriaConstruct(
 void hysteria2Construct(Proxy &node, const std::string &group, const std::string &remarks, const std::string &server, const std::string &port,const std::string &up, const std::string &down, const std::string &password, const std::string &obfs, const std::string &obfs_password, const std::string &sni, const std::string &fingerprint, const string_array &alpn, const std::string &ca, const std::string &caStr, const std::string &cwnd, tribool tfo, tribool scv, const std::string &underlying_proxy = "");
 
 void explodeVmess(std::string vmess, Proxy &node);
+void explodeVless(std::string vless, Proxy &node);
 void explodeSSR(std::string ssr, Proxy &node);
 void explodeSS(std::string ss, Proxy &node);
 void explodeTrojan(std::string trojan, Proxy &node);
 void explodeQuan(const std::string &quan, Proxy &node);
 void explodeStdVMess(std::string vmess, Proxy &node);
+void explodeStdVless(std::string vless, Proxy &node);
 void explodeShadowrocket(std::string kit, Proxy &node);
 void explodeKitsunebi(std::string kit, Proxy &node);
 void explodeHysteria2(std::string hysteria2, Proxy &node);
diff --git a/src/script/script_quickjs.h b/src/script/script_quickjs.h
index 86defed..83ec5f7 100644
--- a/src/script/script_quickjs.h
+++ b/src/script/script_quickjs.h
@@ -4,7 +4,7 @@
 #include "parser/config/proxy.h"
 #include "utils/defer.h"
 
-#ifndef NO_JS_RUNTIME
+#if 0
 
 #include <quickjspp.hpp>
 
diff --git a/src/utils/file.cpp b/src/utils/file.cpp
index 3d1928a..9b52a2e 100644
--- a/src/utils/file.cpp
+++ b/src/utils/file.cpp
@@ -1,6 +1,6 @@
 #include <string>
 #include <fstream>
-#include <sys/stat.h>
+#include <filesystem>
 
 #include "utils/string.h"
 
@@ -60,12 +60,9 @@ std::string fileGet(const std::string &path, bool scope_limit)
 
 bool fileExist(const std::string &path, bool scope_limit)
 {
-    //using c++17 standard, but may cause problem on clang
-    //return std::filesystem::exists(path);
     if(scope_limit && !isInScope(path))
         return false;
-    struct stat st;
-    return stat(path.data(), &st) == 0 && S_ISREG(st.st_mode);
+    return std::filesystem::exists(path);
 }
 
 bool fileCopy(const std::string &source, const std::string &dest)
diff --git a/src/utils/file.h b/src/utils/file.h
index e7daacf..740dc13 100644
--- a/src/utils/file.h
+++ b/src/utils/file.h
@@ -2,19 +2,33 @@
 #define FILE_H_INCLUDED
 
 #include <string>
-#include <string.h>
+#include <cstring>
 
 #ifdef _WIN32
-#include <unistd.h>
+#include <direct.h>
+#include <windows.h>
+#include <io.h>
 #define PATH_SLASH "\\"
 #else
-#include <sys/types.h>
 #include <sys/stat.h>
-#define PATH_SLASH "//"
-#endif // _WIN32
+#include <unistd.h>
+#define PATH_SLASH "/"
+#endif
 
 #include <sys/types.h>
+
+#ifdef _WIN32
+struct dirent {
+    char d_name[MAX_PATH];
+};
+using DIR = struct {
+    HANDLE hFind;
+    WIN32_FIND_DATAA findData;
+    dirent dirEnt;
+};
+#else
 #include <dirent.h>
+#endif
 
 std::string fileGet(const std::string &path, bool scope_limit = false);
 bool fileExist(const std::string &path, bool scope_limit = false);
@@ -24,29 +38,49 @@ int fileWrite(const std::string &path, const std::string &content, bool overwrit
 template<typename F>
 int operateFiles(const std::string &path, F &&op)
 {
-    DIR* dir = opendir(path.data());
+#ifdef _WIN32
+    WIN32_FIND_DATAA findData;
+    HANDLE hFind = FindFirstFileA((path + "\\*").c_str(), &findData);
+    if(hFind == INVALID_HANDLE_VALUE)
+        return -1;
+    
+    do {
+        if(strcmp(findData.cFileName, ".") != 0 && 
+           strcmp(findData.cFileName, "..") != 0) {
+            if(op(findData.cFileName)) {
+                FindClose(hFind);
+                return 0;
+            }
+        }
+    } while(FindNextFileA(hFind, &findData));
+    
+    FindClose(hFind);
+    return 0;
+#else
+    DIR* dir = opendir(path.c_str());
     if(!dir)
         return -1;
+    
     struct dirent* dp;
-    while((dp = readdir(dir)) != NULL)
-    {
-        if(strcmp(dp->d_name, ".") != 0 && strcmp(dp->d_name, "..") != 0)
-        {
+    while((dp = readdir(dir)) != nullptr) {
+        if(strcmp(dp->d_name, ".") != 0 && 
+           strcmp(dp->d_name, "..") != 0) {
             if(op(dp->d_name))
                 break;
         }
     }
     closedir(dir);
     return 0;
+#endif
 }
 
 inline int md(const char *path)
 {
 #ifdef _WIN32
-    return mkdir(path);
+    return _mkdir(path);
 #else
     return mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
-#endif // _WIN32
+#endif
 }
 
 #endif // FILE_H_INCLUDED
diff --git a/src/utils/logger.cpp b/src/utils/logger.cpp
index ec6353b..f183320 100644
--- a/src/utils/logger.cpp
+++ b/src/utils/logger.cpp
@@ -1,9 +1,13 @@
 #include <string>
 #include <iostream>
 #include <thread>
-#include <sys/time.h>
-#include <sys/types.h>
+#include <chrono>
+#include <ctime>
+#ifdef _WIN32
+#include <windows.h>
+#else
 #include <unistd.h>
+#endif
 
 #include "handler/settings.h"
 #include "defer.h"
@@ -12,15 +16,20 @@
 
 std::string getTime(int type)
 {
-    time_t lt;
+    auto now = std::chrono::system_clock::now();
+    auto now_time_t = std::chrono::system_clock::to_time_t(now);
+    auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(
+                            now.time_since_epoch()) % 1000000;
     char tmpbuf[32], cMillis[7];
     std::string format;
-    timeval tv = {};
-    gettimeofday(&tv, nullptr);
-    snprintf(cMillis, 7, "%.6ld", (long)tv.tv_usec);
-    lt = time(nullptr);
-    struct tm *local = localtime(&lt);
-    switch(type)
+    snprintf(cMillis, 7, "%06d", static_cast<int>(microseconds.count()));
+    struct tm local;
+#ifdef _WIN32
+    localtime_s(&local, &now_time_t);
+#else
+    localtime_r(&now_time_t, &local);
+#endif
+    switch (type)
     {
     case 1:
         format = "%Y%m%d-%H%M%S";
@@ -34,7 +43,7 @@ std::string getTime(int type)
         format = "%Y-%m-%d %H:%M:%S";
         break;
     }
-    strftime(tmpbuf, 32, format.data(), local);
+    strftime(tmpbuf, 32, format.c_str(), &local);
     return {tmpbuf};
 }
 
@@ -62,15 +71,20 @@ std::mutex log_mutex;
 
 void writeLog(int type, const std::string &content, int level)
 {
-    if(level > global.logLevel)
+    if (level > global.logLevel)
         return;
     std::lock_guard<std::mutex> lock(log_mutex);
     const char *levels[] = {"[FATL]", "[ERRO]", "[WARN]", "[INFO]", "[DEBG]", "[VERB]"};
-    std::cerr<<getTime(2)<<" ["<<getpid()<<" "<<get_thread_name()<<"]"<<levels[level % 6];
-    std::cerr<<" "<<content<<"\n";
+    std::cerr << getTime(2) << " ["
+#ifdef _WIN32
+              << GetCurrentProcessId()
+#else
+              << getpid()
+#endif
+              << " " << get_thread_name() << "]" << levels[level % 6];
+    std::cerr << " " << content << "\n";
 }
 
-
 #ifdef __GNUG__
 #include <cstdlib>
 #include <memory>
diff --git a/src/utils/printout.h b/src/utils/printout.h
index 4b46d71..79b46ed 100644
--- a/src/utils/printout.h
+++ b/src/utils/printout.h
@@ -3,7 +3,6 @@
 
 #include <string>
 #include <vector>
-#include <unistd.h>
 
 #include "misc.h"
 #include "nodeinfo.h"
