# -*- coding: utf-8; -*-
#
# Licensed to MonkDB Labs Private Limited (MonkDB) under one or more contributor
# license agreements.  See the NOTICE file distributed with this work for
# additional information regarding copyright ownership.  MonkDB licenses
# this file to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.  You may
# obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.

from sqlalchemy.ext.compiler import compiles
from sqlalchemy.sql.expression import ColumnElement, literal


class MonkMatch(ColumnElement):
    """
    Represents a full-text search match expression for SQLAlchemy.

    This class encapsulates the logic for generating a database-specific
    full-text search predicate. It supports specifying the column(s) to search,
    the search term, the match type, and additional options.

    .. note::
        The actual SQL generated by this class depends on the database backend
        being used. You may need to create separate compilation functions
        for different database dialects if their full-text search syntax differs.

    Attributes:
        inherit_cache (bool): Indicates whether the expression's compilation can be cached.
                               Set to True for performance optimization.
    """
    inherit_cache = True

    def __init__(self, column, term, match_type=None, options=None):
        """
        Initializes a new `Match` object.

        Args:
            column: A reference to the column(s) to search within.
                    This can be:
                        - A single SQLAlchemy column object.
                        - An index.
                        - A sub-column.
                        - A dictionary where keys are SQLAlchemy column objects
                          and values are boost factors (for ranking search results).
            term (str): The search term (the text to search for). This string
                        will be analyzed and compared against the full-text index.
            match_type (str, optional): The type of full-text matching to use.
                                        Examples include 'natural language' and 'boolean'.
                                        This value is database-specific. Defaults to None.
            options (dict, optional): A dictionary of options that customize the
                                      behavior of the `match_type`. These options are also
                                      database-specific. Defaults to None.

        Raises:
            ValueError: If `options` is specified without a `match_type`.
        """
        super(MonkMatch, self).__init__()
        self.column = column
        self.term = term
        self.match_type = match_type
        self.options = options

    def compile_column(self, compiler):
        """
        Compiles the column part of the match expression into SQL.

        Handles both single columns and dictionaries of columns with boost values.

        Args:
            compiler: The SQLAlchemy compiler object for the current database dialect.

        Returns:
            str: The SQL representation of the column(s) to search.
        """
        if isinstance(self.column, dict):
            column = ", ".join(
                sorted(["{0} {1}".format(compiler.process(k), v)
                       for k, v in self.column.items()])
            )
            return "({0})".format(column)
        else:
            return "{0}".format(compiler.process(self.column))

    def compile_term(self, compiler):
        """
        Compiles the search term into a SQL literal.

        Args:
            compiler: The SQLAlchemy compiler object for the current database dialect.

        Returns:
            str: The SQL representation of the search term as a literal.
        """
        return compiler.process(literal(self.term))

    def compile_using(self, compiler):
        """
        Compiles the `USING` clause (or its equivalent) for specifying the match type and options.

        Args:
            compiler: The SQLAlchemy compiler object for the current database dialect.

        Returns:
            str: The SQL representation of the `USING` clause, or None if no `match_type` is specified.

        Raises:
            ValueError: If `options` is specified without a `match_type`.
        """
        if self.match_type:
            using = "using {0}".format(self.match_type)
            with_clause = self.with_clause()
            if with_clause:
                using = " ".join([using, with_clause])
            return using
        if self.options:
            raise ValueError(
                "missing match_type. "
                + "It's not allowed to specify options "
                + "without match_type"
            )
        return None

    def with_clause(self):
        """
        Formats the options dictionary into a SQL `WITH` clause.

        Args:
            None

        Returns:
            str: The SQL representation of the WITH clause, or None if no options are specified.
        """
        if self.options:
            options = ", ".join(
                sorted(["{0}={1}".format(k, v) for k, v in self.options.items()]))
            return "with ({0})".format(options)
        return None


def match(column, term, match_type=None, options=None):
    """
    Generates a full-text search match predicate for use in SQLAlchemy queries.

    This function creates a `Match` object, which represents a full-text
    search expression. You can use this function in the `filter` or `where`
    clause of a SQLAlchemy query to perform full-text searches.

    Args:
        column: A reference to a column or an index, or a subcolumn, or a
         dictionary of subcolumns with boost values.

        term (str): The term to match against. This string is analyzed and the
         resulting tokens are compared to the index.

        match_type (str, optional): The match type. Determine how the term is
         applied and the score calculated. Defaults to None.

        options (dict, optional): The match options. Specify match type behaviour.
         (Not possible without a specified match type.) Match options must be
         supplied as a dictionary. Defaults to None.

    Returns:
        Match: A `Match` object representing the full-text search predicate.

    Examples:

    1. **Basic Usage**:

       ```
       from sqlalchemy import create_engine, Column, Integer, String
       from sqlalchemy.orm import sessionmaker
       from sqlalchemy.ext.declarative import declarative_base

       Base = declarative_base()

       class Article(Base):
           __tablename__ = 'articles'
           id = Column(Integer, primary_key=True)
           title = Column(String)
           body = Column(String)

       engine = create_engine('sqlite:///:memory:')
       Base.metadata.create_all(engine)

       Session = sessionmaker(bind=engine)
       session = Session()

       # Adding sample data
       article1 = Article(title="SQLAlchemy Full Text Search", body="This article discusses full-text search with SQLAlchemy.")
       article2 = Article(title="Python ORM", body="SQLAlchemy is a powerful Python ORM.")
       session.add_all([article1, article2])
       session.commit()

       # Querying using full-text search
       results = session.query(Article).filter(match(Article.body, "full-text search")).all()

       for article in results:
           print(f"Title: {article.title}, Body: {article.body}")
       ```

    2. **Using Match Type and Options**:

       ```
       # Assuming you have set up your engine and session as above:

       results_with_options = session.query(Article).filter(
           match(Article.body, "powerful", match_type='boolean', options={'option1': 'value1'})
       ).all()

       for article in results_with_options:
           print(f"Title: {article.title}, Body: {article.body}")
       ```

    Note that you need to ensure that your database supports full-text indexing and that appropriate indexes are created on your columns.
    """
    return MonkMatch(column, term, match_type, options)


@compiles(MonkMatch)
def compile_match(match, compiler, **kwargs):
    """
    Compiles the `Match` object into database-specific SQL.

    This function is registered with SQLAlchemy's compilation system via the
    `@compiles(Match)` decorator. It is responsible for generating the
    correct SQL syntax for the full-text search expression based on the
    database dialect being used.

    Args:
        match (Match): The `Match` object to compile.
        compiler: The SQLAlchemy compiler object for the current database dialect.
        **kwargs: Additional keyword arguments passed by the compiler.

    Returns:
        str: The database-specific SQL representation of the full-text search expression.

    Example:

    ```
    # Example usage in context with an existing query setup

    query_string = compile_match(match_instance, some_compiler)
    print(query_string)  # Outputs something like 'MATCH(column_name) AGAINST("term" IN BOOLEAN MODE)'
    ```
    """

    func = "match(%s, %s)" % (match.compile_column(
        compiler), match.compile_term(compiler))
    using = match.compile_using(compiler)

    if using:
        func = " ".join([func, using])

    return func
