"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[529],{849:(t,e,c)=>{c.r(e),c.d(e,{ApiService:()=>r,apiService:()=>h});var n=c(2457);class s{clearAccountCache(t){for(let e of this.cache.keys())(e.includes("/account/".concat(t))||e.includes("/tasks/".concat(t)))&&this.cache.delete(e)}clearAllCache(){this.cache.clear()}get(t){let e=this.cache.get(t);return e?Date.now()-e.timestamp>this.maxAge?(this.cache.delete(t),null):e.data:null}set(t,e){this.cache.set(t,{data:e,timestamp:Date.now()})}constructor(){this.cache=new Map,this.maxAge=3e5}}let a=new s;class i{createAbortController(t){var e;let c=new AbortController;return t&&(this.activeRequests.has(t)||this.activeRequests.set(t,[]),null===(e=this.activeRequests.get(t))||void 0===e||e.push(c)),c}abortRequestsForAddress(t){t&&((this.activeRequests.get(t)||[]).forEach(t=>{try{t.abort()}catch(t){console.error("Error aborting request:",t)}}),this.activeRequests.set(t,[]))}constructor(){this.activeRequests=new Map}}let o=new i;class r{static getInstance(){return r.instance||(r.instance=new r),r.instance}setAuthenticated(t){this.isAuthenticated=t,console.log("API Service: Authentication state set to ".concat(t))}isPublicEndpoint(t){return["/auth/signin","/auth/create","/wallet/generate","/wallet/address","/health","/server/status"].some(e=>t===e||t.startsWith(e))}async get(t){let e=!(arguments.length>1)||void 0===arguments[1]||arguments[1];if(console.trace("API REQUEST ORIGIN: ".concat(t)),!this.isAuthenticated&&!this.isPublicEndpoint(t))throw console.warn("Blocked unauthenticated GET request to ".concat(t)),Error("Authentication required for ".concat(t));let c=this.getCacheKey(t),n=t.match(/\/account\/([^\/]+)\/|\/tasks\/([^\/]+)/),s=n?n[1]||n[2]:null;if(s&&null!==window.ACTIVE_ACCOUNT&&s!==window.ACTIVE_ACCOUNT)throw console.log("Skipping request for inactive account: ".concat(s)),Error("Account inactive");if(e){let e=a.get(c);if(e)return console.log("Using cached data for ".concat(t)),e}let i=o.createAbortController(s);try{r.logAllRequests&&console.log("API Request:",{endpoint:t,stackTrace:Error().stack,timestamp:new Date().toISOString()}),console.log("[API Request] GET ".concat(t));let n=await fetch("".concat(this.basePath).concat(t),{signal:i.signal});if(!n.ok){let t=await n.text();throw Error("API error (".concat(n.status,"): ").concat(t))}let s=await n.json();return e&&a.set(c,s),s}catch(e){throw e instanceof Error&&"AbortError"===e.name||console.error("API request failed for ".concat(t,":"),e),e}}async post(t,e){if(console.trace("API REQUEST ORIGIN: ".concat(t)),console.log("[API Request] POST ".concat(t),e?"(with data)":""),!this.isAuthenticated&&!this.isPublicEndpoint(t))throw console.warn("Blocked unauthenticated POST request to ".concat(t)),Error("Authentication required for ".concat(t));try{let c=await fetch("".concat(this.basePath).concat(t),{method:"POST",headers:{"Content-Type":"application/json"},credentials:"include",body:e?JSON.stringify(e):void 0});if(!c.ok){let t=await c.text();throw Error("API error (".concat(c.status,"): ").concat(t))}let n=await c.json();if(t.includes("/account/")||t.includes("/tasks/")){let e=t.match(/\/account\/([^\/]+)\/|\/tasks\/([^\/]+)/);if(e){let t=e[1]||e[2];a.clearAccountCache(t)}}return n}catch(t){throw t instanceof TypeError&&t.message.includes("fetch")&&n.Up.manualCheck(),t}}getCacheKey(t,e){return"".concat(t).concat(e?JSON.stringify(e):"")}clearCache(t){a.clearAccountCache(t),o.abortRequestsForAddress(t)}clearAllCache(){a.clearAllCache()}abortRequestsForAddress(t){o.abortRequestsForAddress(t)}constructor(){this.isAuthenticated=!1,this.basePath="/api",void 0===window.ACTIVE_ACCOUNT&&(window.ACTIVE_ACCOUNT=null),console.log("API Service initialized")}}r.logAllRequests=!0;let h=r.getInstance()},2457:(t,e,c)=>{c.d(e,{Up:()=>i,bE:()=>s});var n=c(849);let s="connection_status_changed";class a{startMonitoring(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.intervalId||(this._checkServerConnectivity(t),this.intervalId=setInterval(()=>{this._checkServerConnectivity(t)},5e3))}stopMonitoring(){null!==this.intervalId&&(clearInterval(this.intervalId),this.intervalId=null)}async checkConnection(){try{await n.apiService.get("/health"),this.isConnected||(this.isConnected=!0,this.dispatchConnectionEvent(!0))}catch(t){this.isConnected&&(this.isConnected=!1,this.dispatchConnectionEvent(!1))}}async manualCheck(){try{return await n.apiService.get("/health"),this.isConnected=!0,this.dispatchConnectionEvent(!0),!0}catch(t){return this.isConnected=!1,this.dispatchConnectionEvent(!1),!1}}dispatchConnectionEvent(t){let e=new CustomEvent(s,{detail:{isConnected:t}});window.dispatchEvent(e)}getConnectionStatus(){return this.isConnected}async checkBasicConnectivity(){try{return(await fetch("/api/health",{method:"GET",headers:{"Content-Type":"application/json"}})).ok}catch(t){return console.error("Server connectivity check failed:",t),!1}}async _checkServerConnectivity(t){(t?await this.checkConnection():await this.checkBasicConnectivity())?this.isConnected||(this.isConnected=!0,this.dispatchConnectionEvent(!0)):this.isConnected&&(this.isConnected=!1,this.dispatchConnectionEvent(!1))}constructor(){this.intervalId=null,this.isConnected=!0}}let i=new a}}]);