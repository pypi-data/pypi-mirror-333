import getpass
import http.server
import json
import logging
import os
import secrets
import socketserver
import threading
import urllib.parse
import webbrowser
from datetime import datetime, timedelta
from pathlib import Path

from crow_client.models.app import (
    AuthType,
    FirebaseCreds,
    ProviderResponse,
    Providers,
)

logger = logging.getLogger(__name__)


# This is not a secret, and doesn't need to be hidden
# It's simply a client id for users to know where they are logging into
# This client_id is generated by Google as part of the oauth provisioning ran for our client
CLIENT_ID = "209212876053-6rn7c2q3o64gklc07a90dgsm79jnf9b3.apps.googleusercontent.com"
SCOPE = "openid"


class AuthTokenCache:
    """Cache for storing and retrieving authentication tokens."""

    EXPIRE_BUFFER_IN_MINUTES = 5

    def __init__(self):
        self.cache_dir = Path(
            os.getenv("CROW_AUTH_CACHE_DIR", str(Path.home() / ".crow" / "auth_cache"))
        )
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.token_file = self.cache_dir / "tokens.json"

    def _load_cache(self) -> dict:
        if not self.token_file.exists():
            return {}
        try:
            with open(self.token_file) as f:
                return json.load(f)
        except (OSError, json.JSONDecodeError):
            return {}

    def _save_cache(self, cache_data: dict):
        try:
            with open(self.token_file, "w") as f:
                json.dump(cache_data, f)
        except OSError:
            # If we can't save the cache, just continue without caching
            pass

    def get_token(self, service_uri: str, auth_type: AuthType) -> str | None:
        """Get a cached token if it exists and is not expired."""
        cache = self._load_cache()
        entry = cache.get(f"{service_uri}:{auth_type}")

        if not entry:
            return None

        # Check if token is expired (includes a 5 minute buffer)
        expiry = datetime.fromisoformat(entry["expiry"])
        if datetime.now() + timedelta(minutes=self.EXPIRE_BUFFER_IN_MINUTES) >= expiry:
            return None

        time_until_expiry = (expiry - datetime.now()).total_seconds()
        logger.debug(f"Cached token expires in {round(time_until_expiry)}s")
        return entry["token"]

    def store_token(
        self, service_uri: str, auth_type: AuthType, token: str, expiry: datetime
    ):
        """Store a token in the cache."""
        cache = self._load_cache()
        cache[f"{service_uri}:{auth_type}"] = {
            "token": token,
            "expiry": expiry.isoformat(),
        }
        self._save_cache(cache)

    def clear(self):
        """Clear all cached tokens."""
        if self.token_file.exists():
            self.token_file.unlink()


def get_google_credentials() -> ProviderResponse:
    received_token = None

    class TokenHandler(http.server.SimpleHTTPRequestHandler):
        def handle_callback(self):
            nonlocal received_token
            query = urllib.parse.urlparse(self.path).query
            params = urllib.parse.parse_qs(query)

            if "code" in params:
                received_token = params["code"][0]
                self.send_response(200)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(
                    b"Authentication successful! You can close this window."
                )
                threading.Thread(target=httpd.shutdown).start()
            else:
                self.send_response(400)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(
                    b"Authentication failed! Check the console for details."
                )
                threading.Thread(target=httpd.shutdown).start()

        def do_GET(self):  # noqa: N802
            self.handle_callback()

    with socketserver.TCPServer(("", 0), TokenHandler) as httpd:
        PORT = httpd.server_address[1]

        server_thread = threading.Thread(target=httpd.serve_forever)
        server_thread.daemon = True
        server_thread.start()

        redirect_uri = f"http://localhost:{PORT}"
        auth_params = {
            "client_id": CLIENT_ID,
            "response_type": "code",
            "redirect_uri": redirect_uri,
            "scope": SCOPE,
            "access_type": "offline",
            "state": secrets.token_urlsafe(16),
        }

        auth_url = (
            "https://accounts.google.com/o/oauth2/v2/auth?"
            + urllib.parse.urlencode(auth_params)
        )
        webbrowser.open(auth_url)

        server_thread.join()

        return ProviderResponse(
            provider=Providers.GOOGLE, code=received_token, redirect_uri=redirect_uri
        )


def get_password_credentials() -> FirebaseCreds:
    return FirebaseCreds(email=input("Email: "), password=getpass.getpass("Password: "))
